[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The role of Aesthetics in the Understandings of Source code"}],"tag":"title","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Pierre Depaz\\\\under the direction of Alexandre Gefen (Paris-3)\\\\and Nick Montfort (MIT)"}],"tag":"author","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"ED120 - THALIM"}],"tag":"affiliation","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"last updated:"},{"children":null,"tag":"today","value":""}],"tag":"date","value":"1677780249"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"This thesis investigates how the aesthetic properties of source code enable to the construction of semantic spaces to facilitate the understanding of computer processes. To do so, we highlight how source code aesthetics are contingent to other literary, architectural, and scientific aesthetics, and how this overlap mitigates cognitive friction when engaging with source code as a dynamic, functional and shared interface to the world."}],"tag":"paragraph","value":""}],"tag":"abstract","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Introduction"}],"tag":"chapter","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"chap:introduction"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This thesis is an inquiry into the formal manifestations of source code, into how particular configurations of lines of code allow for aesthetic judgments and on the purposes that such configurations serve. The implications of this inquiry will lead us to consider the different ways in which people read and the different ways in which source code can be represented, depending on what it aims at accomplishing, and on the contexts in which it operates."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This study on source code involves the different groups of people which read and write it, the purposes for which they write it, the programming languages they use to write it, and the natural language they use to speak about it. Most importantly, this thesis focuses on source code as a material and linguistic manifestation of a larger digital ecosystem of software and hardware to which it belongs. Since source code is only one component of code, as we will see below, this thesis also aims at studying the reality of written code, rather than its conceptual interpretations."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Starting from pieces of source code, this thesis will aim at assessing what programmers have to say about it, and attempt to identify how one or more specific"},{"children":[{"children":null,"tag":"literal","value":"aesthetic fields"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"are used to refer to it. This aim depends on two facts: first, source code is a medium for expression, both to express the programmer's intent to the computer"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_craftsman_1982"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and the programmer's intent to another programmer"},{"children":[{"children":null,"tag":"literal","value":"abelson_structure_1979"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"—here we also consider the same individual at two different points in time as two different programmers. Second, source code is a relatively new medium, compared to, say, paint or mechanics. As such, the development and solidification of aesthetic practices—that is, of ways of doing which do not find their immediate justification in a practical accomplishment—is an ongoing research project in computer science, software development and the digital humanities. Formal judgments of source code are therefore existing and well-documented, and are related to a need for expressiveness, as we will see in chapter 2, but their formalization is still an ongoing process."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code thus can be written in a way makes it subject to aesthetic judgments by programmers; that is, code"},{"children":[{"children":null,"tag":"literal","value":"has"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"aesthetics, but it is unclear exactly"},{"children":[{"children":null,"tag":"literal","value":"which"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"aesthetics. Indeed, these aesthetic judgments as they exist today rely on different domains to assess source code, as a means to grasp the cognitive object that is software. These draw from metaphors ranging from literature, architecture, mathematics and engineering. And yet, source code, while related to all of these, isn't exactly any of the them. Like the story of the seven blind men and the elephant"},{"children":[{"children":null,"tag":"literal","value":"chun_sourcery_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", each of these domains touch on some specific aspect of the nature of code, but none of them are sufficient to entirely provide a solid basis for the aesthetic judgments of source code. It is at the crossroads of these domains that this thesis locates its work."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The examination of source code, and of the discourses around source code will integrate both the diversity of ways in which source code can exist, and the invariant aspects which underline all diverse approaches of source code. Particularly, we will see how each groups of practicionners tend to deploy references to underlying, systematic conceptual metaphors drawing from the domains above, but also how these references overlap across groups. The point of overlap, as we will demontrate, is that of"},{"children":[{"children":null,"tag":"literal","value":"using a formal linguistic system to communicate the understanding of complex cognitive structures"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Through an interdisciplinary approach, we attempt to connect this formal symbol system to the broader role of aesthetics as a cognitive mechanism to deal with complexity."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The rest of this introduction will consist in establishing a more complete view of the context in which this research takes place, from computer science to digital humanities and science and technology studies. With this context at hand, we will proceed to highlight the specific problems which will be tackled regarding the current place of aesthetics in source code. After outlining our methodology and the theoretical frameworks which will be mobilized throughout this study, we will sketch out how the different chapters of this thesis will attempt at providing some responses to our research questions."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Context"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:context"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"The research territory: code"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:research-territory"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Most of our modern infrastructure depends, to a more or less dramatic extent, on software systems"},{"children":[{"children":null,"tag":"literal","value":"kitchin_code_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", from commercial spaces to classrooms, transport systems to cultural institutions, scientific production and entertainment products. Software regulates and automates the information stores, exchanges and creation which compose each of these domains of human activities.  The complex processes are described in what is called source code, a vast and invisible set of texts. The number of lines of code involved in running these processes is hard to estimate; one can only rely on disclosures from companies, and publicly available repositories. To give an order of magnitude, all of Google's services amounted to over two billions source lines of code (SLOC)"},{"children":[{"children":null,"tag":"literal","value":"scale_why_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", while the 2005 release of the OSX operating system comprised 86 millions lines of code, and while the version 1.0 of the Linux kernel (an operating system which powers most of the internet and specialized computation) totalled over 175,000 SLOC, version 4.1 jumped to over 19.5 million lines of code in the span of twenty years"},{"children":[{"children":null,"tag":"literal","value":"wikipedia_linux_2021"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Given such a large quantity of textual mass, one might wonder: who reads this code? To answer this question, we must start diving a bit deeper into what source code really is."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code consists in a series of instructions, composed in a particular programming language, which is then processed by a computer in order to be executed. For instance, using the language called Python, the source code in"},{"children":[{"children":null,"tag":"literal","value":"code:simple_example"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"consists in telling the computer to store two numbers in what are called"},{"children":[{"children":null,"tag":"literal","value":"variables"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", then proceeds with describing the"},{"children":[{"children":null,"tag":"literal","value":"procedure"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"for adding the double of the first terms to the second term, and concludes in actually executing the above procedure."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/simple.py"}],"tag":"code","value":"python"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Example of the basic elements of a computer program, written in Python"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:simple_example"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Given this particular piece of source code, the computer will output the number"},{"children":[{"children":null,"tag":"literal","value":"14"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"as the result of the operation"},{"children":[{"children":null,"tag":"literal","value":"(4 * 2) + 6"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":". In this sense, then, source code is the requirement for software to exist: since computers are procedural machines, acting upon themselves and upon the world, they need a specification of what to do, and source code provides such a specification. In this sense, computers are the main \"readership\" of source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"However, it is  also a by-product of software, since it is no longer required once the computer has processed and stored it into a"},{"children":[{"children":null,"tag":"literal","value":"binary"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"representation, a series of 0s and 1s which represent the successive states that the computer has to go through in order to perform the action that was described in the source code."},{"children":[{"children":null,"tag":"literal","value":"Binary code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is what most of the individuals who interact with computers deal with, in the form of packaged applications, such as a media player or a web browser. They (almost) never have to inquire about, or read, such source code. In this sense, then, source code only matters until it gets processed by a computer, through which it realizes its intended function."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From another perspective, source code isn't just about telling computers what to do, but also a key component of a particular economy: that of software development. Software developers are the ones who write the source code and this process is first and foremost a collaborative endeavour. Software developers write code in successive steps, because they add features over time, or they fix errors that have shown up in their software, or they decide to rewrite parts of the source code based on new ideas, skills or preferences. In this case, source code is not used to communicate to the computer what it does, but to other software developers what the"},{"children":[{"children":null,"tag":"literal","value":"intent"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of the software is. Source code is then the locus of human, collaborative work; it represents iterations of ideas, formalization of processes and approaches to problem-solving. As Harold Abelson puts it,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"\"Programs must be written for people to read, and only incidentally for machines to execute.\""},{"children":[{"children":null,"tag":"literal","value":"abelson_structure_1979"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Official definitions of source code straddle this line between the first role of source code (as instructions to a computer) and the second role of source code (as indications to a programmer). For instance, a definition within the context of the Institute of Electrical and Electronics Engineering (IEEE) considers source code"},{"children":[{"children":null,"tag":"literal","value":"any fully executable description of a software system, which therefore includes various representations of this description, from machine code to high-level languages and graphical representations using visual programming languages"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"harman_why_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This definition focuses on the ability of code to be processed by a machine, and mentions little about its readability (i.e. processability by other humans)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"On the other hand, the definition of source code provided by the Linux Information Project"},{"children":[{"children":null,"tag":"literal","value":"https://linfo.org/sourcecode.html"}],"tag":"footnote","value":"1"},{"children":null,"tag":"literal","value":"focuses on source code as"},{"children":[{"children":null,"tag":"literal","value":"the version of software as it is originally written (i.e. typed into a computer), by a human in plain text (i.e. human-readable, alphanumeric characters)."}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"linuxinformationproject_source_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The emphasis here is on source code as the support of human activity, as software developers need to understand the pieces of code that they are creating, or modifying. Source code thus has two kinds of readabilities: a computer one, which is geared towards the correct execution of the program, and a human one, which is geared towards the correct understanding of the program. In the lineage of this human-readability, we can point to the Free Software Foundation's equation of the free circulation and publication of source code with the free circulation of publication of ideas. Particularly, Freedom 1 ("},{"children":[{"children":null,"tag":"literal","value":"The freedom to study how the program works, and adapt it to your needs"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":") and Freedom 2 ("},{"children":[{"children":null,"tag":"literal","value":"The freedom to improve the program, and release your improvements to the public, so that the whole community benefits."}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":") as stated in the FSF's definition of Free Software stipulates that access to source code is required to support these freedoms, a version of source code that is"},{"children":[{"children":null,"tag":"literal","value":"not concealed"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", i.e. readable by both human and machine"},{"children":[{"children":null,"tag":"literal","value":"stallman_free_2002"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In addition to this ability to communicate the ideas latent in it, source code, as an always potentially collaborative object, can be the locus of multiple subjectivities coming together. As Krysa and Sedek state in their definition,"},{"children":[{"children":null,"tag":"literal","value":"source code is where change and influence can happen"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and where"},{"children":[{"children":null,"tag":"literal","value":"intentionality and style are expressed"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"fuller_software_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In their understanding, source code shares some features with natural languages as an intersubjective process"},{"children":[{"children":null,"tag":"literal","value":"voloshinov_marxism_1986"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and as such is different from the machine language representation of a program, an object which they do not consider source code due to its unilaterality. The intelligibility of source code, they continue, facilitates its circulation and duplication among programmers. It is this aspect of a socio-technical object that we consider as important as its procedural effectiveness."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In this research, we build on these definitions to propose the following:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Source code is defined as one or more text files which are written by a human or by a machine in such a way that they elicit a meaningful and succesfully actionable response from a digital compiler or interpreter, and describe a software system. These text files are the starting point to produce an execution of the system described, whether the very first starting point, or an intermediate representation used for subsequent compilations. These files are collectively called"},{"children":[{"children":null,"tag":"literal","value":"program texts"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This definition takes into account a broad view of source code, including steps such as intermediate representations (transitory representations from one version of the source to another one), but also obfuscations (deliberately complicating the code to prevent human-readability while maintaining machine-readability) and minifications (reducing the amount of characters used in source code to its minimum). This will allow us to compare human-authorship of source code, machine-authorship, and hybrid modes, in which a human writes unreadable code with the help of tools. One aspect that is being more narrowly defined for the purpose of this study is the actual manifestation of code: while multiple media for source code exist, we exclude here all of those that are not written in the UTF-8 character set—i.e. textual representations. Since one of the questions of this study is to examine the literariness of source code aesthetics, other forms of source code, such as visual programming languages or biological computation, stand outside the scope of this study and should be investigated in subsequent work."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As for the term"},{"children":[{"children":null,"tag":"literal","value":"program text"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", it is chosen in order to highlight the dual nature of source code: that of a computational artefact to be formally processed and unambiguously understood"},{"children":[{"children":null,"tag":"literal","value":"detienne_software_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and that of a open-ended, multi-layered document, in the vein of Barthes' distinction between a text and a work"},{"children":[{"children":null,"tag":"literal","value":"barthes_bruissement_1984"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Beautiful code"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:beautiful-code"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Under this definition of source code textually represented, we now turn to the existence of the aesthetics of such"},{"children":[{"children":null,"tag":"literal","value":"program texts"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". To contextualize this existence, we first need to touch upon the history and practice of software development. As an economic activity, software development came from a bottom-up dynamic, a"},{"children":[{"children":null,"tag":"literal","value":"de facto"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"activity which was not expected in the early days of computing, where most of the work was divided between mathematics and engineering. Its earliest manifestation can be found in the physical rewiring process of mainframes in order to perform a specific computation, something more akin to firmware than to software. These rewiring tasks were done by mostly female assistants, under the direction of mostly male mathematicians"},{"children":[{"children":null,"tag":"literal","value":"chun_software_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and consisted in a simple translation task which did not require any particular attention, or any particular skill. The recognition of software engineering as its own field came as its unique domain of expertise was required in larger engineering projects—for instance, the term"},{"children":[{"children":null,"tag":"literal","value":"software engineering"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"was coined in the late 1960s by Margaret Hamilton and her team as they were working on the Apollo 11 Lunar Module software"},{"children":[{"children":null,"tag":"literal","value":"mindell_digital_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In the same decade, the first volume of"},{"children":[{"children":null,"tag":"literal","value":"The Art of Computer Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", by Donald Knuth, addresses directly both the existence of programming as an activity separate from both mathematics and engineering, as well as an activity with an \"artistic\" dimension"},{"children":[{"children":null,"tag":"literal","value":"knuth_art_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The first volume opens on the following paragraph:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The process of preparing programs for a digital computer is especially attractive, not only because it can be economically and scientifically rewarding, but also because it can be an aesthetic experience much like composing poetry or music. This book is the first volume of a multi-volume set of books that has been designed to train the reader in the various skills that go into a programmer's craft."},{"children":[{"children":null,"tag":"literal","value":"knuth_art_1997"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Considered one of the most canonical textbooks in the field,"},{"children":[{"children":null,"tag":"literal","value":"The Art of Computer Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"highlights two important aspects of programming for our purpose: that it can be an aesthetic experience and that it is the result of a craft, rather than of a highly-formalized systematic process, as we will see in chapter 1. Some of the aeshetic references related to source code are related to its writing and reading being a craft-like activity"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_craftsman_1982"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Craftsmanship is an essentially fleeting phenomenon, a practice rather than a theory, in the vein of Michel De Certeau's"},{"children":[{"children":null,"tag":"literal","value":"tactics"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":", bottom-up actions informally designed and implemented by the users of a situation, product or technology as opposed to"},{"children":[{"children":null,"tag":"literal","value":"strategies"}],"tag":"italic","value":""},{"children":[{"children":null,"tag":"literal","value":"certeau_invention_1990"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", in which ways of doing are deliberately prescribed in a top-down fashion. Craft is hard to formalize, and the development of expertise in the field happens through practice as much as through formal education"},{"children":[{"children":null,"tag":"literal","value":"sennett_craftsman_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". It is also one in which function and beauty exist in an intricate, embodied and implicit relationship, based on subjective qualitative standards rather than strictly external measurements, with the former rarely being explicitly stated"},{"children":[{"children":null,"tag":"literal","value":"pye_nature_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Approaching programming (the activity of writing and reading code) as a craft"},{"children":[{"children":null,"tag":"literal","value":"levy_programmation_1992"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"connects to the multiple testimonies of encountering beautiful code, some of which have made their ways into edited volumes or monographs"},{"children":[{"children":null,"tag":"literal","value":"oram_beautiful_2007,chandra_geek_2014,gabriel_patterns_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Additionally, informal exchanges among programmers on forums, mailing lists, blog posts and code repositories"},{"children":[{"children":null,"tag":"literal","value":"See Annex for the list of collected corpus"}],"tag":"footnote","value":"2"},{"children":null,"tag":"literal","value":"often mention beautiful code, either as a central discussion point or simply in passing. These testimonies constitute the first part of our corpus, as sources in which programmers comment on the aesthetic dimension of their practice. The second part of the corpus is composed of selected program texts, which we will examine in order to identify and formalize which aspects of the textual manifestation of software can elicit an aesthetic experience."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"So the existence of something akin to art, something beautiful and pleasurable emerging from the reading and writing of source code has been acknowledged since the 1960s, in the early days of programming as a self-contained discipline. However, the formalization of an aesthetics of source code first requires a working definition of the concept of"},{"children":[{"children":null,"tag":"literal","value":"aesthetics"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"as used in this study."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"There is a long history of aesthetic philosphical inquiries in the Western tradition, from beauty as the imitation of nature"},{"children":[{"children":null,"tag":"literal","value":"Plato, Republic"}],"tag":"footnote","value":"3"},{"children":null,"tag":"literal","value":", moral purification"},{"children":[{"children":null,"tag":"literal","value":"Aristotle, Poetics; Kant, Critique of the Power of Judgment"}],"tag":"footnote","value":"4"},{"children":null,"tag":"literal","value":", cognitive perfection"},{"children":[{"children":null,"tag":"literal","value":"Leibniz, Ars Combinatoria"}],"tag":"footnote","value":"5"},{"children":null,"tag":"literal","value":", sensible representations with emotional repercussions"},{"children":[{"children":null,"tag":"literal","value":"Baumgarten, Aesthetics"}],"tag":"footnote","value":"6"},{"children":null,"tag":"literal","value":". The common point of these definitions is that of"},{"children":[{"children":null,"tag":"literal","value":"sensual manifestation"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", that is the set of visible forms which can enable an"},{"children":[{"children":null,"tag":"literal","value":"aesthetic experience"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", a cognitive state of pleasure relying on, amongst others, an object, a sense of unity and of discovery"},{"children":[{"children":null,"tag":"literal","value":"beardsley_aesthetic_1970"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The definition of aesthetics that we will use in this thesis starts from this requirement of sense perception, and then builds upon it using two theoretical frameworks: Nelson Goodman's theory of symbols"},{"children":[{"children":null,"tag":"literal","value":"goodman_languages_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and Gérard Genette's distinction between fiction and diction"},{"children":[{"children":null,"tag":"literal","value":"genette_fiction_1993"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The former provides us with an analysis of formal systems in aesthetic manifestations and their role in a cognitive process, while the second offers a broadened perspective on what qualifies as textual arts, or literature."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Goodman's view on aesthetics is an essentially communicative one: we use aesthetics to carry across more or less complex concepts. This communication process happens through various symbol systems (e.g. pictural systems, linguistic systems, musical systems, choreographic systems), the nature and organization of which can elicit an aesthetic experience. His conception of such an aesthetic experience isn't one of self-referential composition, or of purely emotional pleasure, but a cognitive one, one which belongs to the field of epistemology"},{"children":[{"children":null,"tag":"literal","value":"goodman_languages_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The symbol systems involved in the aesthetic judgment bear different kinds of relations to the worlds they refer to—such as denoting, representing, ressembling, exemplifying— and their purpose is to communicate a truth about these worlds"},{"children":[{"children":null,"tag":"literal","value":"goodman_ways_1978"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In Goodman's view, the arts and the sciences are, in the end, two sides of the same coin. They aim at providing conceptual clarity through formal, systematic means, and the arts—understood here in the broad, Renaissance sense of liberal arts—can and should be approached with the same rigor as the sciences. In our case, programming, with its self-proclaimed craft-like status and its mathematical roots, stands equally across the arts and sciences."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"His use of the term"},{"children":[{"children":null,"tag":"literal","value":"languages"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"implies a broader set of linguistic systems than that of strictly verbal ones. This approach will support our initial conception of programming languages as verbal systems, but will allow us not to remain constrained by traditional literary aesthetics such as verse, rhyme or alliteration. To what extent is programming a linguistic activity is going to be one of the main inquiries of this thesis, and Goodman's extended, yet rigorous definition leaves us room to explore the semantic and syntactic dimension of source code as one of those languages of art. Programming languages as symbol systems will be explored further in Chapter 5."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With this analytical framework allowing us to analyze the matter at hand—program texts composed by a symbol system with an epistemic purpose—we turn to a more literary perspective on aesthetics. Genette's approach to literature,"},{"children":[{"children":null,"tag":"literal","value":"the art of language"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", results in the establishment of two dichotomies: fiction/diction, and constitutivity/conditionality. In"},{"children":[{"children":null,"tag":"literal","value":"Fiction and Diction"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"genette_fiction_1993"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", he extends previous conceptions of literature and poetics, from Aristotle to Jakobson, in order to broaden the scope of what can be considered literature, by questioning the conditions under which a text is given a literary status. As such, he establishes the existence of conditional literature alongside constitutive literature: the former gains its status of a literary text from the individual, subjective aesthetic judgment bestowed upon it, while the latter relies on pre-exisiting structures, themes and genres. This approach paves the way for an extending of the domain of literature"},{"children":[{"children":null,"tag":"literal","value":"gefen_extension_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and a more subtle understanding of the aesthetic manifestation in an array of textual works."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Genette also makes the distinction between fiction, with the focus being the potentiality of a text's object, its imaginative qualities and themes, and diction, with an emphasis on the formal characteristics of the text. Since code holds two existences, one as executed, and one as written, I propose to map Genette's concept of fiction on to source code when the latter is considered as a purely functional text—i.e. what the source code ultimately does in its domain of application. Because source code always holds software as a potential within its markings, its diction, waiting to be actualized through execution, one has to imagine what this code actually does. Written source code, then, could either be judged primarily on its fiction or on its diction. Since we focus on the written form of source code, and not on the type of its purpose, an attention to diction will be the entry point of this thesis."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A first approach to source code could be"},{"children":[{"children":null,"tag":"literal","value":"constitutive"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in Genette's terms: a given program text could be considered aesthetically pleasing because the software it generates abides by some definitions of being aesthetically pleasing"},{"children":[{"children":null,"tag":"literal","value":"For instance, Venustas, Firmitas, Utilitas; See Fishwisck, P. (éd),"},{"children":[{"children":null,"tag":"literal","value":"Aesthetic Computing"}],"tag":"emph","value":""}],"tag":"footnote","value":"7"},{"children":null,"tag":"literal","value":", or because the software itself is considered a piece of art, shown in exhibitions and sold in galleries. However, our empirical approach to source code aesthetics, by examining various program texts directly, and our inquiry into the possibility of multiple aesthetic fields co-existing within source code as a symbol system, asks us to forgo this constitutive definition of an aesthetic work as normative categories within software development. Our focus on sense perception within aesthetics starts from a conditional approach, in which programmers emit an aesthetic judgment on a program text, with an emphasis first on what the source code"},{"children":[{"children":null,"tag":"literal","value":"is"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and only secondly on what it"},{"children":[{"children":null,"tag":"literal","value":"does"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"As we have seen with Goodman, there is nonetheless a tight connection between those to states."}],"tag":"footnote","value":"8"},{"children":null,"tag":"literal","value":". This conditional approach implies that we use a conception of the aesthetic that is broader than the artistic and the beautiful, encompassing less dramatic qualifiers, such as"},{"children":[{"children":null,"tag":"literal","value":"good"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"nice"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Diction, then, focuses on the formal characteristics of the text. The point here is not to assume an autotelic mode of existence for source code, but rather to acknowledge that there is a certain difference between the content of software and the form of its source—good software functioning beautifully can be written poorly, and poor, buggy software can be written beautifully. This thesis chooses to focus on the formal aspects of code such as not to restrict ourselves to any specific kind, or genre, of program texts, leaving open the possibility for these categories to emerge after our analysis."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"So, following Genette's re-asking of the Goodman's question of"},{"children":[{"children":null,"tag":"literal","value":"When is art?"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"rather than the historical"},{"children":[{"children":null,"tag":"literal","value":"What is art?"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", we can now proceed with our understanding of aesthetics as a set of physical manifestations which can be grasped by the senses, akin to \"the movement of a light, the brush a fabric, the splash of a color\""},{"children":[{"children":null,"tag":"literal","value":"ranciere_aisthesis_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", which aim at enabling a cognitive, communicative purpose, and which are not exclusively constituted by pre-existing categories."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This overview of the theoretical frameworks of this thesis already implicitly denotes the boundaries of this study. The domain we are investigating here is one that is delimited by both medium and purpose. First, the medium limitations is that of text, in its material sense, as mentioned above in our definition of source code. Second, the purpose limitation is that of computable code, rather than computed code: we are examining latent programs, with their reality as texts and their virtuality as actions, rather than the other way around. Executed software and its set of affordances (e.g. graphical user interfaces"},{"children":[{"children":null,"tag":"literal","value":"gelernter_machine_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", real-time interactivity"},{"children":[{"children":null,"tag":"literal","value":"laurel_computers_1993"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and process-intensive developments"},{"children":[{"children":null,"tag":"literal","value":"murray_hamlet_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":") differ from the literary and architectural ones that software, in its written form, is claimed to exhibit. However, executable and executed software, being to sides of the same coin, might suggest causal relationships—e.g. the aesthetics of source code affecting the aesthetics of software—and such an inquiry would be best reserved for a subsequent study."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Now that we have explicited our object of study—the formal manifestations of software under its textual form—we can turn to a review of the research that has alredy been done on the subject, before highlighting some of the limitations. These relations between source code and aesthetics have been addressed by academic studies through different, separate dynamics."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Literature review"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:literature-review"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A literature review on this topic must address the dualistic nature of studies on source code, as research can be distinguished between the fields of computer science and engineering on one side, and that of the humanities on the other. This overview will provide us with a better sense of which aspects of code and aesthetics have been explored until now, and will invite us to address the remaining gaps."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We have seen that most technical literature, starting from"},{"children":[{"children":null,"tag":"literal","value":"The Art of Computer Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", acknowledges the role that aesthetics have to play in the writing and reading of program texts. Along with the positions of Knuth and Djikstra regarding the importance of paying attention to the aspects of programming practice"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_chapter_1972"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"which go beyond strictly mathematical and engineering requirements, Kerninghan and Plauer publish in 1978 their"},{"children":[{"children":null,"tag":"literal","value":"Elements of Programming Style"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"kernighan_elements_1978"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In it, they focus on how code snippets with a given intent could be rewritten in order to keep the same intent but gain in quality—that is, in readability and understandability. For instance, the following program:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/verbose.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"A very verbose way to left pad a digit with zeroes in the C language."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:verbose_c"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"can be rewritten as:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/verbose_refactored.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"A very terse way to left pad a digit with zeroes in the C language."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:verbose_refactored_c"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"which keeps the exact same functionality, but becomes much clearer. Why it becomes much clearer, though, is thought to be a given for the reader, and not explicited by the authors in terms of concepts such as cognitive surface, repleteness of a symbol system or representation of the main idea(s) at play (promoting an integer to a character, rather than individually checking for each integer case). As the authors do employ terms which will form the basis of an aesthetics of software development, such as clarity, simplicity, or expressiveness, there are nonetheless no overarching principles deployed to systematize the manifestation of such principles, only examples are given."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While Kernighan and Plauer do not directly address the relationship of source code and aesthetics, this is something that Peter Molzberger undertakes five years later through an empirical, qualitative study aimed at highlighting the place aesthetics play in an expert programmer's practice"},{"children":[{"children":null,"tag":"literal","value":"molzberger_aesthetics_1983"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Molzberger's study touches upon ideas of over-arching structure, tension between clarity and personality, and levels of expertise in aesthetic judgment. This short paper highlights multiple instances of code deemed beautiful which will be explored further in this thesis, without providing an answer as to"},{"children":[{"children":null,"tag":"literal","value":"why"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"this might be the case. For instance, a conception of code as literature does not explain instances involving switch in scales and directions of reading, or a conception of code as mathematics does not explain the explicitly required need for a personal touch when writing source code"},{"children":[{"children":null,"tag":"literal","value":"molzberger_aesthetics_1983"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the context of formal academic research, such as the IEEE or the Association for Computing Machinery (ACM), subsequent research focuses on how to quantitatively assess a given quality of source code either through a social perspective on the process of writing"},{"children":[{"children":null,"tag":"literal","value":"norick_effects_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a semantic perspective on the lexicon being used"},{"children":[{"children":null,"tag":"literal","value":"fakhoury_improving_2019,guerrouj_normalizing_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", an empirical study of programming style in the efficiency of software teams"},{"children":[{"children":null,"tag":"literal","value":"reed_sometimes_2010,coleman_aesthetics_2018"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"or on the visual presentation of code in the comprehension process"},{"children":[{"children":null,"tag":"literal","value":"marcus_graphic_1982"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". These focus on the connection of aesthetics with the performance of software development—beautiful code as being related to a good end-product. These methodologies are mostly quantitative, and do not take into account the \"artistry\" and \"craft\" component as laid out by Knuth and Molzberger, but are rather a big-data representation of Kernighan and Plauer's approach."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The development of software engineering as a profession has led to the publication of several books of specialized literature, taking a practical approach to writing good code, rather than a scientific one. Robert C. Martin's"},{"children":[{"children":null,"tag":"literal","value":"Clean Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"'s audience belongs to the fields of business and professional trade, drawing on references from architecture, literature and craft in order to lay out the requirements of what he considers to be clean code. These specific mechanisms are highlighted in terms of how they will support a productive increase in the quality of software developed, as opposed as being satisfying in and of themselves."},{"children":[{"children":null,"tag":"literal","value":"Clean Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"was followed by a number of additional publications on the same topic and with the same approach"},{"children":[{"children":null,"tag":"literal","value":"fowler_refactoring_1999,arns_code_2005,hunt_pragmatic_1999"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Here, these provide an interesting counterpoint to academic research on quality code by relying on different traditions, such as the practical handbook, to explain why the way code is written is important."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Technical and engineering literature, then, establish the existence of and need for aesthetics, presented as formal properties which then constitute"},{"children":[{"children":null,"tag":"literal","value":"quality code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". The methodology in these studies is either empirical, in the case of academic articles, looking at large corpora, more rarely interviewing programmers in order to draw conclusions regarding this relationship between formal properties and quality, while monographs and business literature draw on the experiences of their authors as a programmers to provide source code examples of specific principles, without extending on the rationale and coherence of these principles, let alone within a source code-specific aesthetic framework. A particularly salient example is Greg Oram's edited volume"},{"children":[{"children":null,"tag":"literal","value":"Beautiful Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in which expert programmers are invited to pick a piece of code and explain why they like it, sometimes commenting it line by line"},{"children":[{"children":null,"tag":"literal","value":"oram_beautiful_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This very concrete, empirical inquiry into what makes source code beautiful does no, however, include a strong enough conclusion as to what"},{"children":[{"children":null,"tag":"literal","value":"actually"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"makes code beautiful, but rather writing why they like the idea behind the code, or manifestoes such as Matz's"},{"children":[{"children":null,"tag":"literal","value":"Code as an Essay"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". As such, this monograph will be integrated in our corpus, as commentary rather than academic research. Another limitation to these studies is that they only address one specific group of programmers, and one specific type of software being written. In effect, those who write and read source code are far from being a homogeneous whole, and can be placed along distinct lines—e.g. academics, tinkerers or artists—with distinct practices and standards"},{"children":[{"children":null,"tag":"literal","value":"hayes_cultures_2017"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In none of these studies is it considered whether the conclusions established for one group would be valid for the others."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Before we move on to the perspective of the humanities, one should also note the specific field of philosophy of computer science, which inquires into the nature of computation, from ontological, epistemological and ethical points of view. These are useful both in the meta positioning they take regarding computer science as they well as how they show that issues of representation, interpretation and implementation are still unresolved in the field. Particularly, Rapaport's"},{"children":[{"children":null,"tag":"literal","value":"Philosophy of Computer Science"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"provides an exhaustive literature review of the different fields which computer science is being compared to, from mathematics, engineering and art but—interestingly—few references to computer science as having any kind of relation with literature"},{"children":[{"children":null,"tag":"literal","value":"rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Another, more specific perspective is given by Richard P. Gabriel in his"},{"children":[{"children":null,"tag":"literal","value":"Patterns of Software"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in which he looks at software as a similar endeavour as architecture, drawing on the works of Christopher Alexander. The focus is on its creative and relationship to patters, a subject we will investigate more in chapter 3. Finally, Brian Cantwell-Smith's introduction to his upcoming"},{"children":[{"children":null,"tag":"literal","value":"The Age of Significance: An Essay on the Origins of Computation and Intentionality"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"touches upon these similar ideas of intentionality by suggesting both that computation might be more productively studied from a humanities or artistic point of view than form a strictly scientifc point of view"},{"children":[{"children":null,"tag":"literal","value":"smith_origin_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". These philosophical inquiries into computation mention aesthetics mostly on the periphery, but nonetheless challenge the notion of computation as strictly functional, and suggest additional that perspectives on the topic are needed, including that of the arts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From a humanities perspective, recent literature taking source code as the central object of their study covers fields as diverse as literature, science and technology studies, humanities and media studies and philosophy. Each of these monographs, edited volumes, catalog articles, book chapters or PhD theses, engage with code in its multiple intricacies. Software applications, source code excerpts, programming environments and languages are included in each of these works as primary sources, are considered as text to be read, examined and interpreted."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A first look at"},{"children":[{"children":null,"tag":"literal","value":"Aesthetic Computing"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", edited by Paul A. Fishwick allows us to higlight one of the important points of this thesis: the collection of essays in this collected volume focus more often on the graphical output of the software's work from the end-user's perspective than on the textual manifestations of their source (e.g. Nake and Grabowski's essay on the interface as aesthetic event)"},{"children":[{"children":null,"tag":"literal","value":"fishwick_aesthetic_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As for most studies of aesthetics within computer science, the main focus is on Human-Computer Interaction (HCI) as the art and science of presenting visually the output and affordances of a running program. While a vast and complex field, this is not the topic of this thesis which, rather than focusing on the aesthetics of the computable and executable, is limited to the aesthetics of the computed (texts)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The following works, because of their dealing with source code as text, and due to the background of their authors in literature and comparative media studies, incorporate some aspect of literary theory and criticism, and authors such as N. Katherine Hayles, Maurice J. Black and Alan Sondheim rely on it as their principal perspective. Black, in his PhD dissertation"},{"children":[{"children":null,"tag":"literal","value":"The Art of Code"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"black_art_2002"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"initiates the idea of a cross between programming and literature, and hypothesizes that writing source code is an act that is closer to modernism than postmodernism, as it relies on concepts of authorship, formal linguistic systems and, to some extent, self-reference. The aim of the study is to show how code functions with its own aesthetic, one which is distinct and yet closely related to a literary aesthetic. After highlighting how the socio-political structures of computing since the 1950s have affected the constitution of the idea of a code aesthetic both in professional and amateur programmers, Black moves towards the examination of code practices as aesthetic practices. Here, Black limits himself to the presentation of coding practices insofar as they are identified and referred to as aesthetic practices, but exclusively through a social, second-hand account, rather than formal, definition of a source code aesthetic."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Black  establishes programming as literature, and vice-versa, he assumes that it is possible to write about literature through the lens of source code. However, the actual analysis of source code with the help of formal literary theories is almost entirely side-stepped, mentioning only Perl poetry as an overtly literary use of code. In summary, Black provides a first study in code as a textual object and as a textual practice whose manifestations programmers care deeply about, but does not address what makes code poetry different in its writing, reading and meaning-making than natural-language poetry."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"N. Katherine Hayles, in"},{"children":[{"children":null,"tag":"literal","value":"My Mother Was A Computer: Digital Subjects and Literary Texts"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"hayles_my_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and particularly in the"},{"children":[{"children":null,"tag":"literal","value":"Speech, Writing, Code: Three Worldviews"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"essay temporarily removes code from its immediate social and historical situations and establishes it as a cognitive tool as significant in scale as those of orality and literacy"},{"children":[{"children":null,"tag":"literal","value":"ong_orality_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and attempts to qualify this worldview both in opposition to Saussure's"},{"children":[{"children":null,"tag":"literal","value":"parole"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and Derrida's"},{"children":[{"children":null,"tag":"literal","value":"trace"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", following cybernetics and media studies thinkers such as Friedrich Kittler and Mark B. Hansen. Specifically, she introduces the idea of a Regime of Computation, which relies on the conceptual specificities of code-based expression (among which: depth, dynamism, fragmentation, etc.). Source-code specific contributions touch upon literary paradigms and cognitive effect in two ways. First, she highlights the way code recombines some traditional dialectics of literary theory, namely paradigmatic/syntagmatic, discreete/continuous, compilation/interpretation, and flat/stacked languages, acting as such as clearly different mode of expression. Second, she draws on a comparison between two main programming paradigms, object-oriented programming and procedural programming, and on the syntax of programming languages, such as C++, in order to highlight a novel relationship between the structure and the meaning of programming texts, a structure which depends on its degree of similarity with natural languages."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While Hayles provides the basis for a much deeper analysis of source code's formal literary properties, she also maintains that source code studies should keep in mind the ever-underlying materiality that this very source code relies on; and then locates this materiality in the embodiment of users and readers, along with authors such as Mark Hansen"},{"children":[{"children":null,"tag":"literal","value":"hansen_bodies_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", Bernadette Wegenstein"},{"children":[{"children":null,"tag":"literal","value":"wegenstein_bodies_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and Pierre Lévy"},{"children":[{"children":null,"tag":"literal","value":"levy_programmation_1992"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Beyond the brief acknowledgment that she has of the political and economical conditions of software development and their impact on electronic texts, Hayles also stops short of considering programming languages in their varieties, and the material apparatuses which support them (documentation, architectures, compilers, tutorials, conferences and communities). Building on this approach, a conception of programming languages as a material seems like a possible avenue for looking into the formal possibilities they afford."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Alan Sondheim's essay"},{"children":[{"children":null,"tag":"literal","value":"Codework"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"sondheim_introduction_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", as the introduction of the American Book Review issue dedicated to this specific form, provides another aspect of poetry which integrates source code as a creole language emerging from the interplay of natural and machine languages. Yet, this specific aspect of literary work scans the surface of code rather than with its structure and therefore provides more insight in the anthropology of how humans represent code through speech, rather than representing speech through code. This presents a somewhat postmodern view of programming languages, forcing them upon a relational, mutable conception of language as as series speech-acts, and leaving aside their structural and post-structural characteristics. Codework is essentially defined by its content and"},{"children":[{"children":null,"tag":"literal","value":"milieu"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", one which focuses on human exchanges and bypasses any involvement of machine-processing."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another perspective on the relationship between speech and code is explored by Geoff Cox and Alex Mclean in"},{"children":[{"children":null,"tag":"literal","value":"Speaking Code: Coding as Aesthetic and Political Expression"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"cox_speaking_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". They establish reading, writing and executing source code as a speech-act, extending J.L. Austin's theory to a broader political application by including Arendt's approach of human activities and labor"},{"children":[{"children":null,"tag":"literal","value":"arendt_human_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", from which coding is seen as the practice of producing laboring speech-acts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"They consider source code as a located, instantiated presence, understood as a politically semantic object affecting the multiple economic, social and discursive environments in which it lives. Focusing on speech particularly, this study doesn't quite address the syntactic specificities of codes, for example by looking at the use of loops, arrays, or other syntactical structures briefly touched upon by Hayles. Side-stepping the particular grammatical features of that speech, the authors nonetheless often illustrate the points they are working through, or begin developing those points, with snippets of code written by either McLean or established software artists, thus engaging with details of source code and taking a step away from the dangers of fetishizing code, or"},{"children":[{"children":null,"tag":"literal","value":"sourcery"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"chun_sourcery_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". They include both deductive code (commenting existing source code) or inductive code (code written to act as an example to a point developed by the authors), in a show of the intertextuality of program texts and natural texts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Away from the cultural relevance of code as developed by Cox and McLean, Florian Cramer focuses on the cultural history of writing in computation, tying our contemporary fascination with source code into an older web of historical attempts at integrating combinatorial practices from Hebraic texts to Leibniz's universal languages"},{"children":[{"children":null,"tag":"literal","value":"cramer_words_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". It is in this space between magic and logic that Cramer locates today's experiments in source code (i.e. source code poetry, esoteric languages and codeworks), reminiscent of Simondon's definition of a technical object's essence"},{"children":[{"children":null,"tag":"literal","value":"simondon_mode_1958"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". By relocating it between magic and reality, code is no longer just arbitrary symbols, or machine instructions but also ideal execution, a set of discreete forms which relate to the totality of the world. Once formal execution is considered a cosmogonical force, it becomes synonymous with performative execution, through which it ties back to cultural practices throughout the ages, within both religious and scientific contexts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Cramer extracts five axes along which to apprehend code-based works: totality/fragmentation, rationalization/occultation, hardware/software, syntax/semantics, artificial/natural language. While all these axes overlap each other, it is the"},{"children":[{"children":null,"tag":"literal","value":"syntax/semantics"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"axis which aligns most with this research, givent that these thematical axes are all variations of one another. Towards the end of the book, his development of the concept of speculative programming is also particularly fruitful as the attempt to become a figure of thought and reflection in theory and artistic practice. Cramer states:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"formalisms ["},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"] have a cultural semantics of their own, even on the most primitive and basic level. With a cultural semantics, there inevitably is an aesthetics, subjectivity and politics in computing."},{"children":[{"children":null,"tag":"literal","value":"cramer_words_2003"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This points to the relationship between the formal disposition of source code within program texts and the cultural communities composed of the writers and readers of these program texts. As we have seen, code does have social components of varying natures, insofar as it operates as an expressive medium between varying subjects."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Adrian MacKenzie approaches source code, as part of a broader inquiry on the nature of software, through this social lens in"},{"children":[{"children":null,"tag":"literal","value":"Cutting Code: Software and Sociality"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"mackenzie_cutting_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The author focuses on a relational ontology of software, rather than on a phenomenology: it is defined in how it acts upon, and how it is being acted upon by, external structures, from intellectual property frameworks to design philosophies in software architectures; it only provides an operational definition—software is what it does. His analysis of source code poetry focuses on famous Perl poems, Jodi's artworks and Alex McLean's"},{"children":[{"children":null,"tag":"literal","value":"forkbomb.pl"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", concerned with the executability of code as its dominant feature, dismissing Perl poetry as \""},{"children":[{"children":null,"tag":"literal","value":"a relatively innocuous and inconsequential activity"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" "},{"children":[{"children":null,"tag":"literal","value":"mackenzie_cutting_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". While software could indeed be a \"patterning of social relations\""},{"children":[{"children":null,"tag":"literal","value":"mackenzie_cutting_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", these social relations also take place through linguistic combinations in program texts. This tending to the material realities of software embedded within social and cultural networks and traditions is echoed in David M. Berry's"},{"children":[{"children":null,"tag":"literal","value":"The Philosophy of Software: Computation and Mediation in the Digital Age"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". His definition of materialities, however, focuses on the technical and social processes"},{"children":[{"children":null,"tag":"literal","value":"around"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"code (e.g. build processes, specifications, test suites), rather than on the processes"},{"children":[{"children":null,"tag":"literal","value":"within"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"code (i.e. texts, languages). While this former definition results in what he calls a"},{"children":[{"children":null,"tag":"literal","value":"semiotic place"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"berry_philosophy_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a location in which those processes are organized meaningfully, such a semiotic sense of space could also apply, as we will see in chapter 2, to those intrinsic properties of source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Focusing specifically on the category of code poetry, Camille Paloque-Berges published, a couple of years later,"},{"children":[{"children":null,"tag":"literal","value":"Poétique des codes sur le réseau informatique"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"paloque-berges_poetique_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This work deploys both linguistic and cultural studies theorists such as Barthes and De Certeau in order to explain these playful acts of source code poetry, along with works of esoteric languages and net.art. While the first chapter focuses on digital literature as the result of executed code in order to develop a heuristic to approach source code, and the third and last chapter focusing on the means of distribution of these works, particularly on the development of net.art, 1337 5p43k and codeworks, the second chapter is the most relevant to our research focus. In it, Paloque-Berges provides an introduction of creative acts in source code on both a conceptual level (drawing from Hayles and Montfort) and on a technical, syntactical level. She looks at specific programming patterns and practices ("},{"children":[{"children":null,"tag":"literal","value":"hello world"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", quines), technical syntax (e.g."},{"children":[{"children":null,"tag":"literal","value":"$"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"@"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"as Perl tokens for expressing singular or plurals) and cultural paradigms (De Certeau's tactics and strategies), as she attempts to highlight the specificities of source code for aesthetic manifestation and invites further work to be done in this dual vein of close-reading and theoretical contextualization, beyond specific, heightened instances such as Perl poetry."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Honing in on a minimal excerpt,"},{"children":[{"children":null,"tag":"literal","value":"10 PRNT CHR$(205.5+RND(1)) : GOTO 10;"}],"tag":"inline_listing","value":""},{"children":[{"children":null,"tag":"literal","value":"montfort_10_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", is a collaborative work examining the cultural intertwinings of a single line of code, through hardware, language, syntax, outputs and themes. The whole endeavour is one rigorous close-reading of source code, in a deductive fashion, working from the words on the screen and elaborating the context within which these words exist, in order to establish the cultural relevance of source code, as related to the syntax, hardware and cultural context in which these words exist. While the study itself, being a close-reading of only one work, and particularly a"},{"children":[{"children":null,"tag":"literal","value":"one-liner"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", itself a specific genre, is restricted in terms of broad aesthetic statements, it does show how it is possible to talk about code not as an abstract construct but as a concrete reality. Particularly interesting is the section dedicated to the history of the BASIC programming language, and how particular languages afford particular statements and actions better in a given historical context, a point often glossed over in other studies."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A current synthesis of these approaches, Mark C. Marino's"},{"children":[{"children":null,"tag":"literal","value":"Critical Code Studies"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"marino_critical_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and the eponymous research field it belongs to focuses on close-reading of source code as a method for interpreting it as discourse. Particularly, it is organized around cases studies: each with source code, annotations and commentary. This structure furthers the empirical approach we have seen in Cox and McLean's code, starting from lines of source code in order in order to deduce cultural and social environments and intents through interpretation. This particular monograph, as is stated in the conclusion, offers a set of possible methodologies rather than conclusions in order to engage with code as its textual manifestations: the source code, viewed from different angles, can reveal more than its functional purpose. While Marino, with a background in the humanities, focuses mostly on the literary properties of code as a textual artifact, this thesis builds here on some of his methodologies, particularly reading how the form of the code complements its process and output, and searching the code for clever re-purposing or insight. However, while Marino mentions the aesthetics of code, he does not address the systematic composition of these aesthetics—focusing primarily on"},{"children":[{"children":null,"tag":"literal","value":"what"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"the code means and only secondarily on"},{"children":[{"children":null,"tag":"literal","value":"how"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"the code means it."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Taking a step back, Warren Sack's"},{"children":[{"children":null,"tag":"literal","value":"The Software Arts"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"sack_software_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"historicizes software development as an epistemological practice, rather than as a strictly economic trade. Connecting some of the main components of software (language, algorithm, grammar), he demonstrates how these are rooted in a liberal arts conception of knowledge and practice, particularly visible as a parallel to Diderot and D'Alembert's encyclopedic attempt at formalizing craft practices. By examining this other, humanistic, tradition in parallel with its dominantly acknowledged scientific counterpart, Sack shows the multiple facets that code and software can support. Starting from the concept of \"translation\" as an updated version of Manovich's \"transcoding\", Sack analyzes what is being translated by computing, such as analyses, rhetoric and logic, byt doesn't however address the nature of the process in which these concepts are translated—algorithms as (liberal) ideas, but not as texts. Nonetheless, this work offers a switch in perspective which will be helpful when we come to consider the relationship of source code with domains that are not primarily related to the sciences—i.e. the literary and the architectural, approached from a craft perspective."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This activity of programming as craft, already acknowledged by programmers themselves, is further explored in Erik Pineiro's doctoral thesis"},{"children":[{"children":null,"tag":"literal","value":"pineiro_aesthetics_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In it, he examines the concrete, social and practical justifications for the existence of aesthetics within the software development community. Departing from specific, hand-picked examples such as those featured in Marino's study, his is more of an anthropological approach, revealing what role aesthetics play in a specific community of practicioners. Outlining references to ideas such as"},{"children":[{"children":null,"tag":"literal","value":"cleanliness"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"simplicity"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"tightness"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"robustness"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", amongst others, as aesthetic ideals that programmers aspire to, he does not however summon any specific aesthetic field (whether from literature, mathematics, craft or engineering), but rather frames it in terms of"},{"children":[{"children":null,"tag":"literal","value":"intrsumental goodness"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", with the aesthetics of code being an attempt to reach excellence in instrumental action. While he carefully lays out his argument by focusing on what (a certain group of) programmers actually say, instead of what they might be saying, there remains two limitations: it is not clear how source code as textual material can afford to reach such aesthetic ideals, and whether or not these aesthetic ideals apply to other groups of writers of code, such as the code poets mentioned in some of the works above."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This literature review allows us to have a better grasp of how the relationship between source code and aesthetics has been studied, both from a scientific and engineering perspective, as well as from a humanities perspective."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the former approach, aesthetics are acknowledged as a component of reading and writing code, and assessed through practical examples, quantitiative analysis and, to a lesser extent, qualitative interviews. The research focus is on the effectiveness of aesthetics in code, rather than on unearthing a systematic approach to making code beautiful, even though issues of cognitive friction and understanding, as well as ideals of cleanliness, readability, simplicity and elegance do arise. As such, they form a good starting ground of varied, empirical investigations."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"On a more metaphysical level, works in the field of philosophy of computer science point at the fact that the nature of computing and software are themselves evasive, straddling different lines while not aligning clearly with either science, engineering or arts—pointing out that software is indeed something different."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As for the humanities, the focus is predominantly on literary heuristics of a restricted corpus or on socio-cultural dynamics, and the details and examples of the actual code syntax and semantics are often omitted even though the aesthetic aspects of a literary or cultural nature are being explored in source code, as a new kind of writing. There is a potential for beauty and art in source code,as made obvious by code poetry, but such a potential is not assessed through the same empirical lense as the former part of our literature review and only secondarily investigating which of intrinsic features of code can support aesthetic judgments."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Still, some recent studies, such as those by Paloque-Bergès, Montfort et. al, Cox and McLean and Marino, do engage directly with source code examples, and these constitute important landmarks for a code-specific aesthetic theory and methodology, whether it is as poetic language, speech-act, or critical commentary. Source code is taken as a unique literary device, but it remains unclear in exactly which aspects, besides its executability, it is different from both natural languages and low-level machine languages, and how this literary aspect relates to the effective, mathematical and craft-like nature of source code considered in the computer science and engineering literature."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"The aesthetic specificities of source code"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-specificities-code"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We can now turn to some of the gaps and questions left by this review, which can be grouped under three broad areas: dissonant aesthetic fields, lack of correspondance between empirical investigations and theoretical frameworks, and an absence of close-reading of program texts as expressive artifacts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"First, we can see that there are different aesthetic fields being summon when assessing aesthetics in source code. By aesthetic field, I mean the set of medium-specific symbol systems which operate coherently on a stylistic level, as well as on a thematic level. The main aesthetic fields addressed in the context of source code are those of literature, architecture as well as craft and mathematics. Each of these domains have specific ways to structure the aesthetic experience of objects within that field. For instance, literature can operate in terms of plot, consonance or poetic metaphor, while architecture will mobilize concepts of function, structure or texture. While we will reserve a more exhaustive description of each of these aesthetic fields in chapter 3, the first gap I would like to highlight here is how the multiple aesthetic fields are used to frame the aesthetics of source code, without this plurality being explicitely addressed. Depending on which study one reads, one can see code as literature, as architecture, as mathematics or as craft, and there does not seem to be a consensus as to which of these maps closest to the essence of source code, with exhaustive studies often mentioning several, if not all of the above, fields"},{"children":[{"children":null,"tag":"literal","value":"rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Second, we can see a disconnect between empirical and theoretical work. The former, historically more present in computer science literature, but more recently finding its way into the humanities, aims at observing the realities of source code as a textual object, one which can be mined for semantic data analysis, or as a crafted object, one which is produced by programmers under specific conditions and replicated through examples and principles, rather than systems and theorems. Conversely, the theoretical approach to code, focusing on computation as a broad phenomenon encompassing engineering breakthroughs, social consequences and disruption of traditional understandings of textuality, rarely confronts such theoretical approaches with the concrete, physical manifestations of computation as source code"},{"children":[{"children":null,"tag":"literal","value":"With exceptions of the recent works cited above."}],"tag":"footnote","value":"9"},{"children":null,"tag":"literal","value":", until recently."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In consequence, there are theoretical frameworks that emerge to explain software (e.g. computation, procedurality, protocol), but no frameworks yet which tend to the aesthetics of source code. In the light of the history of aesthetic philosophy, literature studies and visual arts, defining such a precise framework seems like an elusive goal, but it is rather the constellation of conflicting and complementing frameworks which allow for a better grasp of their object of study. In the case of the particular object of this study, the establishment of such framework taking into account the specifically textual dimension of source code (as opposed to, say, McLean and Cox's attention to the speech dimension) is yet to be done. Following the software development and programming literature, such a framework could productively focus on the role and purpose that aesthetics play within source code, rather than on their autotelic nature as manifestations-for-themselves."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, and related to the point above, we can identify a methodological gap. Due to reasons such as access and skill, close-reading of source code from a humanities perspective has been mostly absent, until the recent emergence of fields of software studies and critical code studies. The result is that many studies engaging with source code as a literary object did not provide code snippets to illustrate the points being made. While not necessary"},{"children":[{"children":null,"tag":"literal","value":"per se"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", I argue that if one establishes an interpretative framework related to the nature and specificity of software, such a framework should be reflected in an examination of one of the main components of software—source code. The way that this gap has been productively addressed in recent years has primarily been done through an understanding of code as a part of broader socio-technical artifacts"},{"children":[{"children":null,"tag":"literal","value":"For instance, see the work done in the field of platform studies"},{"children":[{"children":null,"tag":"literal","value":"montfort_10_2014"}],"tag":"citation","value":""}],"tag":"footnote","value":"10"},{"children":null,"tag":"literal","value":", inscribing it within the phenomenon of computation. This focus on the context in which source code exists therefore leaves some room for similar approaches with respect to its textual qualities. Despite N. Katherine Hayles's call for medium-specificity when engaging with code"},{"children":[{"children":null,"tag":"literal","value":"hayles_print_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", it seems that there hasn't yet been close-readings of a variety of program texts in order to assess them as specific aesthetic objects, in addition to their conceptual and socio-technical qualities."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Having established an overview of the state of the research on this topic, and having identified some gaps remaining in this scholarship, we can now clarify some of the problems resulting from those gaps with the following questions."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"What does source code have to say about itself?"}],"tag":"emph","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The relative absence of empirical examination of its source component when discussing code does not seem to be consistent with a conception of source code as a literary object. As methodologies for examining the meanings of source code have recently flourished, the techniques of"},{"children":[{"children":null,"tag":"literal","value":"close-reading"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", as focusing first and foremost on \"the words on the page\""},{"children":[{"children":null,"tag":"literal","value":"richards_practical_1930"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"have been applied for extrinsic means: extract what the lines of code have to say about the world, rather than what they have to say about themselves, about their particular organization as source files, as typographic objects or as symbol systems expressing concepts about the computational entities they describe. In this sense, it is still unclear how the possible combinations of control flow statements, function calls, function definitions, datatypes, variable declaration and variable naming, among other syntactic devices, enable program texts to be expressive. While close-reading will be a useful heuristic for investigating these problems, it will also be necessary to question the unicity of source code, and take into account how it varies across writers and readers and the social groups they constitute. This problem therefore has to be modulated with respect to the social environment in which it exists—it will then be possible to highlight to what extent the aesthetics of source code vary across these groups, and to what extent they don't."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"How does source code relate to other aesthetic fields?"}],"tag":"emph","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Multiple aesthetic fields are being mapped onto source code, allowing us to grasp such a novel object through more familiar lenses. However, the question remains of what it is about the nature of source code which can act as common ground for approaches as diverse as literature, mathematics and architecture, or whether these references only touch on distinct aspects of source code. When one talks about structure in source code, do they refer to structure in an architectural sense, or in a literary sense? When one refers to"},{"children":[{"children":null,"tag":"literal","value":"syntactic sugar"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in a programming language, does this have implications in a mathematical sense? This question will involve inquiries into the relationship of syntax and structure, of formality and tacitness,  of metaphor and conceptual mapping, and in understanding of how adjectives such as"},{"children":[{"children":null,"tag":"literal","value":"clean"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"clear"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"simple"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"might have similar meanings across those different fields. Offering answers to these questions might allow us to move from a multi-faceted understanding of source towards a more specific one, as the meeting point for all these fields, source code might reveal deeper connections between each of those."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"How do the aesthetics of source code relate to its functionality?"}],"tag":"emph","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The final, and perhaps most important problem, concerns the status of aesthetics in source code not as an end, but as a means. A cursory investigation on the topic immediately reveals how aesthetics in source code can only be assessed only once the intended functionality of the software described has been verified. This stands in the way of a rather traditional opposition between beauty and functionality, and therefore begs further exploration. How do aesthetics support source code's functional purpose? And are aesthetics limited to supporting such purpose, or do they serve other purposes, beyond a strictly functional one? This paradox will relate to our first problem, regarding the meaning-making affordances of source code, and touch upon how the expressiveness of formal languages engage with different conceptions of use and function, therefore relating back to Goodman's concept of the languages of art, of which programming languages can be part of."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Methodology"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:methodology"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"To address such questions, we propose to proceed by looking at two kinds of texts: program texts and meta-texts. The core of our corpus will consist of the two categories, with additional texts and tools involved."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Our primary corpus is source code, taken as"},{"children":[{"children":null,"tag":"literal","value":"program texts"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Due to the intricate relationship between source code and digital communication networks, vast amounts of source code are available online natively or have been digitized"},{"children":[{"children":null,"tag":"literal","value":"While software was circulating freely on ARPANET and early networks, the application of the intellectual property regime on software in 1974 significantly reduced the open-availability of source code."}],"tag":"footnote","value":"11"},{"children":null,"tag":"literal","value":". They range from a few lines to several thousands, date between 1969 and 2021, with a majority written by authors in Northern America or Western Europe. On one side, code snippets are short, meaningful extracts usually accompanied by a natural language comment in order to illustrate a point. On the other, extensive code bases are large ensembles of source files, often written in more than one language, and embedded in a build system"},{"children":[{"children":null,"tag":"literal","value":"A build system is a fairly complex series of code transformations intended to generate executable code."}],"tag":"footnote","value":"12"},{"children":null,"tag":"literal","value":". Both can be written in a variety of programming languages, as long as these languages are composed in alphanumeric characters."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This lack of limitations on size, date or languages stems from our empirical approach. Since we intend to assess code conditionally, that is, based primarily on its own, intrinsic textual qualities, it would not follow that we should restrict to any specific genre of program text. As we carry on this study, distinctions will nonetheless arise in our corpus that align with some of the varieties amongst source—for instance, the aesthetic properties of a program text composed of one line of code might be different from those exhbited by a program text made up of thousands of lines code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We also intend to use source code in both a deductive and an inductive manner. Through our close-reading of program texts, we will highlight some aesthetic features related to its textuality, taking existing source code as concrete proof of their existence. Conversely, we will also write our own source code snippets in order to illustrate the aesthetic features discussed in natural language. This use of source code snippets is widely spread among communities of programmers in order to qualify and strengthen their points in online discussions, and we intend to follow this weaving in of machine language and natural language in order to strengthen our argumentation. This approach will therefore oscillate between theory and practice, the concrete and the abstract, as it both extracts concepts from readings of source code and illustrates concepts by writing source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The case of programming languages is a particular one: they do not exclusively constitute program texts (unless they are considered strictly in their implementation details as lexers, interpreters and compilers, themselves described in program texts), but are a necessary, if artificial, condition for the existence of source code. They therefore have to be taken into account when assessing the aesthetic features of program text, as integral part of the affordances of source code. Rather than focusing on their context-free grammars or abstract notations, or on their implementation details, we will focus on the syntax and semantics that they allow the programmer to use. Still, programming languages are hybrid artefacts, and their intrinsic qualities are only assessed insofar as they relate to the aeshetic manifestations of source code written in those languages."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Meta-texts"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"on source code make up our secondary corpus. Meta-texts are written by programmers, provide additional information, context and explanation for a given extract of source code, and is a significant part of the software ecosystem. Even though they are written in natural langauge, this ability to write comments has been a core feature of any programming language very early on in the history of computing, linking any program text with a potential commentary, whether directly among the source code lines ("},{"children":[{"children":null,"tag":"literal","value":"inline commentary"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":") or in a separate block ("},{"children":[{"children":null,"tag":"literal","value":"external commentary"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":")"},{"children":[{"children":null,"tag":"literal","value":"Such a distinction isn't a strict binary, and systems of inscription exist which couple code a commentary more tightly, such as WEB or Juptyer Notebook."}],"tag":"footnote","value":"13"},{"children":null,"tag":"literal","value":". Examples of external commentaries include user manuals, textbooks, documentation, journal articles, forums posts, blog posts or emails. The inclusion in our corpus of those meta-texts is due to two reasons: the practical reason of the high epistemological barrier to entry when it comes to assessing source code in linguistic or hardware environments which one isn't familiar with, and the theoretical reason of including the (aesthetic) judgment of programmers as it supports our conditional, rather than constitutive, approach."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While we intend to look at source through close-reading, favoring the role and essence of each line as a meaningful, structural element, rather than that of the whole, our interpretation of meta-texts will take place via discourse analysis. Building on Dijk and Kintsch's work on discourse comprehension"},{"children":[{"children":null,"tag":"literal","value":"dijk_strategies_1983"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", we intend to approach these texts at a higher level, in terms of the lexical field they use, as a marker of the aesthetic field they refer to, as well as at a lower level, noting which specific syntactic aspects of the code they refer to. This focus on both the micro-level (e.g. local coherence and proposition analysis) and on the macro-level (e.g. socio-cultural context, intended aim and  lexical field usage) will allow us to link specific instances of written code with the broader semantic field that they exist in. This connection between micro- and macro- relies on the hypothesis that there is something fundamentally similar between a source code construct, its meaning and use at the micro-level, and the aesthetic field to which it is attached at a macro-level, a hypothesis we will address further when investigating the role of metaphor in source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the end, this process will allow us to construct a framework from empirical observations. The last part of our methodology, after having completed this analysis of program-texts and their commentaries, is to cross-reference it with texts dealing with the manifestation of aesthetics in those peripheral fields. Literary theory, centered around the works of I.A. Richards, Roland Barthes and Paul Ricoeur can shed light on the attention to form, on the interplay of syntax and semantics, of open and closed texts, and suggest productive avenues through the context of metaphor. Architecture theory will be involved through the two main approaches mentioned by software developers: functionalism as illustrated by the credo"},{"children":[{"children":null,"tag":"literal","value":"form follows function"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and works by Vitruvius, Louis Sullivan and the Bauhaus on one side, and pattern languages as initiated by the work of Christopher Alexander on the other. The aesthetic nature of the two remaining fields, mathematics and craft, have a thinner tradition of formalized aesthetics than literature and architecture, but we nonetheless include essays and monographs from practicioners in the field addressing those issues. This additional set of texts will allow us to operate comparatively when it comes to expliciting source code's aesthetics."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This study therefore aims at weaving in empirical observations, discourse analysis and external framing, in order to propose systematic approaches to source code's textuality. However, these will not unfold in a strictly linear sequence; rather, there will be a constant movement between practice and theory and between code-specific aesthetic references and broader ones: this interdisciplinary approach intends to reflect the multifaceted nature of software."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Roadmap"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:roadmap"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Our first step in this study is an empirical assessment of how programmers consider aesthetics with their practice or reading and writing it, first from a conceptual standpoint. After acknowledging and underlining the diversity of those practices, from software developers and scientists to artists and hackers, we will identify which concepts and references are being used the most when referring to beautiful code—concepts such as clarity, simplicity, cleanliness, and others. These concepts will then allow us to touch upon the field that are being referred to when considering the practice of programming: literature, architecture and mathematics as domains in themselves, and craft as a particular approach to these domains. Finally, we will how how the overlap of these concepts can be found in the process of"},{"children":[{"children":null,"tag":"literal","value":"understanding"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"—communicating abstract ideas through concrete manifestations."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"After establishing the role of aesthetics as a means for understanding source code, we will proceed to analyze further such a relationship between understanding, source code and aesthetics. We will see that one of the main features of source code is the elusiveness of its meaning, whether effective or intended. Beautiful code is often code that can be understood clearly, which raises the following question: how can a completely explicit and formal language allow ambiguity? The answer to this question will involve an analysis of the two audiences of source code: humans and machines."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Taking a step back towards textuality, we will then assess how the different fields that are being referred to when talking about source code have touched upon these issues of understanding, from rhetoric to literature, through architecture and mathematics. Thinking in terms of surface-structure and deep-structure, we will establish a first connection between program texts and literary text through their reliance on linguistic metaphors. Since metaphors aren't exclusively literary devices, looking at them from a cognitive perspective will also raise issues of modes of knowledge, between explicit, implicit and tacit. The understanding of beauty in architecture, based on the two traditions mentioned above, will provide an additional perspective by providing concepts of structure, function and usability. These will echo a final inquiry into mathematical beauty, drawing a direct link between idea and implementation, theorem and proof, and providing a deeper understanding of the concept of"},{"children":[{"children":null,"tag":"literal","value":"elegance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With a firmer grasp on the stakes of source code as an understandable text, we can now turn to its effective manifestations, by close-reading program texts. Working through"},{"children":[{"children":null,"tag":"literal","value":"structure"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"syntax"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"vocabulary"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", we will be able to formalize a set of textual typologies involved in producing an aesthetic experience through source code. Particularly, we will highlight where those tokens differ across communities of practice, and where they overlap, keeping in mind the conditionality of those aesthetic judgments, and attempt to trace connections between specific textual configurations of source code with the ideals summoned by the programmers. After this deductive consideration, we will move on to apply these typologies to several larger program texts—ranging from the LaTeX codebase, the Carnivore software artwork to several code poems. These will highlight a remaining component in the concrete manifestation of source code aesthetics: the place of programming languages."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At this point, we will have established aesthetics in source code as a way to address the inherent tensions of a program text's dual audience, computers and humans. Being understandable by both humans and machines is indeed the feat of programming languages, the symbol systems on which beautiful texts depend on. As we have elicited the intricacies of aesthetic manifestations in human to machine communication, we then investigate machine to machine communication. Deconstructing programming languages as formal grammars will show that there are very different conceptions of semantics and meanings expected from the computer than those expected from a human, even though a machine's perspective on beautiful code could still be based around concepts of effectiveness, simplicity and performance."},{"children":[{"children":null,"tag":"literal","value":"Contra"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"those, human use of programming languages reaches into the extreme of"},{"children":[{"children":null,"tag":"literal","value":"esolangs"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"—an investigation into those will reveal that language is effectively considered as a material, one whose base elements can be recombined into unexpected puzzling structures."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Recognizing programming languages as the bridge between the two domains of programming—the human of the machine—will allow us to clarify how the different aesthetic fields (literature, architecture, mathematics) relate to programming. We will show how programming languages provide a gradual interface between different modes of being of source code: source code as text, source code as structure and source code as theory. The need for aesthetics arises from the tradeoffs that need to be made when these different modes of being overlap"},{"children":[{"children":null,"tag":"literal","value":"simondon_mode_1958"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We will then turn back to our research questions to suggest some possible answers. The reorganization of the source aesthetic fields inot a linear succession of the interpration or compilation process from high-level to low-level hints at a specifically spatial nature of program texts. Indeed, the specific aesthetics of source code are those of a constant doubling between the specificities of the human (such as natural handling of ambiguity, and intuitive understanding of the problem domain) and of the machine (such as speed of execution, and reliance on explicit formal grammars, which can also be seen as the tension between surface structure, one that is textual and readable, and deep structure, one that is made up of dynamic processes representing complex concepts, and yet devoid of any fluidity or ambiguity. It is this dynamism, both in terms of"},{"children":[{"children":null,"tag":"literal","value":"where"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"when"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"code could be executed, which suggest the use of aesthetics in order to grasp more intuitively the topology and chronology, the state and behaviour of a program text."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, we will relate the approaches of Goodman of art as cognitively effective symbol systems, and of Simondon's consideration of aesthetic thought as a link between technical thought and religious thought. Starting from a practical perspective on aesthetics taking from the field of craft—the thing well done—, aesthetics also highlight functionality on a cognitive level—the thing well thought. Beauty in source code seems to be dominantly what is useful and thoughtful, even when they are reflected in the distorting mirrors of hacks and esoteric languages, broadening our possible understandings of what aesthetics can do, and what functionality can be."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Implications and readership"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:implications-readership"}],"tag":"label","value":"introduction"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This thesis fits within the field of software studies, and aims at clarifying what do we mean when we refer to code"},{"children":[{"children":null,"tag":"literal","value":"code as"},{"children":null,"tag":"dots","value":""}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Code as literature, architecture or mathematics, code as philosophy or as craft, are metaphors which can be examined productively by looking at the texts themselves, an approach that has only been deployed in relatively recent work."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This relationship between practice, function and beauty is the broad, underlying question of this study. In the vein of the cognitive approach to art and aesthetics, this study is an attempt to show how aestethics play a communicative role, and how concrete manifestations can, through a metaphorical process, hint at broader ideas. In this sense, this study is not just about the relation of aesthetics and function, but also about the function of aesthetics. While this idea of aesthetics as a way of communicating ideas could be equally applied across artistic and non-artistic domains, another aim of this thesis is to highlight the relativity a aesthetic standards: using a similar medium, practices, uses and purposes determine as much, if not more, of the artistic worth of a given program text."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"By examining the result of the practice of programmers at a close-level, this study hopes to contribute to a clarification of what exactly is programming, along with the consequences of the embedding of software in our social, economic and political practices. In order to address the question of whether algorithms are political in themselves, or if their use is political, it is important to define clearly what it is that we are talking about when discussing algorithms. A clarification of source code on a concrete level attempts to help clarify what this essential component of algorithms, and opens up potential for further work in terms of thinking no longer of the aesthetics of source code, but of its poetics, in the way source code, as a language of art, is also a way of worldmaking."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"To this end, this thesis is aimed at a variety of readers and audience. From the humanities perspective, digital humanists and literary theorists interested in the concrete manifestations of source code as specific meaning-making techniques will be able to find the first steps of such an approach being laid out, and contrast these specific technique with the broader poetics of code studied by other scholars, or with the aesthetics of natural language texts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Programmers and computer scientists will find an attempt at formalizing something they might have known implicitly ever since they started practicing writing and reading code, and the approach of languages as poetics and structure might help them think through these aspects in order to write perhaps more aesthetically pleasing, and thus perhaps better, code. Conversely, anyone engaged seriously in a craft activity could find here a rigorous study of what goes on into a specific craft, asking how their own practice engages with tools and modes of knowledge, and with a more explicit conception of beauty."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, such a specific conception of beauty, then, will also be of interest to artists and art theorists. By investing aesthetics without a direct relation to the artwork, but rather within a functional purpose, this study suggests that one can think through beauty and artworks not as ends, but as ways to accomplish things that formal systems of explanation might not be able to achieve. An aesthetics of source code would therefore aim at highlighting the purpose of instrumental beauty within a textual environment."}],"tag":"paragraph","value":""}],"tag":"root","value":""}],"tag":"include","value":"introduction.tex"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Aesthetic ideals in programming practices"}],"tag":"chapter","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"chap:ideals"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The first step in our study of aesthetic standards in source code will identify the aesthetic ideals ascribed by programmers to the source code they write and read; that is, the syntactic qualifiers and semantic fields that they refer to when discussing program texts. To that end, we first start by clarifying whom we refer to by the term"},{"children":[{"children":null,"tag":"literal","value":"programmers"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", revealing a multiplicity of practices and purposes, from"},{"children":[{"children":null,"tag":"literal","value":"ad hoc"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", one-line solutions, to printed code and massively-distributed codebases."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We then turn to the kinds of beauty that these programmers aspire to. After expliciting our methodology of discourse analysis, we engage in a review of the various kinds of publications and writings that programmers write, read and refer to when it comes to qualifying their practice. From this will result a cluster of adjectives which we see being used in an aesthetic manner. These will provide an empirical basis when examining, in subsequent chapters, the formal arrangements of program texts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From these, we can then move to a description of which aesthetic fields are being referenced by programmers on a broader level, and consider how multiple kinds of beauties, from literary, to architectural and scientific conceptions of beauty can overlap and be referred to by the same medium."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, we conclude this chapter by elaborating on one of the points of overlap in these different references: the importance of function, craft and knowledge in the disposition and representation of code. We will show how this particular way of working  plays a central role in an aesthetic approach to source code and results from the specificity of code as a cognitive material, a specificity we will focus on in the next chapter."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"The practice of programmers"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:practice-programmers"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The history of software development is that of a specific, reserved practice which was born in the aftermath of the second world war, which trickled down to broader and broader audiences at the eve of the twenty-first century. Through this development, various paradigms, platforms and applications have been involved in producing software, resulting in different epistemic communities and communities of practice"},{"children":[{"children":null,"tag":"literal","value":"cohendet_organisational_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", in turn producing different types of source code. Each of these focus on the description of specific instructions to the computer, but do so with particular characteristics. To this end, we take a socio-historical stance on the field of programming, highlighting how diverse practices emerge at different moments in time, how they are connected to contemporary technical and economic organizations, and for specific purposes."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Even though such types of reading and writing source code often overlap with one another, this section will highlight a diversity of  ways in which code is written, notably in terms of origin—how did such a practice emerge?—, references—what do they consider good?—, purposes—what do they write for?—and examples—how does their code look like?. First, we take a look at the software industry, to identify professional"},{"children":[{"children":null,"tag":"literal","value":"software developers"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the large code bases they work on and the specific organizational practices within which they write it. They are responsible for the majority of source code written today, and do so in a professional and productive context, where maintainability, testability and reliability are the main concerns. Then, we turn to a parallel practice, one that is often exhibited by software developers, as they also take on the stance of"},{"children":[{"children":null,"tag":"literal","value":"hackers"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Disambiguating the term reveals a set of practices where curiosity, cleverness, and idiosyncracy are central, finding unexpected solutions to complex problems, sometimes within artificial constraints. Finally, we look at"},{"children":[{"children":null,"tag":"literal","value":"scientists"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"poets"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". On one end,"},{"children":[{"children":null,"tag":"literal","value":"scientists"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"embody a rather academic approach,  focusing on abstract concepts such as simplicity, minimalism and elegance; they are often focused on theoretical issues, such as mathematical models, as well as programming language design, but are also involved in the implementation of algorithms. On the other end,"},{"children":[{"children":null,"tag":"literal","value":"poets"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"read and write code first and foremost for its textual and semantic qualities, publishing code poems online and in print, and engaging deeply with the range of metaphors allowed by this dynamic linguistic medium."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While this overview encompasses most of the programming practices, we leave aside some approaches to code, mainly because they do not directly engage with the representation of source code as a textual matter. More and more, end-user applications provide the possibility to program in rudimentary ways, something referred to as the \"low-code\" approach"},{"children":[{"children":null,"tag":"literal","value":"team_lowcode_2021"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and thus contributing to the blurring of boundaries between programmers and non-programmers"},{"children":[{"children":null,"tag":"literal","value":"For instance, Microsoft's Visual Basic for Applications, Ableton's Max For Live, MIT's Scrath or McNeel's Grasshopper are all programming frameworks which are not covered within the scope of this study. In the case of VBA and similar office-based high-level programming, it is because such a practice is a highly personal and"},{"children":[{"children":null,"tag":"literal","value":"ad hoc"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"one, and therefore is less available for study."}],"tag":"footnote","value":"14"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Software developers"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:software-developers"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As Niklaus Wirth puts it,"},{"children":[{"children":null,"tag":"literal","value":"the history of software is the history of growth in complexity"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"wirth_brief_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", while paradoxically, a lowering of the barrier to entry. As computers' technical abilities in memory managment and processing power increased year on year since the 1950s, the nature of writing instructions shifted as well."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In his history of the software industry, Martin Campbell-Kelly traces the development of a discipline through an economic and a technological lens, and he identifies three consecutive waves in the production of software"},{"children":[{"children":null,"tag":"literal","value":"campbell-kelly_airline_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". During the first period, as soon as the 1950s, and continuing throughout the 1960s, software developers were contractors hired to engage directly with a specific computing machine. These computing, mainframes, were large, expensive, and rigid machines, requiring hardware-specific knowledge of the corresponding Assembler instruction set, since they didn't yet feature an operating system which could facilitate some of the more basic memory allocation and input/output functions, and thus enable interoperable program-writing"},{"children":[{"children":null,"tag":"literal","value":"One of the first operating systems, MIT's Tape Director, would be only developped in 1956"},{"children":[{"children":null,"tag":"literal","value":"ross_personal_1986"}],"tag":"citation","value":""}],"tag":"footnote","value":"15"},{"children":null,"tag":"literal","value":". Two distinct groups of people were involved in the operationalization of such machine: electrical engineers, tasked with designing hardware, and programmers, tasked with implementing the software. While the former historically received the most attention"},{"children":[{"children":null,"tag":"literal","value":"ross_personal_1986"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", the latter was mostly composed of women and, as such, not considered essential in the process"},{"children":[{"children":null,"tag":"literal","value":"light_when_1999"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". At this point, then, programming remains closely tied to hardware."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The second period in software development starts in the 1960s, as hardware switched from vacuum tubes to transistors and from magnetic core memory to semiconductor memory, making them faster and more capable to handle complex operations.  On the software side, the development of several programming languages, such as FORTRAN, LISP and COBOL, started to address the double issue of portability—having a program run unmodified on different machines with different instruction sets—and expressivity—allowing programmers to use high-level, English-like syntax, rather than assembler instruction codes. By then, programmers are no longer theoretically tied to a specific machine, and therefore acquire a certain autonomy, a recognition which culminates in the naming of the field of"},{"children":[{"children":null,"tag":"literal","value":"software engineering"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in 1968 at a NATO conference"},{"children":[{"children":null,"tag":"literal","value":"randell_nato_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The third and final phase that Campbell-Kelly identifies is that of mass-market production: following the advent of the UNIX family of operating systems, the distribution of the C programming language, the wide availability of C compilers, and the appearance of personal computers such as the Commodore 64, Altair and Apple II, software could be effectively entirely decoupled from hardware"},{"children":[{"children":null,"tag":"literal","value":"For a more detailed account of the personal computer revolution, see: Cerruzzi, P., A History of Modern Computing"},{"children":[{"children":null,"tag":"literal","value":"ceruzzi_history_2003"}],"tag":"citation","value":""}],"tag":"footnote","value":"16"},{"children":null,"tag":"literal","value":". And yet, despite this growth in popularity, software immediately enters a crisis: software development projects run over time and budget, prove to be unreliable in production and unmaintainable in the long-run. The creation of software is no longer a corollary to the design of hardware, and as an independent field would as such become the main focus of computing as a whole"},{"children":[{"children":null,"tag":"literal","value":"ceruzzi_history_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". It is at this time that discussions around best practices in writing source code started to emerge, once the activity of the programmer was no longer restricted to"},{"children":[{"children":null,"tag":"literal","value":"tricks by means of which he contrived to squeeze the impossible into the constraints of his equipment"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"dijkstra_humble_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This need for a more formal approach to the actual process of programming found one of its most important manifestations in Edsger Djikstra's"},{"children":[{"children":null,"tag":"literal","value":"Notes on Structured Programming"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"dijkstra_chapter_1972"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In it, he argues for moving away from programming as a craft, and towards programming as an organized discipline, with its methodologies and systematization of program construction. Despite its laconic section titles"},{"children":[{"children":null,"tag":"literal","value":"See, for instance, Chapter 1: \""},{"children":[{"children":null,"tag":"literal","value":"On our inability to do much"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\""}],"tag":"footnote","value":"17"},{"children":null,"tag":"literal","value":", Djikstra's 1972 report nonetheless contributed to establish a more rigorous typology of the constructs required for reliable, provable programs—based on fundamental heuristics such as sequencing, selection, iteration and recursion—, and aimed at the formalization of the practice. Along with other subsequent developments (such as Hoare's contribution on proper data structuring"},{"children":[{"children":null,"tag":"literal","value":"hoare_chapter_1972"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", or the rise of object-oriented programming with Smalltalk) programming would solidify its foundations as a profession:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"We knew how the nonprofessional programmer could write in an afternoon a three-page program that was supposed to satisfy his needs, but how would the professional programmer design a thirty-page program in such a way that he could really justify his design? What intellectual discipline would be needed? What properties could such a professional programmer demand with justification from his programming language, from the formal tool he had to work with?"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_chapter_1972"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As a result of such interrogations comes an industry-wide search for solutions to the intractable problem of programming: that it is"},{"children":[{"children":null,"tag":"literal","value":"a technique to manage information which in turn produces information"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". To address such a conundrum, a variety of tools, formal methods and management processes enter the market; they aim at acting as a"},{"children":[{"children":null,"tag":"literal","value":"silver bullet"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"brooks_mythical_1975"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", addressing the cascade of potential risks"},{"children":[{"children":null,"tag":"literal","value":"See"},{"children":[{"children":null,"tag":"literal","value":"https://catless.ncl.ac.uk/Risks/"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":"for such risks"}],"tag":"footnote","value":"18"},{"children":null,"tag":"literal","value":"which emerge from large software applications. However, this growth in complexity is also accompanied by a diversification of software applications: as computers become more widely available, and as higher-level programming languages provide more flexibility in their expressive abilities, software engineering engages with a variety of domains, each of which might need a specific solution, rather than a generic process. Confronted with this diversity of applications, business literature on software practices flourishes, being based on the assumption that the complexity of software should be tackled at its bottleneck: the reading and writing of source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The most recent step in the history of software developers is the popularization of the Internet and of the World Wide Web. Even though the former had existed under as ArpaNet since 1969, the network was only standardized in 1982 and access to it was provided commercially in 1989. Built on top of the Internet, the latter popularized global information exchange, including technical resources to read and write code. Software could now be written by remote individual written on"},{"children":[{"children":null,"tag":"literal","value":"cloud computing"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"platforms, shared through public repositories and deployed via containers with a lower barrier to entry than at the time of source code printed in magazines, of overnight batch processing and of non-time-sharing systems."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software developers have written some of the largest codebases to this date, since this type of activity represents the most significant fraction of programmers. Due to its close ties to commercial distributors, however, source code written in this context often falls under the umbrella of proprietary software, thus made unvailable to the public. Some examples that we include in our corpus are either professional codebases that have been leaked"},{"children":[{"children":null,"tag":"literal","value":"Such as the Microsoft Windows XP source code"},{"children":[{"children":null,"tag":"literal","value":"warren_windows_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"19"},{"children":null,"tag":"literal","value":", open-source projects that have come out of business environments, such as Soundcloud's Prometheus, Kirby's CMS System, Facebook's React, or large-scale open-source projects which nonetheless adhere to structured programming guidelines, such as Donald Knuth's TeX typesetting system or the Linux Foundation's Linux kernel."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The features of these codebases hint at the qualities that software developers have come to ascribe to their object of practice. First, the program texts they write are large, much larger than any other codebase included in this study. They often feature multiple programming languages and are highly structured and standardized: each file follows a pre-established convention in programming style, which favors an authoring by multiple programmers without any obvious trace to a single individual authorship. These program texts stand the closest to a programming equivalent of engineering, with its formalisms, standards and usability. From this perspective, the IEEE's Software Engineering Body of Knoweldge (SWEBOK) provides a good starting point to survey the specificities of software developers as source code writers and readers"},{"children":[{"children":null,"tag":"literal","value":"bourque_swebok_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"; the main features of which include the definition of requirements, design, construction, testing and maintenance."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software requirements are the acknowledgement of the importance of the"},{"children":[{"children":null,"tag":"literal","value":"problem domain"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the domain to which the software takes its inputs from, and to which it applies its outputs. For instance, software written for a calculator has arithmetic as its problem domain; software written for a learning management system has students, faculty, education and courses as its problem domain; software written a banking institution has financial transactions, savings accounts, fraud prevention and credit lines as its problem domain. Requirements in software development aim at formalizing as best as possible the elements that must be used by the software in order to perform a successful computation, and an adequate formalization is a fundamental requirement for a successful software application."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Subsequent to the identification and codification of requirements, software design relates to the overall organization of the software components, considered not in their textual implementation, but in their conceptual agency. Usually represented through diagrams or modelling languages, it is concerned with"},{"children":[{"children":null,"tag":"literal","value":"understanding how a system should be organized and designing the overall structure of that system"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"sommerville_software_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Of particular interest is the relationship that is established between software development and architecture. Considered a creative process rather than a strictly rational one, due to the important role of the contexts in which the software will exist (including the problem domain)"},{"children":[{"children":null,"tag":"literal","value":"sommerville_software_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", software architecture operates both from a top-down perspective, laying down an abstract blueprint for the implementation of a system, as well as form a bottom-up one, representing how the different components of an existing system interact. This apparent contradiction, and the role of architecture in the creative aspects of software development, will be further explored in section"},{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-domains"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"below."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software construction relates to the actual writing of software, and how to do so in the most reliable way possible. The SWEBOK emphasizes first and foremost the need to minimize complexity"},{"children":[{"children":null,"tag":"literal","value":"Following Hoare's assessment in his Turing Award Lecture that"},{"children":[{"children":null,"tag":"literal","value":"\"there are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies.\""}],"tag":"emph","value":""}],"tag":"footnote","value":"20"},{"children":null,"tag":"literal","value":", in anticipation of likely changes and possible reuse by other software systems. Here, the emphasis on engineering is particularly salient: while most would refer to the creation of software as"},{"children":[{"children":null,"tag":"literal","value":"writing"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"software, the IEEE document refers to it as"},{"children":[{"children":null,"tag":"literal","value":"constructing"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"software"},{"children":[{"children":null,"tag":"literal","value":"The term software construction refers to the detailed creation of working software through a combination of coding, verification, unit testing, integration testing, and debugging."},{"children":[{"children":null,"tag":"literal","value":"bourque_swebok_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"21"},{"children":null,"tag":"literal","value":". Coding is only assessed as a practical consideration, one which should not take up the most attention, if the requirements, design and testing steps are satisfyingly implemented."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In parallel, a whole field of business litterature"},{"children":[{"children":null,"tag":"literal","value":"martin_clean_2008,hendrickson_software_2002,fowler_refactoring_1999,mcconnell_code_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"has focused specifically on the process of writing code, starting from the assumption that:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"We will never be rid of code, because code represents the details of the requirements. At some level those details cannot be ignored or abstracted; they have to be specified. And specifying requirements in such details that a machine can execute them is"},{"children":[{"children":null,"tag":"literal","value":"programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". "},{"children":[{"children":null,"tag":"literal","value":"martin_clean_2008"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As we see in these two perspectives on the role that code should play, the tension identified by Djikstra some thirty years before between craft and discipline is still alive and well at the beginning of the twenty-first century, even though the attention paid to code still relates to the need for reliability and maintainability in a maturing industry."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software maintenance, finally, relates not to the planning or writing of software, but to its reading. Software is notoriously filled with bugs"},{"children":[{"children":null,"tag":"literal","value":"McConnell estimates that the industry average is about 15 - 50 errors per 1000 lines of delivered code."},{"children":[{"children":null,"tag":"literal","value":"mcconnell_code_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"22"},{"children":null,"tag":"literal","value":"and can, at the same time, be easily fixed while already being in a production environment through software update releases. This means that the lifecycle of a software doesn't stop when then first version is written, but rather when it does not run anywhere anymore. The nature of software allows for it to be edited across time and space, by other programmers which might not have access to the original group of implementers: consequently, software should be first and foremost understandable—SWEBOK lists the first feature of coding as being"},{"children":[{"children":null,"tag":"literal","value":"techniques for creating understandable source code"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"bourque_swebok_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This requirement ties back to one of the main problems of software, which is its notorious cognitive complexity, one that remains at any stage of its development."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"What does this look like in practice, then? Ideals of clarity, reusability and reliability—and their opposites—can be found in some of the available code bases of professional software. The paradox to be noted here is that, even though software developers write the most code, it is the least accessible online and, as such, the following excerpts are covering the range of commercial software (Microsoft Windows), licensed and publicly available software (Kirby)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The first excerpts come from the source code for Microsoft Windows 2000, which was made public in 2004. The program text contains  28,655 files, the largest of our  corpus, by multiple orders of magnitude, with 13,468,327 combined lines and including more than 10 different file extensions. Taking a closer look at some of these files allow us to identify some of the specific features of code written by software developers, and how they specifically relate to architectural choices, collaborative writing and verbosity."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"First, the most striking visual feature of the code is its sheer size. Representing such a versatile and low-level system such as an operating system manifest themselves in files that are often above 2000 lines of code. In order to allow abstraction techniques at a higher-level for the end-developer, the operating system needs to do a significant amount of \"grunt\" work, relating directly to the concrete reality of the hardware platform which needs to be operated. For instance, the initialization of strings of text for the namespaces (a technique directly related to the compartmentalization) is necessary, repetitive work which can be represented using a rhythmic visual pattern, such as in the"},{"children":[{"children":null,"tag":"literal","value":"cmdatini.c"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"source file, reproduced partially in"},{"children":[{"children":null,"tag":"literal","value":"code:ms2000"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"fontsize=\\footnotesize, breaklines, breakanywhere"},{"children":null,"tag":"literal","value":"./corpus/ms2000.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Unicode string initialization in Microsoft 2000 operating system"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:ms2000"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The repetition of the"},{"children":[{"children":null,"tag":"literal","value":"RtlInitUnicodeString"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"call in the first part of this listing stands at odds with today's industry-standard practices of not repeating oneself; a standard only adhered to in the second part of the code, the two"},{"children":[{"children":null,"tag":"literal","value":"for()"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"statements. While this practice would only be formalized in Andy Hunt's"},{"children":[{"children":null,"tag":"literal","value":"The Pragmatic Programmer"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in 1999"},{"children":[{"children":null,"tag":"literal","value":"hunt_pragmatic_1999"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", the longevity of the windows 2000 operating system and its update cycle would nonetheless have affected how this code is written. The reason why such a repetition applies is the requirement of registering each string with the kernel. Dealing with a different problem domain (kernel instructions) leads to a different kind of expected aesthetics"},{"children":[{"children":null,"tag":"literal","value":"Effectively, references to"},{"children":[{"children":null,"tag":"literal","value":"RtlInitUnicodeString()"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"happen 1580 times across 336 files"}],"tag":"footnote","value":"23"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Verbosity, the act of explicitly writing out statements which could be functionally equivalent in a compacted form, is a significant feature of the Windows 2000 codebase, and also relies on a particular semantic environment: that of using the C programming language. As mentioned above, the development of C and UNIX in the 1970s have led to wide adoption of the former, and to some extent of the later (even though Windows is a notable exception since it is an operation system not based on the UNIX tradition). What we see in this listing is the consequence of this development: using a verbose language results in a verbose program text, something we will see in the following section on hacker's code and will explore much further in chapter 5."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another significant aesthetic feature of the Windows 2000 program text is its use of comments, and specifically how those comments representing the multiple, layered authorship. This particular source code is one that is written across individuals and across time, each with presumably its own writing style. Yet, writing source code within a formal organization often implies the adoption of coding styles, with the intent that"},{"children":[{"children":null,"tag":"literal","value":"all code in any code-base should look like a single person typed it, no matter how many people contributed"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"waldron_idiomatic_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". For instance, the excerpt in"},{"children":[{"children":null,"tag":"literal","value":"code:buffer_c"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"from"},{"children":[{"children":null,"tag":"literal","value":"jdhuff.c"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"is a example of such overlapping of styles:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"fontsize=\\footnotesize"},{"children":null,"tag":"literal","value":"./corpus/buffer.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Programming styles overlapping in the source code of Microsoft 2000."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:buffer_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Here, we see different writings of comments(using"},{"children":[{"children":null,"tag":"literal","value":"//"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"/* */"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":") as well as  different kinds of capitalizations. Those comments are ignored at compile time: that is, they are not meaningful to the machine, and are only expected to be read by other programmers, and in this case primarily by programmers belonging to one's organization. This hints at the various origins of the authors, or at the very least at the different moments, and possible mental states of the potential single-author: irregularity in comment writing can connect to irregularities in semantic content of the comments. This irregularity becomes suspicious, and leads to ascribing a different epistemological value to them. If comments aren't procedurally guaranteed to be reflected in the execution, and outcome, of the program, then one tend to rely on the fact that \"the only document that describes your code completely and correctly is the code itself\""},{"children":[{"children":null,"tag":"literal","value":"goodliffe_code_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This excerpt highlights the constant tension between source code as the canonical origin of knowledge of what the program does and how it does it, while comments reflect the idiosyncratic dimension of all natural-language expressions of human programmers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, this chronological and interpersonal spread of the program text, combined with organizational practices, require the use of comments in order to maintain aesthetic and cognitive coherence in the program, if only by the use of comment headers, which locate a specific file within the greater architectural organization of the program text (see"},{"children":[{"children":null,"tag":"literal","value":"code:enum_c"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":")."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/enum.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"pnpenum.c shows the traces of multiple authors collaborating on a single file over time."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:enum_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This highlights both the multiple authorship (here, we have one original author and one revisor) as well as the evolution in time of the file: comments are the only manifestation of this layering of revisions which ultimately results in the \"final\" software"},{"children":[{"children":null,"tag":"literal","value":"The term \"final\" is in quotes, since the Windows 2000 source contains the mention"},{"children":[{"children":null,"tag":"literal","value":"BUGBUG"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"7436 times across 2263 files, a testament to the constant state of unfinishedness that software tends to remain in."}],"tag":"footnote","value":"24"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A complementary example is the Kirby CMS"},{"children":[{"children":null,"tag":"literal","value":"Allgeier, Bastian et. al.,"},{"children":[{"children":null,"tag":"literal","value":"https://github.com/getkirby/kirby"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":", 2011, consulted in 2022"}],"tag":"footnote","value":"25"},{"children":null,"tag":"literal","value":". With development starting in 2011 and a first release in 2012, it developed a steady userbase, correlated in Google Trends analytics"},{"children":[{"children":null,"tag":"literal","value":"https://trends.google.com/trends/explore?date=all\\&q=kirby\\%20cms"}],"tag":"footnote","value":"26"},{"children":null,"tag":"literal","value":", consistent forum posts"},{"children":[{"children":null,"tag":"literal","value":"https://forum.getkirby.com"}],"tag":"footnote","value":"27"},{"children":null,"tag":"literal","value":"and commit history on the main repository"},{"children":[{"children":null,"tag":"literal","value":"https://github.com/getkirby/kirby"}],"tag":"footnote","value":"28"},{"children":null,"tag":"literal","value":". Kirby is an open-source, developer-first (meaning that it affords direct engagement of other developers with its architecture through modification, extension or partial replacement), single-purpose project. As such, it stands at the other end of the commercial, efficient software spectrum than Microsoft Windows 2000."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The Kirby source code is entirely available online, and the following snippets hint at another set of formal values—conciseness, expliciteness and delimitation. Conciseness can be seen in the lengths of the various components of the code base. For instance, the core of Kirby consists in 248 files, with the longest being"},{"children":[{"children":null,"tag":"literal","value":"src/Database/Query.php"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"at 1065 lines, and the shortest being"},{"children":[{"children":null,"tag":"literal","value":"src/Http/Exceptions/NextRouteException.php"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"at 16 lines, for an average of 250 lines per file (compared to the leading project in the field, Wordpress.org, which has respectively 3466 files, with the longest file comprising 9353 lines of code ("},{"children":[{"children":null,"tag":"literal","value":"customize-controls.js"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"), and the shortest 1line (such as"},{"children":[{"children":null,"tag":"literal","value":"script-loader-packages.php"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":")"},{"children":[{"children":null,"tag":"literal","value":"The project was cloned on 06.05.2022 from the official repository at"},{"children":[{"children":null,"tag":"literal","value":"https://github.com/WordPress/WordPress"}],"tag":"url","value":""}],"tag":"footnote","value":"29"},{"children":null,"tag":"literal","value":")."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"If we look at a typical function declaration within Kirby, we found one such as the"},{"children":[{"children":null,"tag":"literal","value":"distinct()"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"setter for Kirby's database, reproduced in"},{"children":[{"children":null,"tag":"literal","value":"code:query_php"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/query.php"}],"tag":"code","value":"php"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Query.php"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:query_php"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Out of these 11 lines, the actual functionality of the function is focused on one line,"},{"children":[{"children":null,"tag":"literal","value":"$this->distinct = $distinct;"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":". Around it are machine-readable comment snippets, and a function wrapper around the simple variable setting. The textual overhead then comes from the wrapping itself: the actual semantic task of deciding whether a query should be able to include distinct select clauses (as opposed to only allowing join clauses), is now decoupled from its actual implementation (one could describe to the computer such an ability to generate distinct clauses by assigning it a boolean value, or an integer value, or passing it as an argument for each query, etc.). The quality of this writing, at first verbose, actually lies in its conciseness in relation to the possibilities for extension that such a form of writing allows: the"},{"children":[{"children":null,"tag":"literal","value":"distinct()"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"function could, under other circumstances, be implemented differently, and still behave similarly from the perspective of the rest of the program. Additionally, this wrapping enables the setting of default values (here,"},{"children":[{"children":null,"tag":"literal","value":"true"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"), a minimal way to catch bugs by always providing a fallback case."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Kirby's source code is also interestingly explicit in comments, and succint in code. Let us take, for instance, from the"},{"children":[{"children":null,"tag":"literal","value":"Http\\\\Route"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"class (see"},{"children":[{"children":null,"tag":"literal","value":"code:route_php"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":")."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/route.php"}],"tag":"code","value":"php"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Route.php"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:route_php"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The 9 lines above the function declaration are machine-readable documentation. It can be parsed by a programmatic system and used as input to generate more classical, human-readable documentation"},{"children":[{"children":null,"tag":"literal","value":"See, for instance, JavaDocs, or ReadTheDocs"}],"tag":"footnote","value":"30"},{"children":null,"tag":"literal","value":". This is noticeable due to the highly formalized syntax"},{"children":[{"children":null,"tag":"literal","value":"param string name_of_var"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", rather than writing out \"this function takes a parameter of type string named"},{"children":[{"children":null,"tag":"literal","value":"name_of_var"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"\". This does compensate for the tendency of comments to drift out of synchronicity with the code that they are supposed to comment, by tying them back to some computational system to verify its semantic contents, while providing information about the inputs and outputs of the function."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Beyond expliciting inputs and outputs, the second aspect of these comments is targeted at the"},{"children":[{"children":null,"tag":"literal","value":"how"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of the function, helping the reader understand the rationale behind the programmatic process. Comments here aren't cautionary notes on specific edge-cases, as seen in fig."},{"children":[{"children":null,"tag":"literal","value":"code:route_php"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"above, but rather natural language renderings of the overall rationale of the process. The implication here is to provide a broader, and more explicit understanding of the process of the function, in order to allow for further maintenance, extension or modification."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, we look at a subset of the function, the clause of the third if-statement:"},{"children":[{"children":null,"tag":"literal","value":"(preg_match('#^' . $this->regex($pattern) . '$#u', $path, $parameters))"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":". Without comments, one must realize on cognitive gymnastics and knowledge of the PHP syntax in order to render this as an extraction of all route parameters, implying the removal of the first element of the array. In this sense, then, Kirby's code for parsing an HTTP route is both verbose—in comments—and parsimonious—in code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"What these aesthetic features (small number of files, short file length, short function length) imply is an immediate feeling of"},{"children":[{"children":null,"tag":"literal","value":"building blocks"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Short, graspable, (re-)usable (conceptual) blocks are made available to the developer directly, as the Kirby ecosystem, like many other open-source projects, relies on contributions from individuals who are not expected to have any other encounter with the project other than, at the bare minimum, the source code itself."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These two examples, Microsoft Windows 2000 and Kirby CMS, show particular presentations of source code—through repetition, verbosity, commenting and conciseness. These are in part tied to their socio-technical ecosystems made up of hardware, institutional practices ranging from corporate guidelines to open-source contribution, with efficiency and usability remaining at the forefront, both at the result level (the software) and at the process level (the code)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software developers are a large group of practitioners whose focus on producing effective, reliable and sustainable software, leads them to writing in more-or-less codified manner. Before diving into how such a manner of writing relates to references from architecture and engineering in order to foster simplicity and understandability, in section"},{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-domains"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", we acknowledge that the bondary between groups of practicioners isn't a clear-cut one, and so we turn to another practice closely linked to professional development—hacking."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Hackers"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:hackers"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Hackers have been present in popular cultural mostly as young, computer experts, working on the edge of legality. These popular description of hackers tend to veer towards technical excellence, obsession and esoteric involvement with the machine, accompanied by seemingly-radical value systems and political beliefs. They are often depicted as lonely, obsessed programmers, hyperfocused on the task at hand and able to switch altered mental states as they dive into computational problems, as described by Joseph Weizenbaum in 1976"},{"children":[{"children":null,"tag":"literal","value":"\"Wherever computer centers have become established, that is to say, in countless places in the United States, as well as in virtually all other industrial regions of the world, bright young men of disheveled appearance, often with sunken glowing eyes, can be seen sitting at computer consoles, their arms tensed and waiting to fire their fingers, already poised to strike, at the buttons and keys on which their attention seems to be as riveted as a gambler's on the rolling dice. When not so transfixed, they often sit at tables strewn with computer printouts over which they pore like possessed students of a cabalistic text.\""},{"children":[{"children":null,"tag":"literal","value":"weizenbaum_computer_1976"}],"tag":"citation","value":""}],"tag":"footnote","value":"31"},{"children":null,"tag":"literal","value":". While some of it is true—for instance, the gender, the compulsive behaviour and the embodied connection to the machine—, hackers nonetheless designate a wider group of people, one which writes code driven mostly by curiosity, cleverness and freedom. Such a group has had a significant influence in the culture of programming, with which it overlaps with the aforementionned values of intellectual challenges."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"To hack, in the broadest sense, is to enthusiastically inquire about the possibilities of exploitation of technical systems"},{"children":[{"children":null,"tag":"literal","value":"\"HACKER [originally, someone who makes furniture with an axe] n. 1. A person who enjoys learning the details of programming systems and how to stretch their capabilities, as opposed to most users who prefer to learn only the minimum necessary. 2. One who programs enthusiastically, or who enjoys programming rather than just theorizing about programming."},{"children":[{"children":null,"tag":"literal","value":"dourish_original_1988"}],"tag":"citation","value":""}],"tag":"footnote","value":"32"},{"children":null,"tag":"literal","value":"and, as such, isnt' strictly bound to the advent of the computer"},{"children":[{"children":null,"tag":"literal","value":"See Rosenbaum's report in the October 1971 issue of Esquire for an account of phreaking, computer hacking's immediate predecessor"},{"children":[{"children":null,"tag":"literal","value":"rosenbaum_secrets_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"33"},{"children":null,"tag":"literal","value":". Computer hacking specifically came to proeminence as early computers started to become available in north-american universities, and coalesced around the Massachussets Institute of Technology's Tech Model Railroad Club"},{"children":[{"children":null,"tag":"literal","value":"levy_hackers_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Computer hackers were at the time skilled and highly-passionate individuals, with an autotelic inclination to computer systems: these systems mattered most when they referenced themselves, instead of interfacing with a given problem domain. Early hackers were often self-taught, learning to tinker with computers while still in high-school"},{"children":[{"children":null,"tag":"literal","value":"lammers_programmers_1986"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and as such tend to exhibit a radical position towards expertise: skill and knowledge aren't derived from academic degrees or credentials, but rather from concrete ability and practical efficacy"},{"children":[{"children":null,"tag":"literal","value":"A meritocratic stance which has been analyzed in further in"},{"children":[{"children":null,"tag":"literal","value":"coleman_aesthetics_2018"}],"tag":"citation","value":""}],"tag":"footnote","value":"34"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The histories of hacking and of software development are deeply intertwined: some of the early hackers worked on software engineering projects—such as the graduate students who wrote the Apollo Guidance Computer routines under Margaret Hamilton—, and then went on to profoundly shape computer infrastructure. Particularly, the development of the UNIX operating system by Dennis Ritchie and Ken Thompson is a key link in connecting hacker practices and professional ones. Developed from 1969 at Bell Labs, AT\\&T's research division, UNIX was \"very close to being the first system under which a programmer could sit down directly at a machine and compose programs on the fly, exploring possibilities and testing while composing\", and was \"brainstormed by three people and implemented by Ken Thompson in two days — on an obsolete machine that had been designed to be a graphics terminal for a 'real' computer.\""},{"children":[{"children":null,"tag":"literal","value":"raymond_art_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":".  This was a system which was supporting the kind of free exploration of a system's boundaries that is central to hacker culture, and which relied on sharing and circulating source code in order to allow anyone to improve it—in effect, AT\\&T's inexpensive licensing model until the 1980s, and the use of the C programming language starting from 1977 made it widely available within university settings"},{"children":[{"children":null,"tag":"literal","value":"\"Unix has become well entrenched in the nation's colleges and universities due to Western Electric's extensive, inexpensive licensing of the system. As a result, many of today's graduating computer scientists are familiar with it.\""},{"children":[{"children":null,"tag":"literal","value":"morgan_ibm_1982"}],"tag":"citation","value":""}],"tag":"footnote","value":"35"},{"children":null,"tag":"literal","value":". UNIX, a product at the intersection of corporate and hacker culture, was spreading its design philosophy of clear, modular, simple and transparent design across programming communities."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The next step in the evolution of hacker culture built on this tenet to share source code, and hence to make written software understandable from its textual manifestation. The switch identified in the previous section from hardware being the most important component of a computing system to software had led manufacturers to stop distributing source code, making proprietary software the norm. Until then, executable software was the consequence of running the source code through a compilation process; around the 1980s, executable software was distributed directly as a binary file, its exact contents an unreadable series of 0s and 1s. As a result to licensing changes of the UNIX system, the GNU project was created, and in its wake the Free Software Foundation, which established the ethical requirement to access the source code of any software."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the meantime, personal microcomputers came to the market and opened up this ability to tinker and explore computer systems beyond the realms of academic-licensed large mainframes and operating systems. Starting with models such as the Altair 8800, the Apple II and the Commodore 64, as well as with easier, interpreted computer languages such as BASIC, whose first version for such micro-computers was written by Bill Gates, Paul Allen and Monte Davidoff"},{"children":[{"children":null,"tag":"literal","value":"montfort_10_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". While seemingly falling out of the realm of \"proper\" programming, the microcomputer revolution allowed for new groups of individuals to explore the interactivity of source code due to their small size when published as type-in listings."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the wake of the larger free software movement, emerged its less radical counterpart, the open-source movement, as well as its more illegal counterpart, security hacking. The former is usually represented by the types of individuals depicted in mainstream news outlets when they reference hackers: programmers breaching private systems, sometimes in order to cause financial, intelligence or material harm. Security hackers, sometimes called crackers, form a community of practice of their own, with ideas of superior intelligence, subversion, adventure and stealth"},{"children":[{"children":null,"tag":"literal","value":"For a lyrical account of this perception of the hacker ethos, see"},{"children":[{"children":null,"tag":"literal","value":"The Conscience of a Hacker"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", published in Phrack Magazine: \"This is our world now"},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"the world of the electron and the switch, the beauty of the baud.  We make use of a service already existing without paying for what could be dirt-cheap if it wasn't run by profiteering gluttons, and you call us criminals.  We explore"},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"and you call us criminals.  We seek after knowledge"},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"and you call us criminals.\""},{"children":[{"children":null,"tag":"literal","value":"mentor+++_textbackslash_1986"}],"tag":"citation","value":""}],"tag":"footnote","value":"36"},{"children":null,"tag":"literal","value":". These practices nonetheless refer to the original conception of hacking—getting something done quickly, but not well—and include such a practical, efficient appoach into its own set of values and ideals, which are in turn represented in the kinds of program texts being written by members of this community of practice"},{"children":[{"children":null,"tag":"literal","value":"Those program texts include computer viruses, worms, trojan horses and injections, amongst others."}],"tag":"footnote","value":"37"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Meanwhile, the open-source movement took the tenets of hacking culture and adapted it to make it more compatible to the requirements of businesses. Open-source can indeed be seen as a compromise between the software industry development practices and the efficacy of free software development. Indeed, beyond the broad values of intellectual curiosity and skillful exploration, free software projects such as the Linux kernel, the Apache server or the OpenSSL project have proven to be highly efficient, and used in both commercial, non-commercial, critical and non-critical environments"},{"children":[{"children":null,"tag":"literal","value":"raymond_cathedral_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Such an approach sidesteps the political and ethical values held in previous iterations of the hacker ethos in order to focus exclusively on the sharing of source code and open collaboration while remaining within an inquisitive and productive mindframe. With the advent of corporate"},{"children":[{"children":null,"tag":"literal","value":"hackathons"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"—short instances of intense collaboration in order to create new software, or new features on a software system—are a particularly salient example of this overlap between industry practices and hacker practices"},{"children":[{"children":null,"tag":"literal","value":"nolte_you_2018"}],"tag":"citation","value":""},{"children":[{"children":null,"tag":"literal","value":"Along with the address of the software corporate giant Meta's headquarters: 1, Hacker Way, Menlo Park, CA 94025, U.S.A."}],"tag":"footnote","value":"38"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As a community of practice, hackers are programmers which, while overlapping with industry-embedded software developers, hold a set of values and ideals regarding the purpose and state of software. Whether academic hackers, amateurs, security hackers or open-source contributors, all are centered around the object of source code as a vehicle for communicating the knowledge held within the software, and the expertise necessary for writing such software, bypassing auxiliary resources like natural-language documentation. Incidentally, those political and ethical values of expertise and openness often overlap with aesthetic values informing how their code exists in its textual manifestation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"To hack is, according to the dictionary, \"to cut irregularly, without skill or definite purpose; to mangle by or as if by repeated strokes of a cutting instrument\". I have already said that the compulsive programmer, or hacker as he calls himself, is usually a superb technician. It seems therefore that he is not \"without skill\" as the definition will have it. But the definition fits in the deeper sense that the hacker is \"without definite purpose\": he cannot set before him a clearly defined long-term goal and a plan for achieving it, for he has only technique, not knowledge. He has nothing he can analyze or synthesize; in short, he has nothing to form theories about. His skill is therefore aimless, even disembodied. It is simply not connected with anything other than the instrument on which it may be exercised. His skill is that of a monastic copyist who, though illiterate, is a first rate calligrapher."},{"children":[{"children":null,"tag":"literal","value":"weizenbaum_computer_1976"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While he looks down on hackers, perhaps unfairly, from the perspective of a computer scientist whose theoretical work can be achieved only through thought, pen and paper—an approach to programming which we will address in the next section—, the point still remains: hackers are first and foremost technical experts who can get lost in technics for their own sake. From a broad perspective, hackers therefore seem to exhibit an attitude of"},{"children":[{"children":null,"tag":"literal","value":"direct engagement"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"subverted use"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"technical excellence"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":".  Gabriella Coleman, in her anthropological study of hackers, highlights that they value both semantic ingenuity"},{"children":[{"children":null,"tag":"literal","value":"Hackers themselves tend to favor puns—the free software GNU project is a recursive acronym for"},{"children":[{"children":null,"tag":"literal","value":"GNU's Not UNIX"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"39"},{"children":null,"tag":"literal","value":"and technical wittiness, even though source code written by hackers can take multiple shapes, from one-liners, to whole operating systems, to deliberate decisions to subvert best practices in crucial moments"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The"},{"children":[{"children":null,"tag":"literal","value":"one-liner"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is a piece of source code which fits on one line, and is usually intepreted immediately by the operating system. They are terse, concise, and eminently functional: they accomplish one task, and one task only. This binary requirement of functionality (in the strict sense of: \"does it do what it's supposed to do?\") actually finds a parallel in a different kind of one-liners, the humoristic ones in jokes and stand-up comedy. In this context, the one-liner also exhibits the features of conciseness and impact, with the setup conflated with the punch line, within the same sentence. One-liners are therefore self-contained, whole semantic statements which, through this syntactic compression, appear to be clever—in a similar way that a good joke is labelled clever."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In programming, one-liners have their roots in the philosophy of the UNIX operating system, as well as in the early diffusion of computer programs for personal computer hobbyists"},{"children":[{"children":null,"tag":"literal","value":"montfort_10_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". On the one side, the Unix philosophy is fundamentally about building simple tools, which all do one thing well, in order to manipulate text streams"},{"children":[{"children":null,"tag":"literal","value":"raymond_art_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Each of these tools can then be piped (directing one output of a program-tool into the input of the next program-tool) in order to produce complex results—reminiscing of the orthogonality feature of programming languages (see chap. 4). Sometimes openly acknowledged by language designers—such as those of AWK—the goal is to write short programs which shouldn't be longer than one line. Given that constraint, a hacker's response would then be: how short can you make it?"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"If writing one-line programs is within the reach of any medium-skilled programmer, writing the shortest of all programs does become a matter of skill, coupled with a compulsivity to reach the most syntactically compressed version. For instance, Guy Steele"},{"children":[{"children":null,"tag":"literal","value":"Influential langugage designer, who worked on Scheme, ECMAScript and Java, among others."}],"tag":"footnote","value":"40"},{"children":null,"tag":"literal","value":"recalls:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"This may seem like a terrible waste of my effort, but one of the most satisfying moments of my career was when I realized that I had found a way to shave one word off an 11-word program that [Bill] Gosper had written. It was at the expense of a very small amount of execution time, measured in fractions of a machine cycle, but I actually found a way to shorten his code by 1 word and it had only taken me 20 years to do it."},{"children":[{"children":null,"tag":"literal","value":"seibel_coders_2009"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This sort of compulsive behaviour is also manifested in the practice of"},{"children":[{"children":null,"tag":"literal","value":"code golf"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", challenges in which programmers must solve problems by using the least possible amount of characters—here, the equivalent of"},{"children":[{"children":null,"tag":"literal","value":"par"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in golf would be Kolmogorov complexity"},{"children":[{"children":null,"tag":"literal","value":"See:"},{"children":[{"children":null,"tag":"literal","value":"https://en.wikipedia.org/wiki/Kolmogorov_complexity"}],"tag":"url","value":""}],"tag":"footnote","value":"41"},{"children":null,"tag":"literal","value":". Minimizing program length in relation to the problem complexity is therefore a definite feature of one-liners, since choosing the right programming language for the right tasks can lead to a drastic reduction of syntax, while keeping the same expressive and effective power. Tasked with parsing a text file to find which lines had a numerical value greater than 6, Brian Kernighan writes the code in"},{"children":[{"children":null,"tag":"literal","value":"code:select_lines_c"}],"tag":"reference","value":""},{"children":[{"children":null,"tag":"literal","value":"From Succesful Language Design, Brian Kernighan at the University of Nottingham,"},{"children":[{"children":null,"tag":"literal","value":"https://www.youtube.com/watch?v=Sg4U4r_AgJU"}],"tag":"url","value":""}],"tag":"footnote","value":"42"},{"children":null,"tag":"literal","value":":"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/select_lines.c"}],"tag":"code","value":"cpp"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Selecting lines from an input file in C"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:select_lines_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The equivalent in AWK, a language he designed, and which he actually refers to in the comment on line 15, presumably as a heuristic as he is writing the function, is seen in"},{"children":[{"children":null,"tag":"literal","value":"code:select_lines_awk"}],"tag":"reference","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/select_lines.sh"}],"tag":"code","value":"bash"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Selecting lines from an input file in AWK"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:select_lines_awk"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The difference is obvious, not just in terms of formal clarity and reduction of the surface structure, but also in terms of matching the problem domain: this obviously prints every line in which the third field is greater than 6. The AWK one-liner is more efficient, more understandable because it allows for less confusion, and is therefore more beautiful. On the other hand, however, one-liners can be so condensed that they loose all sense of clarity for someone who doesn't have a deep knowledge of the specific language in which it is written. For instance, here is Conway's game of life implemented in one line of APL"},{"children":[{"children":null,"tag":"literal","value":"code:game_of_life"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/game_of_life.apl"}],"tag":"code","value":"text"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Conway's Game of Life implemented in APL"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:game_of_life"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The obscurity of such a line—due to its highly-unusual character notation, and despite the pre-existing knowledge of the expected output—shows why one-liners are usually highly discouraged for any sort of code which needs to be worked on by other programmers. Cleverness in programming indeed tends to be seen as a display of the relationship between the programmer and the machine, rather than between different programmers and only tangentially about the machine. On the other hand, though, the nature of one-liners makes them highly portable and shareable, infusing them with what one could call"},{"children":[{"children":null,"tag":"literal","value":"social beauty"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Popular with early personal computer adopters, at a time during which the source code of programs were printed in hobbyist magazines and needed to be input by hand, and during which access to computation wasn't widely distributed amongst society, being able to type just one line in, say, a BASIC interpreter, and resulting in unexpected graphical patterns created a sense of magic and wonder in first-time users—how can so little do so much?"},{"children":[{"children":null,"tag":"literal","value":"For an example fo such one-liner, see for instance:"},{"children":[{"children":null,"tag":"literal","value":"https://www.youtube.com/watch?v=0yKwJJw6Abs"}],"tag":"url","value":""}],"tag":"footnote","value":"43"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another example of beautiful code written by hackers is the UNIX operating system, whose inception was an informal side-project spearheaded by Ken Thompson and Dennis Ritchie in the 1970s. As the first portable operating system, UNIX's influence in modern computing was significant, e.g. in showing the viability and efficiency of text-based processing, hierarchical file-system, shell scripting and regular expressions, amongst others. UNIX is also one of the few pieces of production software which has been carefully studied and documented by other developers. One of the most famous examples is"},{"children":[{"children":null,"tag":"literal","value":"Lions' Commentary on UNIX 6th Edition, with Source Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"by John Lions, an annotated edition of the UNIX source code, which was circulated illegaly in classrooms for twenty years before its official publication was authorized by the copyright owners"},{"children":[{"children":null,"tag":"literal","value":"lions_lions_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This need to allow for quality software to be studied is highlighted by the architect Christopher Alexander, in the preface of software developer Richard P. Gabriel's"},{"children":[{"children":null,"tag":"literal","value":"Patterns of Software"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":":"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"For a programmer, what is a comparable goal? What is the Chartres of programming? What task is at a high enough level to inspire people writing programs, to reach for the stars?"},{"children":[{"children":null,"tag":"literal","value":"gabriel_patterns_1998"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"UNIX might be one of the answers to that question, both by its functionality, and by its conciseness, if not alone by its availability."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another program which qualifies as beautiful hacker code, due both to its technical excellence, unusual solution and open-source availability is the function to compute the inverse square root of a number, a calculation that is particularly necessary in any kind of rendering application (which heavily involves vector arithmetic). It was found in the source code of id Software's"},{"children":[{"children":null,"tag":"literal","value":"Quake"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"video game, listed in"},{"children":[{"children":null,"tag":"literal","value":"code:fast_sqrt_c"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"verbatim"},{"children":[{"children":null,"tag":"literal","value":"The Quake developers aren't the authors of that function—the merit of which goes to Greg Walsh—but are very much the authors of the comments."}],"tag":"footnote","value":"44"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/fast_inverse_sqrt.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Inverse fast square root"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:fast_sqrt_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"What we see here is a combination of the understanding of the problem domain (i.e. the acceptable result needed to maintain a high-framerate with complex graphics), the specific knowledge of low-level computers operations (i.e. bit-shifting of a float cast as an integer) and the snappiness and wonder of the comments"},{"children":[{"children":[{"children":null,"tag":"literal","value":"what the fuck?"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"indeed"}],"tag":"footnote","value":"45"},{"children":null,"tag":"literal","value":". The use of"},{"children":[{"children":null,"tag":"literal","value":"0x5f3759df"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"is what programmers call a"},{"children":[{"children":null,"tag":"literal","value":"magic number"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", a literal value whose role in the code isn't made clearer by a descriptive variable name. Usually bad practice and highly-discouraged, the magic number here is exactly that: it makes the magic happen."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Further examples of such intimate knowledge of both the language and the machine can be found in the works of the"},{"children":[{"children":null,"tag":"literal","value":"demoscene"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Starting in Europe in the 1980s, demos were first short audio-visual programs which were distributed along with"},{"children":[{"children":null,"tag":"literal","value":"crackware"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(pirated software), and to which the names of the people having cracked the software were prepended, in the form of a short animation"},{"children":[{"children":null,"tag":"literal","value":"reunanen_computer_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Due to this very concrete constraint—there was only so much memory left on a pirated disk to fit such a demo—programmers had to work with these limitations in order to produce the most awe-inspiring graphics effects before software boot. One notable feature of the demoscene is that the output should be as impressive as possible, as an immediate, phenomenological appreciation of the code which could make this happen"},{"children":[{"children":null,"tag":"literal","value":"For an example, see"},{"children":[{"children":null,"tag":"literal","value":"Elevated"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", programmed by iq, for a total program size of 4 kilobytes:"},{"children":[{"children":null,"tag":"literal","value":"https://www.youtube.com/watch?v=jB0vBmiTr6o"}],"tag":"url","value":""}],"tag":"footnote","value":"46"},{"children":null,"tag":"literal","value":". Indeed, the"},{"children":[{"children":null,"tag":"literal","value":"comp.sys.ibm.pc.demos"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"news group states in their FAQ:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"A Demo is a program that displays a sound, music, and light show, usually in 3D. Demos are very fun to watch, because they seemingly do things that aren't possible on the machine they were programmed on."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Essentially, demos \"show off\". They do so in usually one, two, or all three of three following methods:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"They show off the computer's hardware abilities (3D objects, multi-channel sound, etc.)"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"They show off the creative abilities of the demo group (artists, musicians)"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"They show off the programmer's abilities (fast 3D shaded polygons, complex motion, etc.)"},{"children":[{"children":null,"tag":"literal","value":"melik_pc_2012"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"list","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This showing off, however, does not happen through immediate engagement with the code from the reader's part, but rather in the thorough explanation of the minute functionalities of the demo by its writer. Because of these constraints of size, the demos are usually written in C, openGL, Assembly, or the native language of the targeted hardware. Source code listings of demos also make extensive use of shortcuts and tricks, and little attention is paid to whether or not other humans would directly read the source—the only intended recipient is a very specific machine (e.g. Commodore 64, Amiga VCS, etc.). The release of demos, usually in demoparties, are sometimes accompanied by documentation, write-ups or presentations"},{"children":[{"children":null,"tag":"literal","value":"You can find"},{"children":[{"children":null,"tag":"literal","value":"Elevated"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"'s technical presentation here:"},{"children":[{"children":null,"tag":"literal","value":"https://www.iquilezles.org/www/material/function2009/function2009.pdf"}],"tag":"url","value":""}],"tag":"footnote","value":"47"},{"children":null,"tag":"literal","value":". However, this presentation format acknowledges a kind of individual, artistic feat, rather than the"},{"children":[{"children":null,"tag":"literal","value":"egoless programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"lauded by Brooks in professional software development."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Pushing the boundaries of how much can be done in how little code, here is a 256-bytes demo resulting in a minute-long music video"},{"children":[{"children":null,"tag":"literal","value":"akesson_mind_2017"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"on the Commodore 64. It is firsted listed as a hexademical dump by its author (see"},{"children":[{"children":null,"tag":"literal","value":"code:a_mind_is_born.hex"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":")"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/a_mind_is_born.hex"}],"tag":"code","value":"hexdump"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Actual source code of the demo A Mind is Born. Instructions are given to the computer as hexadecimal chunks."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:a_mind_is_born.hex"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Even with knowledge of how hexadecimal instructions map to the instruction set of the specific chip of of the Commodore 64 (in this case, the SID 8580), the practical use of these instructions takes productive advantage of ambivalence and side-effects. In the words of the author, Linus Akesson (emphasis mine):"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"We need to tell the VIC chip to look for the video matrix at address \\$0c00 and the font at \\$0000. This is done by writing \\$30 into the bank register (\\$d018). But this will be done from within the loop, as doing so allows us to use the value \\$30 for two things."},{"children":[{"children":null,"tag":"literal","value":"An important property of this particular bank configuration is that the system stack page becomes part of the font definition"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Demosceners therefore tend to write beautiful, deliberate code which is hardly understandable by other programmers without explanation, and yet hand-optimized for the machine. This presents a different perspective of the relationship between aesthetics and understanding, in which aesthetics do not support and enable understanding, but rather become a proof of the mastery and skill required to input such a concise input for such an overwhelming output. This shows in an extreme way that one does need a degree of expert knowledge in order to appreciate it—in this sense, aesthetics in programming are shown to be almost often dependent on pre-existing knowledge."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Hackers are programmers who write code within a variety of settings, from academia to hobbyists through professional software development, with an explicit focus on knowledge and skill. Yet, some patterns emerge. First, one can see the emphasis on the"},{"children":[{"children":null,"tag":"literal","value":"ad hoc"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", insofar as choosing the right tool for the right job is a requirement for hacker code to be valued positively. This requirement thus involves an awareness of which tool will be the most efficient at getting the task at hand done, with a minimum of effort and minimum of overhead, usually at the expense of sustaining or maintaining the software beyond any immediate needs, making it available or comprehensible neither across time nor across individuals, a flavour of"},{"children":[{"children":null,"tag":"literal","value":"locality"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Second, this need for knowing and understanding one's tools hints at a material relationship to code, whether instructions land in actual physical memory registers, staying away from abstraction and remaining in \"concrete reality\" by using magic numbers, or sacrificing semantic clarity in order to"},{"children":[{"children":null,"tag":"literal","value":"\"shave off\""}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"a character or two."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The ideals at play in the writing and reading of source code for hackers is thus centered around specific means of knowledge: knowledge of the hardware, knowledge of the programming language used and knowledge of the tradeoffs acceptable all the while exhibiting an air of playfulness—how far can one go pushing a system's boundaries before it breaks down entirely? How little effort can one put in order to get a maximum outcome? Yet, one aspect that seems to elude hackers in their conception of code is that of conceptual soundness. If code is considered beautiful by attaining previously unthought achievements of purposes with the least amount of resources, rationalization as to why, whether"},{"children":[{"children":null,"tag":"literal","value":"a prior"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"a posteriori"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", does not seem to be a central value. Hackers exhibit tendencies to both"},{"children":[{"children":null,"tag":"literal","value":"get the job done"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"do it for the sake of doing it"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":".This behaviour is unlike that of computer and data scientists, and towards whom we turn to next."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"If hacking can be considered a way of doing which deals with the practical intricacies of programming, involving concrete knowledge of the hardware and the language, our third group tends towards the opposite. Programming scientists (of which computer scientists are a subset) engage with progamming first and foremost at the conceptual level, with different locii of implementation: either as a"},{"children":[{"children":null,"tag":"literal","value":"theory"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", or as a"},{"children":[{"children":null,"tag":"literal","value":"model"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Scientists"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:scientists"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Historically, then, programming emerged as a distinct practice from the computing sciences: not all programmers are computer scientists, and not all computer scientists are programmers. Nonetheless, scientists engage with programming and source code in two distinct ways, and as such open up the landscape of the type of code which can be written, and of the standards which support the evaluation of formally satisfying code. First, we will look at code being written outside of computer science research activities and, through it, examine how the specific needs of usability, replicability and data structuring link back to standards of software development. Then, we will to the code written by computer scientists, such as programming language designers, and develop how computer implementation exists between the dual scientific pillars of theorization and experimentation"},{"children":[{"children":null,"tag":"literal","value":"vardi_science_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Computation as a means"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:computation-means"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Scientific computing, defined as the use of computation in order to solve non-computer science tasks, started as early as the 1940s and 1950s in the United States, aiding in the design of the first nuclear weapons, among others"},{"children":[{"children":null,"tag":"literal","value":"oberkampf_verification_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Essentially, calculations necessary to the verification of theories in disciplines such as physics, chemistry or mathematics were handed over to the computing machines of the time. Beyond the military applications of early computer technology, one can point to Harlow and Fromm's article on"},{"children":[{"children":null,"tag":"literal","value":"Computer Experiments in Fluid Dynamics"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", published in 1965, focusing on how the advent of computing technology would prove to be of great assistance in physics and engineering:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The fundamental behavior of fluids has traditionally been studied in tanks and wind tunnels. The capacities of the modern computer make it possible to do subtler experiments on the computer alone."},{"children":[{"children":null,"tag":"literal","value":"harlow_computer_1965"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At this time,Computation and computers are perceived as promising automated aids in processing data at a much faster rates than human scientists"},{"children":[{"children":null,"tag":"literal","value":"licklider_mancomputer_1960"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The remaining issue, then, is to make computers more accessible to scientists which did not have direct exposure to them, and therefore might be unfamiliar to the intricacies of their use. Beyond the unaffordable price point of university mainframes before the personal computer revolution, another vector for simplification and accessibility is the development of adequate programming languages. Developed in 1964 at Dartmouth College,"},{"children":[{"children":null,"tag":"literal","value":"BASIC"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"(Beginners' All-purpose Symbolic Instruction Code) aims at addressing this hurdle by designing \""},{"children":[{"children":null,"tag":"literal","value":"the world's first user-friendly programming language"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" "},{"children":[{"children":null,"tag":"literal","value":"brooks_finally_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The intent is to provide non-computer scientists with easy means to instruct the computer on how to perform computations relevant to their work. Still, computing in the academia will only pick up with the distribution of the multiple versions of the UNIX timesharing system, which allowed multiple users to use a given machine at the same time, and the performance boost as well as the versatility provided by the C programming language in the late 1970s."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"By the dawn of the 21st century, scientific computing had increased in the scope of its applications (extending beyond engineering and experimental, so-called \"hard\" sciences, to social sciences and the humanities) as well as in the time spent developing and using software"},{"children":[{"children":null,"tag":"literal","value":"prabhu_survey_2011"}],"tag":"citation","value":""},{"children":[{"children":null,"tag":"literal","value":"hannay_how_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", with the main programming languages used being MATLAB, C/C++ and Python. While C and C++'s use can be attributed to their historical standing, popularity amongst computer scientists, efficiency for systems programming and speed of execution, MATLAB and Python offer different perspectives. MATLAB, originally a matrix calculator from the 1970s, became popular with the academic community by providing features such as a reliable way to do floating-point arithmetic and a graphical user interface (GUI). Along with its powerful array-manipulation features, the ability to visualize large series of data and plot it on a display largely contributed to MATLAB's popularity"},{"children":[{"children":null,"tag":"literal","value":"moler_history_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", features shared with RStudio, a GUI to the R programming language. In"},{"children":[{"children":null,"tag":"literal","value":"code:mesh_m"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", one can see in"},{"children":[{"children":null,"tag":"literal","value":"graphic:mesh-visualization"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"how concise the plotting of a three-dimensional plane is in MATLAB, requiring only one call to"},{"children":[{"children":null,"tag":"literal","value":"mesh"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/mesh.matlab"}],"tag":"code","value":"matlab"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Mesh.m"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:mesh_m"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"width=\\textwidth,height=\\textheight,keepaspectratio"},{"children":null,"tag":"literal","value":"matlab.png"}],"tag":"image","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Visualization of a 3D-mesh in Matlab"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"graphic:mesh-visualization"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"figure","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In parallel to MATLAB and R, Python represents the advent of the so-called scripting languages. Scripting languages are programming  languages which offer readability and versatility, along with decoupling from the actual operating system that it is being executed on. System languages, such as C, are designed and used in order to interact directly with the computer hardware, and to constitute data structures from the ground up"},{"children":[{"children":null,"tag":"literal","value":"ousterhout_scripting_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". On the other hand, scripting languages were designed and used in order to connect existing software systems or data sources together, most notably in the early days of shell scripting (such as"},{"children":[{"children":null,"tag":"literal","value":"Bash"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"sed"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"awk"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"). Starting with the late 1990s, and the appearance of languages such as Perl"},{"children":[{"children":null,"tag":"literal","value":"First version developed in 1987 by Larry Wall"}],"tag":"footnote","value":"48"},{"children":null,"tag":"literal","value":"and Python"},{"children":[{"children":null,"tag":"literal","value":"First official release in 1991 by Guido Van Rossum"}],"tag":"footnote","value":"49"},{"children":null,"tag":"literal","value":", scripting languages became more widely used by non-programmers who already had data to work with and needed tools to exploit it. In the following decades, the development of additional scientific libraries such as"},{"children":[{"children":null,"tag":"literal","value":"SciKit"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"NumPy"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"for mathematics and numerical work or"},{"children":[{"children":null,"tag":"literal","value":"NLTK"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"for language processing and social sciences in Python complemented the language's ease of use by providing manipulation of complex scientific concepts"},{"children":[{"children":null,"tag":"literal","value":"millman_python_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a phenomenon of user-extension which has also been observed in R and MATLAB's ecosystems"},{"children":[{"children":null,"tag":"literal","value":"moler_history_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This steady rise of scientific computing has nonetheless highlighted the apparent lack of quality standards in academic software, and how the lack of value judgments on the software written might impact the reliability of the scientific output. Perhaps the most well-known example of such a lack is the one revealed by the leak of the source code of the Climate Research Unit from the University of East Anglia in 2009"},{"children":[{"children":null,"tag":"literal","value":"merali_computational_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In the leak, inline comments of the authors, show that particular variable values were chosen to make the simulation run, with scientific accuracy being only a secondary concern. Code reviews of external software developers point out to the code of the CRU leak as being a symptom of the general state of academic software. As Professor Darrel Ince stated to the UK Parliamentary Committee in February 2010:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"There is enough evidence for us to regard a lot of scientific software with worry. For example Professor Les Hatton, an international expert in software testing resident in the Universities of Kent and Kingston, carried out an extensive analysis of several million lines of scientific code. He showed that the software had an unacceptably high level of detectable inconsistencies."},{"children":[{"children":null,"tag":"literal","value":"committee_disclosure_2010"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As a response to this realization, the beginning of the 2000s has seen the desire to re-integrate the best practices of software engineering in order to correct scientific software's lack of accuracy"},{"children":[{"children":null,"tag":"literal","value":"hatton_how_1994"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", resulting in the formation of communities such as the Research Software Engineers"},{"children":[{"children":null,"tag":"literal","value":"woolston_why_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As we have seen above, software engineering had developed on their own since its establishment as an independent discipline and professional field. Such a split, described by Diane Kelly as a \""},{"children":[{"children":null,"tag":"literal","value":"chasm"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" "},{"children":[{"children":null,"tag":"literal","value":"kelly_software_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"then had to face the different standards to which commercial software and scientific software were held to. For instance, commercial software must be extensible and performant, two qualities that do not necessarily translate to an academic setting, in which software might be written within a specific, time-constrained, research project, or in which access to computing resources (i.e. supercomputers) might be less of a problem."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Within Landau et. al's conception of the scientific process as the progression from problem to theory, followed by the establishment of a model, the devising of a method, and then on to implemementation and finally to assessment"},{"children":[{"children":null,"tag":"literal","value":"landau_survey_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", code written as academic software is involved in the latter two stages of  method and implementation. Within those two stages, software has to abide by the processes and requirements of scientific research. First and foremost, reproducibility is a core requirement of scientific research in general"},{"children":[{"children":null,"tag":"literal","value":"We can date this requirement back to the seventeenth century with Robert Boyle and the Invisible College in England"},{"children":[{"children":null,"tag":"literal","value":"leveque_reproducible_2012"}],"tag":"citation","value":""}],"tag":"footnote","value":"50"},{"children":null,"tag":"literal","value":"and bugs in a scientific software system can lead to radically different ouptuts given slightly different input data, while concealing the origin of this difference. Good academic code, then, is one which defends actively against these, perhaps to the expense of performance and maintainability. This can be addressed by reliable error-handling, regular assertions of the state of the processed data and extensive unit testing"},{"children":[{"children":null,"tag":"literal","value":"wilson_best_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Furthermore, a unique aspect of scientific software comes from the lack of clear upfront requirements. Such requirements, in software development, are usually provided ahead of the programming process, and should be as complete as possible. As the activity of scientists is defined by an incomplete understanding of the application domain, requirements tend to emerge as further knowledge is developed and acquired"},{"children":[{"children":null,"tag":"literal","value":"segal_when_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As a result, efforts have been made to familiarize scientists with software development best practices, so that they can implement quality software on their own. Along with field-specific textbooks"},{"children":[{"children":null,"tag":"literal","value":"See"},{"children":[{"children":null,"tag":"literal","value":"Effective Computation in Physics"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"scopatz_effective_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"A Primer for Computational Biology"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"oneil_primer_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"covering similar software-oriented material from different academic perspectives."}],"tag":"footnote","value":"51"},{"children":null,"tag":"literal","value":"the most prominent initiative in the field is"},{"children":[{"children":null,"tag":"literal","value":"Software Carpentry"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", a collection of self-learning and teaching resources which aims at implementing software best practices across academia, for scientists and by scientists. Founded by Greg Wilson, the co-editor of"},{"children":[{"children":null,"tag":"literal","value":"Beautiful Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the organization's title refers directly to equivalents in the field of software development."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We see a convergence of quality standards of broad academic software towards the quality standards of commercial software development"},{"children":[{"children":null,"tag":"literal","value":"See Graphbrain at"},{"children":[{"children":null,"tag":"literal","value":"https://github.com/graphbrain/graphbrain"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":"for such an example. The code's organization and formal features are congruent and on par with commercial software."}],"tag":"footnote","value":"52"},{"children":null,"tag":"literal","value":".  And yet, this convergence is due to, as we have seen, a past divergence between computation and science, as computer science worked towards asserting and pursuing its own field of research. As a subset of science, computer science nonetheless possesses its own specific standards, taking software not as a means to an end, but as the end itself."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Computation as an end"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:computation-end"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Computer scientists are scientists whose work focuses on computation as a means, rather than as a tool. They study the phenomenon of computation, investigating its nature and effects through the development of theoretical frameworks around it. Originally derived from computability theory, as a branch of formal mathematical logic, computation emerged as an autonomous field from work in mechanical design and configuration (Ada Lovelace and Charles Babbage),  work on circuit and language design (C. S. Pierce, Konrad Zuse and John Von Neumann), work on mathematical foundations (Alan Turing and Alonzo Church), information theory (Claude Shannon), systems theory (Norbert Wiener) and expert systems (John McCarthy and Marvin Minsky)"},{"children":[{"children":null,"tag":"literal","value":"ifrah_universal_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In the middle of such a constellation ranging from mathematical theory to practical electronics, computer science establishes its institutional grounding with the inauguration of the first dedicated academic department at Purdue University in 1962."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From this multifaceted heritage and academic interdisciplinarity, computer scientists identified key areas such as data structures, algorithms and language design as foundations of the discipline"},{"children":[{"children":null,"tag":"literal","value":"wirth_algorithms_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Though the process, the tracing of the \"roots\" of computation remained a constant debate as to whether computer science exists within the realm of mathematics, of engineering or as a part of the natural sciences. The logico-mathematical model of computer science contends that one can do computer science without an electronic computer, while the engineering approach of computer science tends to put more practical matters, such as architecture, language design and systems programming (implicitly assuming the use of a digital computer) at the core of the discipline; both being a way to generate and process information as natural phenomenon"},{"children":[{"children":null,"tag":"literal","value":"tedre_development_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The broad difference we can see between these two conceptions of computer science is that of"},{"children":[{"children":null,"tag":"literal","value":"episteme"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"techne"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". On the theoretical and scientific side, computer science is concerned with the primacy of ideas, rather than of implementation. The quality of a given program is thus deduced from its formal (in the mathematical sense) properties, rather than its formal (in the aesthetic sense) properties. The first manifestations of such a theoretical focus can be found in the Information Processing Language (1956 by Allen Newell, Cliff Shaw and Herbert Simon), which was originally designed and developed to prove Bertrand Russell's"},{"children":[{"children":null,"tag":"literal","value":"Principia Mathematica"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". While the IPL, as one of the very first programming languages, influenced the development of multiple subsequent languages, some later languages came to be known as logic programming languages, based on a formal logic syntax of facts, rules and clauses about a given domain and whose correctness can be easily proven (see"},{"children":[{"children":null,"tag":"literal","value":"code:prolog_sample"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"below for an example of the"},{"children":[{"children":null,"tag":"literal","value":"Prolog"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"logic programming language)."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/inductive.pl"}],"tag":"code","value":"prolog"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Prolog sample source"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:prolog_sample"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Due to its Turing-completeness, one can write programs such as language processing, web applications, cryptography or database programming (using the"},{"children":[{"children":null,"tag":"literal","value":"Datalog"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"variant of"},{"children":[{"children":null,"tag":"literal","value":"Prolog"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"), but its use seems to remain limited outside of theoretical circles in 2021"},{"children":[{"children":null,"tag":"literal","value":"See the Stackoverflow Developer survey for popular language uses"},{"children":[{"children":null,"tag":"literal","value":"https://insights.stackoverflow.com/survey/2021"}],"tag":"url","value":""}],"tag":"footnote","value":"53"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another programming language shares this feature of theoretical soundness faced with a limited range of actual use in production environments, Lisp—"},{"children":[{"children":null,"tag":"literal","value":"LISt Processor"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"—designed to process lists. It was developed in 1958, the year of the Dartmouth workshop on Artificial Intelligence, by its organizator, John McCarthy. Inheriting from IPL, it retained the core idea that programs should separate the knowledge of the problem (input data) and ways to solve it (internal rules), assuming  the rules are independent to a specific problem."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The base structural elements of LISP are not symbols, but lists (of symbols, of lists, of nothing), and they themselves act as symbols (e.g. the empty list). By manipulating those lists recursively—that it, processing something in terms of itself—Lisp highlights even further this tendency to separate computation from the problem domain, and to exhibit autotelic tendencies. This is facilitated by its atomistic and relational structure: in order to solve what it has do, it evaluates each symbol and traverses a tree-structure in order to find a terminal symbol. Building on these features of complex structures with simple elements, Willam Byrd, computer scientst at the University of Utah, describes the following lines of Scheme (a LISP dialect) as \"the most beautiful program ever written\""},{"children":[{"children":null,"tag":"literal","value":"byrd_william_2017"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a Scheme interpreter written in Scheme ("},{"children":[{"children":null,"tag":"literal","value":"code:scheme_interpreter"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"):"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/interpreter.scheme"}],"tag":"code","value":"scheme"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Scheme interpreter written in Scheme"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:scheme_interpreter"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The beauty of such a program, for Byrd, is the abilty of these fourteen lines to reveal powerful and complex ideas about the nature and process of computation. As an interpreter, this program can take any valid Scheme input and evaluate it correctly, recreating computation in terms of itself. It does so by showing and using ideas of recursion (with calls to"},{"children":[{"children":null,"tag":"literal","value":"eval-expr"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"), environment (with the evaluation of the"},{"children":[{"children":null,"tag":"literal","value":"body"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":") and lambda functions, as used throughout the program. Following Alan Kay, creator of the Smalltalk programming language, Byrd equates the feelings he experiences in witnessing and pondering the program above to those suggested by Maxwell's equations, which constitute the foundation of classical electromagnetism (see"},{"children":[{"children":null,"tag":"literal","value":"graphic:maxwell-equations"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":") "},{"children":[{"children":null,"tag":"literal","value":"kay_conversation_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In both cases, the quality ascribed to those inscriptions come from the simplicity and conciseness of their base elements—making it easy to understand what the symbols mean and how we can compute relevant outputs—all the while allowing for complex consequences for both, respectively, computer science and electromagnetism."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"width=\\textwidth,height=\\textheight,keepaspectratio"},{"children":null,"tag":"literal","value":"maxwell.png"}],"tag":"image","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Maxwell's equations form a terse, unified basis for electromagnetism, optics and electric circuitry."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"graphic:maxwell-equations"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"figure","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With this direct manipulation of symbolic units upon which logic operations can be performed, Lisp became the language of AI, an intelligence conceived first and foremost as abstractly logical, if not outright algebraic. Lisp-based AI was thus working on what Seymour Papert has called \"toy problems\"—self-referential theorems, children's stories, or simple puzzles or games"},{"children":[{"children":null,"tag":"literal","value":"nilsson_early_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In these, the problem and the hardware are reduced from their complexity and multi-consequential relationships to a finite, discreete set of concepts and situations. Confronted to the real world—that is, to commercial exploitation—Lisp's model of symbol manipulation, which proved somewhat successful in those early academic scenarios, started to be applied to issues of natural language understanding and generation in broader applications. Despite disappointing reviews from government reports regarding the effectiveness of these AI techniques, commercial applications flourished, with companies such as Lisp Machines, Inc. and Symbolics offering Lisp-based development and support. Yet, in the 1980s, over-promising and under-delivering of Lisp-based AI applications, which often came from the combinatorial explosion deriving from the list- and tree-based representations, met a dead-end."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"\""},{"children":[{"children":null,"tag":"literal","value":"By making concrete what was formerly abstract, the code for our Lisp interpreter gives us a new way of understanding how Lisp works"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\", notes Michael Nielsen in his analysis of Lisp, pointing at how, across from the"},{"children":[{"children":null,"tag":"literal","value":"episteme"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of computational truths stands the"},{"children":[{"children":null,"tag":"literal","value":"techne"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of implementation"},{"children":[{"children":null,"tag":"literal","value":"nielsen_lisp_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The alternative to such abstract, high-level language, is then to consider computer science as an engineering discipline, a shift between theoretical programming and practical programming is Edsger Dijkstra's"},{"children":[{"children":null,"tag":"literal","value":"Notes on Structured Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In it, he points out the limitation of considering programming exclusively as a concrete, bottom-up activity, and the need to formalize it in order to conform to the standards of mathematical logical soundness. Djikstra argues for the superiority of formal methods through the need for a sound theoretical basis when writing software, at a time when the software industry is confronted with its first crisis."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Within the software engineering debates, the theory and practice distinction had a slightly different tone, with terms like “art” and “science” labeling two different mindsets concerning programming"},{"children":[{"children":null,"tag":"literal","value":"knuth_art_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As mentioned by Djikstra's example, software engineering suffered from an earlier image of programming as an inherently unmanageable, unsystematic, and artistic activity. There again, many saw programming essentially as an art or craft"},{"children":[{"children":null,"tag":"literal","value":"tedre_development_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", rather than an exact science. Beyond theoretical soundness, computer science engineering concerns itself with efficiency and sustainability, with measurements such as the"},{"children":[{"children":null,"tag":"literal","value":"O()"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"notation for program execution complexity. It is not so much about whether it is possible to express an algorithm in a programming language, but whether it is possible to run it effectively, in the contingent environments of hardware, humans and problem domains"},{"children":[{"children":null,"tag":"literal","value":"Notably, algorithms in textbooks tend to be erroneous when used in production; only in five out of twenty are they correct"},{"children":[{"children":null,"tag":"literal","value":"pattis_textbook_1988"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"54"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This approach, halfway between science and art, is perhaps best seen in Donald Knuth's magnum opus,"},{"children":[{"children":null,"tag":"literal","value":"The Art of Computer Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In it, Knuth summarizes the findings and achievements of the field of computer science in terms of algorithm design and implementation, in order to \""},{"children":[{"children":null,"tag":"literal","value":"to organize and summarize what is known about the fast subject of computer methods and to give it firm mathematical and historical foundations."}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" "},{"children":[{"children":null,"tag":"literal","value":"knuth_art_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The art of computer programming, according to him, is therefore based on mathematics, but nonetheless different from it insofar as it does have to deal with effectiveness, implementation and contingency"},{"children":[{"children":[{"children":null,"tag":"literal","value":"The Art of Computer Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"involves a hypothetical computer, called MIX, to implement the algorithms discussed."}],"tag":"footnote","value":"55"},{"children":null,"tag":"literal","value":". In so doing, Knuth takes on a more empirical approach to programming than his contemporaries, inspecting source code and running software to assess their performance, an approach he first inaugurated for FORTRAN programs when reporting on their concrete effectiveness for the United States Department of Defense"},{"children":[{"children":null,"tag":"literal","value":"defensetechnicalinformationcenter_dtic_1970"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Structure and Interpretation of Computer Programs"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is another influential academic textbook dealing not just with computation as a an autotelic phenomenon, in which the authors insist that source code is \""},{"children":[{"children":null,"tag":"literal","value":"must be written for people to read, and only incidentally for machines to execute"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" "},{"children":[{"children":null,"tag":"literal","value":"abelson_structure_1979"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Still, even when confronted with implementation and the plurality of contingencies of non-mathematical elements which accompanies it, the aesthetic standard in this more engineering approach to computer science is the proportionality between the number of lines of code written and the complexity of the idea explained, as we can see in the series"},{"children":[{"children":null,"tag":"literal","value":"Beautiful Julia Algorithms"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"moss_beautifulalgorithms_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". For instance,"},{"children":[{"children":null,"tag":"literal","value":"code:bubble_sort_julia"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"implements the Bubble Sort sorting algorithm in one loop rather than the usual two loops in C, resulting in an easier grasping of the concept at hand, rather than being distracted by the idiosyncracy of the implementation. The simplicity of scientific algorithms is expressed even further in"},{"children":[{"children":null,"tag":"literal","value":"code:nearest_neighbor_julia"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"the one-line implementation of a procedure for finding a given element's nearest neighbor, a crucial component of classification systems, including AI systems."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/bubblesort.jl"}],"tag":"code","value":"julia"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Bubble Sort implementation in Julia"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:bubble_sort_julia"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/nearest_neighbor.jl"}],"tag":"code","value":"julia"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Nearest neighbor implementation in Julia"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:nearest_neighbor_julia"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"According to Tedre, computer science itself was split in a struggle between correctness and productivity, between theory and implementation, and between formal provability and intuitive art"},{"children":[{"children":null,"tag":"literal","value":"tedre_science_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In the early developments of the field, when machine time was expensive and every instruction cycle counted, efficiency ruled over elegance, but in the end he assesses elegance prevailed, as we will see with the evolution of craft within programming in section"},{"children":[{"children":null,"tag":"literal","value":"sec:craft"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"below."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In closing, one should note that the"},{"children":[{"children":null,"tag":"literal","value":"Art"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in the title of Knuth's series does not, however, refer to art as a fine art, or a purely aesthetic object. In a 1974 talk at the ACM, Knuth goes back to its Latin roots, where we find"},{"children":[{"children":null,"tag":"literal","value":"ars"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"artis"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"meaning \"skill.\", noting that the equivalent in Greek being τεχνη, the root of both \"technology\" and \"technique.\". This semantic proximity helps him reconcile computation as both a science and an art, the first due to its roots in mathematics and logic, and the second"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"because it applies accumulated knowledge to the world, because it requires skill and ingenuity, and especially because it produces objects of beauty. A programmer who subconsciously views himself as an artist will enjoy what he does and will do it better. Therefore we can be glad that people who lecture at computer conferences speak about the state of the Art."},{"children":[{"children":null,"tag":"literal","value":"knuth_computer_1974"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"When written within an academic and scientific context, source code tends to align with the aesthetic standards of software development, valuing reliability, reabability, sustainability, in particular through Greg Wilson's work on the development of software development principles through the Software Carpentry initiative. This alignment can also be seen in a conception of computer science as a kind of engineering, as an empirical practice which can and should still be formalized in order to become more efficient. There, one can turn to Donald Knuth's"},{"children":[{"children":null,"tag":"literal","value":"Art of Computer Programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to see the connections between the academia's standards and the industry's standards."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, a conception of computation as engineering isn't the only conception of computer science. Within a consideration of computer science as a  theoretical and abstract object of study, source code becomes a means of providing insights into more complex abstract concepts, seen in the Lisp interpreter, or one-line algorithms implementing foundational algorithms in computer science, similar to this aspect of the hacker ethos. It is this relation to a conception of beauty traditionally associated with mathematics and engineering which we will investigate further to highlight which aesthetic ideals can be ascribed to code. But, first, we complete our overview of code practitioners by turning to the software artists, who engage most directly with source code as a written material through source code poetry."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Poets"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:poets"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code poetry is a distinct subset of electronic literature, and software art. One the one hand, electronic literature is a broad field encompassing natural language texts taking full advantage of the dynamic feature of computing to redefine the concept of text, authorship and readership. It encompasses a variety of approaches, including generative literature, interactive fiction, visual poetry, source code poetry and esoteric programming languages, as well as certain aspects of software art. However, we focus here only on the elements of electronic literature which shift their focus from output to input, from executable binary with transformed natural language as a result, to static, latent source."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"On the other hand, software art is an umbrella term regrouping artistic practices which engage with the computer on a somewhat direct, material level, whether through hardware"},{"children":[{"children":null,"tag":"literal","value":"See Alexei Shuglin's"},{"children":[{"children":null,"tag":"literal","value":"386 DX"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(1998-2013)"}],"tag":"footnote","value":"56"},{"children":null,"tag":"literal","value":"or software"},{"children":[{"children":null,"tag":"literal","value":"See Netochka Nezanova's"},{"children":[{"children":null,"tag":"literal","value":"Nebula.M81"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(1999)"}],"tag":"footnote","value":"57"},{"children":null,"tag":"literal","value":". This space for artistic experimentation flourished at the dawn of the 20th century, with initiatives such as the"},{"children":[{"children":null,"tag":"literal","value":"Transmediale"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"festival's' introduction of a"},{"children":[{"children":null,"tag":"literal","value":"software art"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"award between 2001 and 2004, or the"},{"children":[{"children":null,"tag":"literal","value":"Run\\_me"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"festival, from 2002 to 2004. In both of these, the focus is on projects which incorporate standalone programmes or script-based applications which aren not merely functional tools, but also act as an effective artistic proposition, as decided by the artist, jury and public. These works often bring the normally hidden, basic materials from which digital works are made (e.g. code, circuits and data structures) into the foreground"},{"children":[{"children":null,"tag":"literal","value":"yuill_code_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Within this realm, code poetry is a form a software art whose execution is only secondary to the work's meaning."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Electronic literature, a form based on the playful"},{"children":[{"children":null,"tag":"literal","value":"détournement"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of the computer's constraints, gets closer to our topic insofar as the poems generated represent a more direct application of the rule-based paradigm to the syntactical output of the program. Starting with Christopher Stratchey's love letters (1953), generated (and signed!) by MUC, the Manchester Univac Computer, computer poems are generated by algorithmic processes, and as such rely essentially on this particular feature of programming: laying out rules in order to synthesize syntactically and semantically sound natural language poems. Here, the rules themselves matter only in relation to the output, as seen by their ratio: a single rule for a seemingly-infinite amount of outputs, with these outputs very often being the only aspect of the piece shown to the public."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These works and their authors build on a longer tradition of rule-based composition, from Hebrew to the Oulipo and John Cage's indeterministic composition, amongst others"},{"children":[{"children":null,"tag":"literal","value":"cramer_words_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a tradition in which creativity and beauty can emerge from within a strict framework of formal rules. Nonetheless, the source code to these works is rarely released in conjunction with their output, hinting again at their lesser importance in terms of their overall artistic values. If electronic literature is composed of two texts, a natural-language output and a computer-language source, only the former is actually considered to be poetry, often leaving the latter in its shadow (as well as, sometimes, its programmer, an individual sometimes different from the poet). The poem exists through the code, but isn't exclusively limited to the human-readable version of the code, as it only comes to life and can be fully appreciated, under the poet's terms, once interpreted or compiled. While much has been written on electronic literature, few of those commentaries focus on the soundness and the beauty of the source as an essential component of the work, and only in recent times have we seen the emergence of close-readings of the source of some of these works for their own sake"},{"children":[{"children":null,"tag":"literal","value":"See the publications in the field of Critical Code studies, Software studies and Platform studies."}],"tag":"footnote","value":"58"},{"children":null,"tag":"literal","value":". These constitute a body of work centered around the concept of generative aesthetics"},{"children":[{"children":null,"tag":"literal","value":"goriunova_read_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", in which beauty comes from the unpredictable and somewhat complex interplay of rule-based systems, and whose manifestations encompass not only written works, but games, visual and musical works as well."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, the approach of code poets is more specific than broad generative aesthetics: it is a matter of exploring the specific expressive affordances of source code, and the overlap of machine-meaning and human-meaning essential to the correct functioning of code which acts as a vector for artistic communication. Such an overlap of meaning is a specific feature of source code poetry. In a broad sense, code poetry conflates classical poetry (as strict syntactical and phonetical form, combined with poetic expressivity) with computer code, but it is primarily defined by the fact that it does not require the code to be executed, but only to be read by a human. Following the threads laid out by electronic literature, code poetry starts from this essential feature of computers of working with strictly defined formal rules, but departs from it in terms of utility. Code poems are only functional insofar as they are accepted by the intepreter or compiler of the language in which they are written. To the computer, they are indeed functional, in that they are legal and can be parsed; but they do not do anything of"},{"children":[{"children":null,"tag":"literal","value":"use"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Such formal compliance is only a pre-requisite, a creative constraint, for their human writers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Within this reliance on creative constraints provided by a computing environment, the emphasis here is on the act of reading, rather than on the act of deciphering, as we have seen with obfuscated code (and in functional code in general). Source code poems are often easy to read, and have an expressive power which operates beyond the common use of programming. Building on Flusser's approach, let us consider poetry as a means to bring concepts into the thinkable, and to crystallize thoughts which are not immediately available to us"},{"children":[{"children":null,"tag":"literal","value":"flusser_doubt_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"; through various linguistic techniques, poetry allows us to formulate new concepts and ideas, and to shift perspectives."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In their different manifestations, code poems make the boundary between computer meaning and human meaning thinner and thinner, a feature often afforded by the existence and use of higher-level programming languages. Starting with the development of FLOWMATIC in 1955 by Grace Hopper, it was shown that an English-like syntactical system could be used to communicate concepts for the computer to process. From there, programming languages could be described along a gradient, with binary at the lowest end, and natural language (in an overwheling majority, English) at the highest end. This implies that they could be written and read similarly to English, including word order, pronouncation and interpretation, similar to the error-tolerance of human laguages, which doesn't cause the whole communication process to fail whenever a specific word, or a word order isn't understood."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The community of programmers writing in Perl,"},{"children":[{"children":null,"tag":"literal","value":"perlmonks"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"See their website:"},{"children":[{"children":null,"tag":"literal","value":"https://perlmonks.org/"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":", with the spiritual, devoted and communal undertones that such a name implies."}],"tag":"footnote","value":"59"},{"children":null,"tag":"literal","value":"has been one of the most vibrant and productive communities when it comes to code poetry. This particular use of Perl started in 1990, when the language creator Larry Wall shared some of the poems written in the language, and it gained further exposition through the work of Shannon Hopkins"},{"children":[{"children":null,"tag":"literal","value":"hopkins_camels_1992"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The first Perl poem is considered to have been written by Wall in 1990, reproduced in"},{"children":[{"children":null,"tag":"literal","value":"code:japh_perl"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/japh.pl"}],"tag":"code","value":"perl"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Just Another Perl Hacker, japh.pl"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:japh_perl"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Hopkins analyzes the ability of the poem to enable dual understandings of the source—human and machine. Yet, departing from the previous conceptions of source that we have looked at, code poetry does not aim at expressing the same thing to the machine and to the human. The value of a good poem comes from its ability to evoke different concepts for both readers of the source code. As Hopkins puts it:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"In this poem, the q operator causes the next character (in this case a newline) to be taken as a single quote, with the next occurrence of that delimiter taken as the closing quote. Thus, the single-quoted line 'Just another Perl hacker' is printed to STDOUT. In Perl, the \"unless \\$spring\" line is mostly filler, since \\$spring is undefined. In poetical terms, however, \"\\$spring\" is very important: haiku poetry is supposed to specify (directly or indirectly) the season of the year. As for the q operator, that reads in English as the word \"queue\", which makes perfect sense in the context of the poem."},{"children":[{"children":null,"tag":"literal","value":"hopkins_camels_1992"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The poem"},{"children":[{"children":null,"tag":"literal","value":"Black Perl"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in"},{"children":[{"children":null,"tag":"literal","value":"code:black_perl"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", submitted anonymously, is another example of the richness of the productions of this community:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/black_perl.pl"}],"tag":"code","value":"perl"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"lBlack Perl, Anonymous, 1990, updated by kck, 2017"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:black_perl"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The most obvious feature of this code poem is that it can be read by anyone, including by readers with no previous programming experience: each word is valid both as English and as Perl. A second feature is the abundant use of verbs. Perl belongs to a family of programming languages grouped under the"},{"children":[{"children":null,"tag":"literal","value":"imperative"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"paradigm, which matches a grammatical mood of natural languages, the"},{"children":[{"children":null,"tag":"literal","value":"imperative mood"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Such mood emphasizes actions to be take rather than, for instance, descriptions of situations, and thus sets a clear tone for the poem. The fact that Perl is based on stating procedures to be executed and states to be changed creates this feeling of relentless urgency when reading through the poem, a constant need to be taking actions, for things to be changed. Here, the native constraints of the programming language interacts directly with the poetic suggestion of the work in a first way: the nature of Perl is that of giving orders, resulting in a poem which addresses"},{"children":[{"children":null,"tag":"literal","value":"someone"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to execute"},{"children":[{"children":null,"tag":"literal","value":"something"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Still, Perl's flexibility leaves us wondering as to who and what are concerned by these orders. Is the poem directing its words to itself? To the reader? Is Perl just ever talking exclusively to the computer? This ambiguity of the adressee adds to the ominousness of each verse."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Following in the footsteps of the"},{"children":[{"children":null,"tag":"literal","value":"perlmonks"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", additional communities around code poetry have formed, whether in university settings"},{"children":[{"children":null,"tag":"literal","value":"Such as Stanford's Code Poetry Slam, which ran between 2014 and 2016, see"},{"children":[{"children":null,"tag":"literal","value":"https://web.archive.org/web/20161024152353/http://stanford.edu/\\%7Emkagen/codepoetryslam/"}],"tag":"url","value":""}],"tag":"footnote","value":"60"},{"children":null,"tag":"literal","value":", or as independent intiatives"},{"children":[{"children":null,"tag":"literal","value":"See the Source Code Poetry event,"},{"children":[{"children":null,"tag":"literal","value":"https://www.sourcecodepoetry.com/"}],"tag":"url","value":""}],"tag":"footnote","value":"61"},{"children":null,"tag":"literal","value":". Beyond collections such as threads and hashtags on Twitter"},{"children":[{"children":null,"tag":"literal","value":"See"},{"children":[{"children":null,"tag":"literal","value":"#SongsInCode"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"at"},{"children":[{"children":null,"tag":"literal","value":"https://twitter.com/search?q=\\%2523SongsInCode"}],"tag":"url","value":""}],"tag":"footnote","value":"62"},{"children":null,"tag":"literal","value":", code poetry also features artistic publications, such as printed anthologies of code poetry in book form"},{"children":[{"children":null,"tag":"literal","value":"bertram_code_2012"}],"tag":"citation","value":""},{"children":[{"children":null,"tag":"literal","value":"holden_code_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Yet, code poems from the 20th century aren't the first time where a part of the source code is written exclusively to elicit a human reaction, without any machinic side-effects. One of the earliest of those instances is perhaps the Apollo 11 Guidance Computer (AGC) code, written in 1969"},{"children":[{"children":null,"tag":"literal","value":"Hamilton et. al., 1969, retrieved from https://github.com/chrislgarry/Apollo-11"}],"tag":"footnote","value":"63"},{"children":null,"tag":"literal","value":"in Assembly. Cultural references and jokes are peppered throughout the text as comments, asserting computer code as a means of expression beyond exclusively technical tasks"},{"children":[{"children":null,"tag":"literal","value":"See also: \"Crank that wheel\", \"Burn Baby Burn\""}],"tag":"footnote","value":"64"},{"children":null,"tag":"literal","value":", and independent from a single writer's preferences, since they passed multiple checks and review processes to end up in the final, submitted and executed document, such as reproduced in"},{"children":[{"children":null,"tag":"literal","value":"code:numero_mysterioso_asm"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/numero_mysterioso.asm"}],"tag":"code","value":"ca65"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"AGC source code for the Lunar Landing Guidance Equation, 1969"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:numero_mysterioso_asm"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Code comments allow a programmer to write in their mother tongue, rather than in the computer's, enabling more syntactic and semantic flexibility, and thus reveal a burgeoning desire for programmers to express themselves within their medium of choice."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At the turn of the 1980s, following the transition to programming from an annex practice to full-fledged discipline and profession, and with the development of more expressive programming languages (e.g. Pascal in 1970, C in 1972), software development had grown exponentially"},{"children":[{"children":null,"tag":"literal","value":"See Stackoverflow's Developer Profile survey:"},{"children":[{"children":null,"tag":"literal","value":"https://insights.stackoverflow.com/survey/2019\\#developer-profile-_-years-since-learning-to-code"}],"tag":"url","value":""}],"tag":"footnote","value":"65"},{"children":null,"tag":"literal","value":", and fostering practices, communities and development styles and patterns"},{"children":[{"children":null,"tag":"literal","value":"From Djikstra's Notes on Structured Programming to Knuth's Literate Programming and Martin's Clean Code"}],"tag":"footnote","value":"66"},{"children":null,"tag":"literal","value":". Source code becomes recognized as a text in its own, which can hold qualities and defects of its own, and to which engineering and artistic attention must be paid. No longer a transitional state from formula to binary, it becomes a semantic material, whose layout, organization and syntax are important to the eyes of its writers and readers. Pushing further into the direction of the visual layout of the code, such an endeavour becomes pursued for its own sake, equally important to the need for a program to be functional."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The Obfuscated C Code Contest"},{"children":[{"children":[{"children":null,"tag":"literal","value":"https://www.ioccc.org"}],"tag":"url","value":""}],"tag":"footnote","value":"67"},{"children":null,"tag":"literal","value":", starting in 1984, is the most popular and oldest organized production of such code, in which programmers submit code that is functional and visually meaningful beyond the exclusive standards of well-formatted code. If the source code's two meanings of a computer poem was made readily available to interpretation, and if such meanings existed in parallel in the comments of the AGC routines, pointing at the overlay of computer-related semantics (e.g. line numbers) and human-related semantics (e.g. a reference to the biblical number of the beast, 666), obfuscated code is a first foray into closely intertwining these separate meanings in the source code itself, making completely transparent, or completely opaque what the code does just by glancing at it."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/circle.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"westley.c, entry to the 1988 IOCCC"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:circle_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The source code in"},{"children":[{"children":null,"tag":"literal","value":"code:circle_c"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", submitted to the 1988 IOCCC"},{"children":[{"children":null,"tag":"literal","value":"Source:"},{"children":[{"children":null,"tag":"literal","value":"https://web.archive.org/web/20131022114748/http://www0.us.ioccc.org/1988/westley.c"}],"tag":"url","value":""}],"tag":"footnote","value":"68"},{"children":null,"tag":"literal","value":"is a procedure which does exactly what it shows: it deals with a circle. More precisely, it estimates the value of PI by computing its own circumference. While the process is far from being straightforward, relying mainly on bitwise arithmetic operations and a convoluted preprocessor definition, the result is nonetheless very intuitive—the same way that PI is intuitively related to PI. The layout of the code, carefully crafted by introducing whitespace at the necessary locations, doesn't follow any programming practice of indentation, and would probably be useless in any other context, but nonetheless represents another aspect of the"},{"children":[{"children":null,"tag":"literal","value":"concept"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"behind the procedure described, not relying on traditional programming syntax"},{"children":[{"children":null,"tag":"literal","value":"For such a program, see for instance:"},{"children":[{"children":null,"tag":"literal","value":"https://crypto.stanford.edu/pbc/notes/pi/code.html"}],"tag":"url","value":""}],"tag":"footnote","value":"69"},{"children":null,"tag":"literal","value":", but rather on an intuitive, human-specific understanding"},{"children":[{"children":null,"tag":"literal","value":"Concrete poetry also makes such a use of visual cues in traditional literary works."}],"tag":"footnote","value":"70"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Obfuscating practices, beyond their technical necessities (for security and efficiency), are traditionally tied to hacking practices, prominently with one-liners (the shorter a name, the more obscure and general it becomes). As such, they rely on the brain-teasing process of deciphering, and on the pleasurable, aesthetic experience of resolving and uniting two parallel meanings: what we see in the code, and what it does"},{"children":[{"children":null,"tag":"literal","value":"Also known informally as the \"Aha!\" moment, crucial in puzzle design."}],"tag":"footnote","value":"71"},{"children":null,"tag":"literal","value":". What we focus on here is the aspect of obfuscation which plays with the different layers of meaning: meaning to the computer, meaning to the human, and different ways of representing and communicating this meaning (from uglifying, to consistent formatting, to depicting a circle with dashes and underscores). While the aesthetics at play in hacking will be further explored below, we focus on the fact that obfuscating code practices, beyond hiding the meaning and the intent of the program, also manifest an attempt to represent such a meaning in different ways, leaving aside traditional code-writing practices and suggesting the meaning of the program by challenging the abilities of human interpretation at play in the process of deciphering programs."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Code poetry values code which, while being functional, expresses more than what it does, by allowing for"},{"children":[{"children":null,"tag":"literal","value":"Sprachspiele"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", languages games where pronounciation, syntax and semantics are playfully composed into a fluid linguistic construct in order to match a human poetic form, such as the haiku, or to constitute a specific puzzle. Relying on the inherent tendency of source code to remain opaque, obfuscated code contests let us see how far can such an opacity of a computer program's effective meaning be sustained."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In this section, we have seen how the set of individuals who write and read code is heterogeneous. Instead, we can see a significant degree of variation between source code written within the context of software engineering, hacking, scientific research and artistic activity. While none of these areas are exclusive of the others—a software developer by day can hack on the weekend and participate in code poetry events—, they do convey different perspectives on how the code is written, and on how it is evaluated. This cursory introduction to each approach has shown that, for instance, software engineers prefer code which is modular, modifiable, sustainable and understandable by the largest audience of possible contributors, while hackers would favor conciseness over expressivity, and tolerate idiosyncracy for the purpose of immediate, functional efficiency. On the other hand, scientific programming favors ease of use, accuracy and reproducibility, sometimes overlapping with software engineering, while code poets explore the semantic tension between a human interpretation and the machine interpretation of a given source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These are strands of similarity within apparent diversity. The code snippets in this section show that there is a tendency to prefer a specific group of qualities—readability, conciseness, clarity, expressivity and functionality—even though different types of the aforementionned practices would put a different emphasis on each of those aspects. The question we turn to next, then, is to what extent do these different practices of code writing and reading share common judgments regarding their formal properties? Do hackers and poets agree on some value judgment, and how? To start this investigation, we first analyze programmers' discourses in the following section in order to identify concrete categories of formal properties which might enable a source code to be positively valued for its appearance, before we turn to the aesthetic registers code practicionners refer to when discussing beautiful code to further qualifies these properties."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Ideals of beauty"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:ideals-beauty"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With this overview of the varieties of practices at play amongst those who read and write source code, we will analyze more thoroughly what are the aesthetic standards most value by those different groups. The aim here is to formalize our understanding of which source code is considered beautiful, and to do so at multiple levels. The goal here is to capture both the specific manifestations of beautiful code as specified and enunciated by programmers, as well as the semantic contexts from which these enunciations originate. What we will see is that, while a set of aesthetic values and a set of aesthetic manifestations can be pinpointed precisely, the domains that are mobilized to justify these values are clearly distinct. To do so, we will introduce a discourse analysis framework for the empirical study of the corpus, followed by an examination of the broad fields that these discourses refer to. This will be complemented in Chapter 3 by a a medium-specific reading through critical code studies and rhetorical code studies on one hand, and the work done by conceptual metaphors on the other."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Introduction to the Methodology"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:ideals-methodology"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Discourse consists of text, talk and media, which express ways of knowing the world, of experiencing and valuing the world. This study builds on Kintsch and Van Dijk's work on providing tools to analyze an instance of discourse, and is centered around what is said to constitute good source code. While discourse analysis can also be used critically by unearthing which value judgments that occur in power relationships"},{"children":[{"children":null,"tag":"literal","value":"See Diana Mullet on Critical Discourse Analysis"},{"children":[{"children":null,"tag":"literal","value":"mullet_general_2018a"}],"tag":"citation","value":""}],"tag":"footnote","value":"72"},{"children":null,"tag":"literal","value":", we focus here on aesthetic value judgments, as their are first expressed through language. Of all the different approaches to discourse, the one we focus on here is that of"},{"children":[{"children":null,"tag":"literal","value":"pragmatics"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", involving the spatio-temporal and intentional context in which the discourse is uttered. We find this approach particularly fitting through its implication of the"},{"children":[{"children":null,"tag":"literal","value":"cooperative principle"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in which utterances are ultimately related to one another through communicative cooperation to reveal the intent of the speaker"},{"children":[{"children":null,"tag":"literal","value":"schiffrin_approaches_1994"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Practically, this means that we assume the position of programmers talking to programmers is cooperative insofar as both speaker and listener want to achieve a similar goal: writing good code. This double understanding—focusing first and foremost on utterances, and then re-examining them within a broader cooperative context—will lead us to encompass a variety of production media (blog post, forums, conferences, text books), in order to depict the cultural background (software practices as outlined above as well as additional factors such as skill levels). Our comprehension of those texts, then, will be set in motion by a a dual movement between local, micro-units of meaning and broader, theoretical macro-structure of the text, and linked by acts of co-reference"},{"children":[{"children":null,"tag":"literal","value":"kintsch_model_1978"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Particular attention will be paid to the difference between intentional and extensional meaning"},{"children":[{"children":null,"tag":"literal","value":"dijk_strategies_1983"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As we will see, some of the texts in our corpus tend to address a particular problem (e.g. on forums, social media or question \\& answer platforms), or to discuss broader concepts around well-written code. Particularly,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Figures of speech may attract attention to important concepts, provide more cues for local and global coherence, suggest plausible pragmatic interpretations (e.g., a promise versus a threat), and will in general assign more structure to elements of the semantic representation, so that [meaning] retrieval is easier."},{"children":[{"children":null,"tag":"literal","value":"dijk_strategies_1983"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Following this idea, we will proceed by examining syntactic markers to deduce overarching concepts at the semantic level. Among those syntactic markers, we include single propositions as explicit predicates regarding source code, lexical fields used in those predicates in order to identify their connotations and denotations, as well as for the tone of the enunciations to identify value judgments. At the semantic level, we will examine the socio-cultural references, the"},{"children":[{"children":null,"tag":"literal","value":"a priori"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"knowledge assumed from the audience, as well as the semantic entities which compose the theme of the discourse at hand. Finally, the discourses we will examine aren't exclusively composed of natural language, but also of source code extracts, resulting in a hybrid between natural and machine syntax within the same discursive artifact."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In line with John Cayley's analytic framework of structure, syntax and vocabulary"},{"children":[{"children":null,"tag":"literal","value":"cayley_code_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", we can nonetheless echo discourse analysis as applied to natural languages. Cayley's framework highlights essential aspect of analysis which applies both to natural languages and source code: that of the scales at which aesthetic judgment operates. It also provides a bridge with literature and literary studies without imposing too rigid of a grid preventing interdisciplinarity. While it does not immediately acknowledge more traditional literary concepts such as fiction, authorship, literarity, etc., Cayley's framework does leave room for these concepts to be taken into account. Particularly, we will see that the concept of authorship—who writes to whom—will prove to be useful."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, our intepretation of the macrostructures described by Kintsch and Van Dijk will rely extensively on the work done by metaphors as the conceputal level, rather than at the strictly linguistic one. Lakoff and Johsnon's seminal work develops a theory of conceptual metaphors by highlighting their essential dependence on pre-existing cognitive structures, which we associate with already-understood concepts. The metaphor maps a source domain (made up of cognitive structure(s)) to a target domain. In the process, they extend the field of applicability of metaphors from the strictly literary to the broadly cultural: metaphors work because each of us has some conception of those domains involved in the metaphorical process. Metaphors rely in part on a static understanding, resulting in a fixed meaning from the application of a given source to a given target. Some of these sources are called"},{"children":[{"children":null,"tag":"literal","value":"schemas"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and are defined enough to not be mistaken for something else, but broad enough to allow for multiple variants of itself to be applied to various targets"},{"children":[{"children":null,"tag":"literal","value":"lakoff_metaphors_1980"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", providing both diversity and reliability. As we will see below, their approach allows us to focus not just on textual objects, but on the vast range of metaphors used specifically in computing-related environments. Given that the source of the metaphor should be grounded, with as little invariablity as possible, in order to qualify a potentially ill-defined target domain, this provides us with a first foray into the inherent elusiveness and instability of computing when presented to a broader audience."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Going beyond the role of metaphors manifested in expressions such as"},{"children":[{"children":null,"tag":"literal","value":"the desktop"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"the mouse"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", or"},{"children":[{"children":null,"tag":"literal","value":"the cloud"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", we will explore Lakoff's understanding of the specifically poetic metaphor in Chapter 3 while assessing the linguistic component of computing—source code. For now, we will pay close attention to what programmers are saying about (beautiful) source code, which metaphors they employ to support these value judgments, and why—focusing first on the metaphors"},{"children":[{"children":null,"tag":"literal","value":"of"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"source code, before moving, in the next section, to the metaphors"},{"children":[{"children":null,"tag":"literal","value":"in"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The corpus studied here consists of texts ranging from textbooks and trade manuals to blog posts and online forum discussions"},{"children":[{"children":null,"tag":"literal","value":"Specifically, we have gathered 47 different online sources, from forum discussions to blog posts, 26 journal articles from the Association for Computing Machinery, 20 monographs and 1 edited volume, listed in Appendix I. These constitute our primary sources insofar as they are written by practicioners on the topic of good and beautiful code."}],"tag":"footnote","value":"73"},{"children":null,"tag":"literal","value":". The rationale behind such a broad approach is to constitute a lexical basis for what practicing programmers consider when assessing good code, as expressed in the everyday interactions of online forums and blog posts, but also inclusive of diverse sources of communication, beyond edited volumes. From authoritative sources, such as canonical textbooks or widely-read blog posts from well-known practicioners, to more casual forum exchanges will support the empirical dimension of our research. From this approach, this section will show how there are"},{"children":[{"children":null,"tag":"literal","value":"specific"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"ways to qualify well-written code, which are echoed both from bottom-up and from top-down perspectives, and employing recurring references."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Lexical Field in Programmer Discourse"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:lexical-fields"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In terms of existing studies of the lexical field programmers use, Erik Pineiro has done significant work in his doctoral thesis. In it, he argues that aesthetics exist from a programmers perspective, decoupled from the final, executable form of the software. While this current study draws on his work, and confirms his findings, it also builds upon it in several ways. First, Pineiro focuses on a narrower corpus, that of the Slashdot.org"},{"children":[{"children":[{"children":null,"tag":"literal","value":"https://slashdot.org"}],"tag":"url","value":""}],"tag":"footnote","value":"74"},{"children":null,"tag":"literal","value":"forums"},{"children":[{"children":null,"tag":"literal","value":"pineiro_aesthetics_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"(p. 51). Second, he examines aesthetic judgment from a private perspective of software engineers, separate from other possible aesthetic fields which might enter in dialogue with beautiful code"},{"children":[{"children":null,"tag":"literal","value":"pineiro_aesthetics_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"(p.52), such as artists or hackers. Finally, his discussion of aesthetics takes place in a broader context of business management and productivity, while this current study situates itself within media studies and aesthetic philosphy, and its implications within how a certain class of communicative artefacts are considered beautiful. Still, Pineiro's work provides valuable insights in terms of identifying the manifestations and rationales for an aesthetic experience of source code. Thus, we continue his research by highlighting the main adjectives in the lexical field of programmers' discourse."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Already mentioned in Peter Naur's analysis of the practice of programming,"},{"children":[{"children":null,"tag":"literal","value":"clean"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is the first adjective which stands out as a requirement when assessing the form taken by source code. Clean code, he says, is a reference to how easy it is for readers of code to build a coherent theory of the system both described and prescribed by this source code"},{"children":[{"children":null,"tag":"literal","value":"naur_programming_1985"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This purpose of cleanliness is then completed by a description of the clean form in an analysis of clean code appears a couple of decades later in the title of a series of best-selling trade manuals written by Robert C. Martin and published by Prentice Hall from 2009 to 2021, the full titles of which clearly enunciate their normative aim"},{"children":[{"children":[{"children":null,"tag":"literal","value":"Clean Code: A Handbook of Agile Software Craftsmanship"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"The Clean Coder: A Code Of Conduct For Professional Programmers"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"Clean Architecture: A Craftsman's Guide to Software Structure and Design"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"Clean Agile: Back to Basics"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"Clean Craftsmanship: Disciplines, Standards, and Ethics"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"75"},{"children":null,"tag":"literal","value":". What exactly is cleanliness, in Martin's terms, is nonetheless defined by circumlocutions, relying on contributions from experts. After asking leading programmers what clean code means to them, he carries on in the volume by providing examples of"},{"children":[{"children":null,"tag":"literal","value":"how"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to achieve clean code, while only loosely defining what it is. In general, cleanliness is mostly a definition by negation: it states that something is clean if it is free from impurities, blemish, error, etc. An alternative to this definition which trade manuals such as"},{"children":[{"children":null,"tag":"literal","value":"Clean Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"use consists in providing examples on how to move from bad, \"dirty\" code, to clean code through specific, practical guidelines regarding naming, spacing, class delimitation, etc.. Starting at a high-level, some hints can be glimpsed from Ward Cunningham's answer:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"You know you are working on clean code when each routine you read turns out to be pretty much what you expected. You can call it beautiful code when the code also makes it look like the language was made for the problem."},{"children":[{"children":null,"tag":"literal","value":"martin_clean_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"(p.10)"}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"along with Grady Brooch's:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Clean code is simple and direct. Clean code reads like well-written prose. Clean code never obscures the designer’s intent but rather is full of crisp abstractions and straightforward lines of control."},{"children":[{"children":null,"tag":"literal","value":"martin_clean_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"(p.11)"}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Cleanliness is tied to expressiveness: it is devoid of any extraneous syntactic and semantic symbols (e.g. it does one thing, and one thing well), in order to let the problem at hand appear, with all its implications. Instead, the tool (i.e. programming languages) disappear at the syntactic level, to enable expressiveness at the semantic level."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Martin echoes Hunt when he advocates for such a definition of clean as lack of additional syntactic information:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Don't spoil a perfectly good program by over-embellishment and over-refinement."},{"children":[{"children":null,"tag":"literal","value":"hunt_pragmatic_1999"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This advice to programmers denotes a conception of clean that is not just about removing as much syntactic form as possible, but which also implies a balance."},{"children":[{"children":null,"tag":"literal","value":"Overembellishment"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"implies excess addition, while"},{"children":[{"children":null,"tag":"literal","value":"over-refinement"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"implies, on the contrary, excess removal. This normative approach finds its echo in the numerous quotations of Antoine de Saint-Exupéry's comment on aircraft design"},{"children":[{"children":null,"tag":"literal","value":"For instance, see"},{"children":[{"children":null,"tag":"literal","value":"https://news.ycombinator.com/item?id=1640594"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"https://twitter.com/codewisdom/status/1353651398337044481"}],"tag":"url","value":""}],"tag":"footnote","value":"76"},{"children":null,"tag":"literal","value":":"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Il semble que la perfection soit atteinte non quand il n'y a plus rien à ajouter, mais quand il n'y a plus rien à retrancher."},{"children":[{"children":null,"tag":"literal","value":"desaint-exupery_terre_1972"}],"tag":"citation","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"In anything at all, perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away, when a body has been stripped down to its nakedness."}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", translated by Lewis Galantière in the 1939 edition of"},{"children":[{"children":null,"tag":"literal","value":"Wind, Sand and Stars"}],"tag":"emph","value":""}],"tag":"footnote","value":"77"}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This balance between too much and too little is found in another dichotomy stated by programmers: between simple and clever. Simplicity, argues Jeremy Gibbons, is not only a restraint on the quantity of syntactic tokens (as one could achieve by keeping names short, or aligning indentations), but also a semantic equilibrium at the level of abstracted ideas"},{"children":[{"children":null,"tag":"literal","value":"gibbons_beauty_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The balance between breadth and depth regarding the task of the code, between the precision of a use-case and its generalization, and its leveraging of external—i.e. supposedly reliable—code is summed up his quoting of Ralph Waldo Emerson at the conclusion of his column:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"We ascribe beauty to that which is simple; which has no superfluous parts; which exactly answers its end; which stands related to all things; which is the mean of many extremes."},{"children":[{"children":null,"tag":"literal","value":"gibbons_beauty_2012"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In another ACM publication, Kristiina Karvonen argues for simplicity not just as a design goal, as leveraged by human-computer interface designers, but as a term with a longer history within the tradition of aesthetic philosophy, especially the work of Johann Joachim Winckelmann"},{"children":[{"children":null,"tag":"literal","value":"karvonen_beauty_2000"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In particular, she stresses the difficulty \"to create significant, that is, beautiful works of art with simple means\""},{"children":[{"children":null,"tag":"literal","value":"karvonen_beauty_2000"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Here, her correlation between"},{"children":[{"children":null,"tag":"literal","value":"significance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"pleasant appearance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"hints at the semantic role of simplicity, as a means to communicate ideas (i.e. to"},{"children":[{"children":null,"tag":"literal","value":"signify"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":") to an audience."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Precisely, simplicity is correlated with clarity (of meaning); if the former refers mainly to the syntactic component (fewer tokens), it enables the non-obfuscated framing of the ideas at play. One example is given in"},{"children":[{"children":null,"tag":"literal","value":"code:clearer_method_c"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"by Dave Bush in a post titled"},{"children":[{"children":null,"tag":"literal","value":"15 Ways to Write Beautiful Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/clearer_method.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Example of clarity differences between two methods."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:clearer_method_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Here, the strive for simplicity leads to removing the brackets, and flipping the boolean check in the if-statement to add a"},{"children":[{"children":null,"tag":"literal","value":"return"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":". Even though it is, strictly speaking, more characters than the brackets and newline (six characters compared to four), the program becomes cleaner, and thus clearer, he argues, by separating the two branching cases inherent to the use of conditional logic, under the form of an if-statement. In the second version, it is made clear that, if a condition"},{"children":[{"children":null,"tag":"literal","value":"is"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the execution should stop, and any subsequent statement can entirely disregard the existence of the if-statement; in the first version, the condition that"},{"children":[{"children":null,"tag":"literal","value":"is not"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is entangled with code that should be executed, since the existence of the if-statement has to be kept in mind until the closing bracket"},{"children":[{"children":null,"tag":"literal","value":"bush_15_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As a corollary to clarity stands obfuscation. It is the act, either intentional or un-intentional, to complicate the understanding of what a program does by leading the reader astray through a combination of syntactic techniques, a process we have already seen in the works of the IOCCC above. In its most widely applied sense, obfuscation is used for practical production purposes: reducing the size of code, and preventing the leak of proprietary information regarding how a system behaves. For instance, the JavaScript source code in"},{"children":[{"children":null,"tag":"literal","value":"code:home_js"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"is obfuscated through a process called"},{"children":[{"children":null,"tag":"literal","value":"minification"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"into the source code in"},{"children":[{"children":null,"tag":"literal","value":"code:home_minified_js"}],"tag":"reference","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/home.js"}],"tag":"code","value":"js"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"home.js (before minification)"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:home_js"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/home_minified.js"}],"tag":"code","value":"js"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"home.js (after minification)"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:home_minified_js"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This process of obfuscation has very clear, quantitative assessment criterias, such as the size of the source code file and cryptographic complexity"},{"children":[{"children":null,"tag":"literal","value":"pellet-mary_co6gc_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Nonetheless. obfuscation can also be valued as a positive aesthetic standard, of which the IOCCC is the most institutionalized guarantor. These kinds of obfuscations, as Mateas and Montfort analyze, involve the playful exploration of the intertwinings of syntax and semantics, seeing how much one can bend the former without affecting the latter. These textual manipulations, they argue, possess an inherently literary quality:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Obfuscation and weird languages invite us to join programming contexts to the literary contexts that must obviously be considered when evaluating literary code. They also suggest that coding can resist clarity and elegance to strive instead for complexity, can make the familiar unfamiliar, and can wrestle with the language in which it is written, just as much contemporary literature does."},{"children":[{"children":null,"tag":"literal","value":"mateas_box_2005"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Such literary connection can also be seen in Noël Arnaud's work"},{"children":[{"children":null,"tag":"literal","value":"Poèmes Algol"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"arnaud_poemes_1968"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", in which he uses the constructs of the language Algol 68 in order to evoke in the reader something different than what the program actually does (i.e. fail to execute anything meaningful). Here, obfuscation is can be considered a literary value, as opposed to other domains, such as the scientific or the architectural, where it is both considered exclusively negatively."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another insight on simplicity and programming regarding the communication of ideas is hinted at by Richard P. Gabriel in his use of the concept of"},{"children":[{"children":null,"tag":"literal","value":"compression"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in both poetry and programming, there is a desire to increase the semantic charge (or significance, in Karvonen's terms) all the while reducing the syntactic load (or the quantitity of formal tokens). One of those extraneous loads is explanation, as pointed out online by user Mason Wheeler:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"When it requires a lot of explanation like that, it's not \"beautiful code,\" but \"a clever hack.\""},{"children":[{"children":null,"tag":"literal","value":"stackoverflow_how_2013"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This answer, posted on the software engineering"},{"children":[{"children":null,"tag":"literal","value":"Stack Exchange"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"forum, in response to the question \"How can you explain \"beautiful code\" to a non-programmer?\""},{"children":[{"children":null,"tag":"literal","value":"stackoverflow_how_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", not only highlights the need to be self-explanatory, but also points at a quality departing form simplicity—cleverness."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Cleverness is often found, and sometimes derided, in examples of code written by hackers, since it unsettles this balance between precision and generality. Clever code would tend towards exploiting particularities of knowledge of the medium (the code) rather than the goal (the problem). Hillel Wayne presents the snippet of Python code in"},{"children":[{"children":null,"tag":"literal","value":"code:is_unique_python"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"as an example of bad clever code:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/unique.py"}],"tag":"code","value":"python"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Method to check for the uniqueness of array elements"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:is_unique_python"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Here, the knowledge of how the"},{"children":[{"children":null,"tag":"literal","value":"set()"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"function in Python behaves, is required in order to understand that the"},{"children":[{"children":null,"tag":"literal","value":"is_unique()"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"function returns whether all the elements of the given list are unique. A programmer without familiarity with Python would be unable to do so without consulting the Python documentation (i.e. requiring extraneous explanation)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Hillel elaborates on the difference between \"bad\" clever code"},{"children":[{"children":null,"tag":"literal","value":"See, for instance, Duff's device, an idiosyncratic and language-specific way to speed up loop unrolling in C. The author himself feels \"a combination of pride and revulsion at this discovery\""},{"children":[{"children":null,"tag":"literal","value":"duff_tom_1983"}],"tag":"citation","value":""}],"tag":"footnote","value":"78"},{"children":null,"tag":"literal","value":", which is essentiall read-only due to its idiosyncracy and reliance on tacit knowledge, and \"good\" clever code, and such distinction corroborates our previous observations regarding beautiful code as a means for expression of the problem domain. His example is that the problem of sorting the roughly 300 million U.S. american citizens by birthdate can be made considerably more efficient by cleverly considering that no U.S. american citizen is older than 120 years, whereby radically reducing the computation space."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Meanwhile, cleverness is a valued attribute in the context of hacker code, putting more emphasis on the technical solution than on the problem domain, as we have seen above. A salient is example was the 1994"},{"children":[{"children":null,"tag":"literal","value":"smr.c"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"entry to the IOCCC, which aimed at being the smallest self-reproducing program"},{"children":[{"children":null,"tag":"literal","value":"kanakarakis_international_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". An exact reproduction of the source code can be found in"},{"children":[{"children":null,"tag":"literal","value":"code:smr_c"}],"tag":"reference","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/smr.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"smr.c"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:smr_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Consisting of a file weighing zero bytes,"},{"children":[{"children":null,"tag":"literal","value":"smr.c"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"provides both a clever reduction of the problem domain, and a clever understanding of what C compilers would effectively accept or not as a valid program text"},{"children":[{"children":null,"tag":"literal","value":"kanakarakis_international_2022a"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Because it has since been banned under the rules of the IOCCC, this source code entirely renounces any claim to a more general application, and finds its aesthetic value only within a specific community."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Coming back to simplicity, we can define more precisely such a qualifier of source code to be"},{"children":[{"children":null,"tag":"literal","value":"an exact fit to the problem"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":": without being too precise, or too generic, displaying an understanding of and a focus on the application domain, rather than the applied tools. William J. Mitchell sums it up in his introductory textbook for graphics programming:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Complex statements have a zen-like reverence for perfect simplicity of expression."},{"children":[{"children":null,"tag":"literal","value":"mitchell_art_1987"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Programmers hold the idea of reaching a conceptual revelation through the reduction of complex styntactical assemblages. This strive towards attaining an inverse relationship between the complexity of an idea and the means to express it is contiguous to another related criteria for beautiful source code present in programmers' discourse:"},{"children":[{"children":null,"tag":"literal","value":"elegance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Leslie Valiant, recipient of the Turing Award in 2010, considers elegance as the explanatory power of simple principles, which might only appear"},{"children":[{"children":null,"tag":"literal","value":"a posteriori"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"—a solution can only be qualified as elegant once it has been found, and very rarely during the process of its development"},{"children":[{"children":null,"tag":"literal","value":"anthes_beauty_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Chad Perrin, in his article"},{"children":[{"children":null,"tag":"literal","value":"ITLOG Import: Elegance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", first approaches the concept as a negation of the gratuitous, a means to reduce as much as possible the syntactic footprint while keeping the conceptual footprint intact:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"In pursuing elegance, it is more important to be concise than merely brief. In a general sense, however, brevity of code does account for a decent quick and dirty measure of the potential elegance that can be eked out of a programming language, with length measured in number of distinct syntactic elements rather than the number of bytes of code: don't confuse the number of keystrokes in a variable assignment with the syntactic elements required to accomplish a variable assignment."},{"children":[{"children":null,"tag":"literal","value":"perrin_itlog_2006"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Perrin also hints at the additional meaningfulness of elegance, as he compares it to other aesthetic properties, such as simplicity, complexity or symmetry. If simplicity inhabits a range between too specific and too general, he describes an elegant system as exactly appropriate for the task at hand, echoing others' definition of clean or simple source code. Elegance, he says, relies on strong, underlying principles, but is nonetheless subject to its manifestation through a particular, linguistic interface. While he touches at length on the influence of progamming languages in the possibility to write elegant source code, we will only address this question in Chapter 4."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Donald Knuth adds another component required to achieve elegance in software: along with leanness of code and the suitability of the language, he adds that elegance necessitates a clear definition of the problem domain"},{"children":[{"children":null,"tag":"literal","value":"fuller_software_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Along with the appropriateness of the linguistic tooling, one can see here that the representation of the data which is then going to be processed by the executed source code also matters. Indeed, source code is not only about expressing dynamic processes, but also about translating the problem domain into formal static representations which will then be easy to operate on."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This aspect of implying underlying principles is also present in Bruce McLennan's discussion of the concept. As he approaches it through the dual lens of structural engineering, this indicates that he also considers elegance as a more profound concept which can manifest itself across disciplines, both as a way of making, and as a way of thinking"},{"children":[{"children":null,"tag":"literal","value":"mclennan_who_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". He defines his"},{"children":[{"children":null,"tag":"literal","value":"Elegance Principle"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"as:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Confine your attention to designs that"},{"children":[{"children":null,"tag":"literal","value":"look"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"good because they"},{"children":[{"children":null,"tag":"literal","value":"are"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"good."},{"children":[{"children":null,"tag":"literal","value":"mclennan_who_1997"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Such a definition relies heavily on the sensual component of elegance: while an underlying property of, at least, human activities, it must nonetheless be manifested in some perceptible way. On"},{"children":[{"children":null,"tag":"literal","value":"Stackexchange"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", user"},{"children":[{"children":null,"tag":"literal","value":"asoundmove"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"corroborates this conception of achieving a simple and clean system where any subsequent modification would lead to a decrease in quality:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"However to me beautiful code must not only be necessary, sufficient and self-explanatory, but it must also subjectively feel perfect \\& light."},{"children":[{"children":null,"tag":"literal","value":"stackoverflow_how_2013"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Once again connecting simplicity (under the guise of necessity and sufficiency), the perception of elegance is also related to a subjective feeling of adequacy, of fitting. Including some of the definitions of simplicity we have seen so far, Paul DiLascia, writing in the Microsoft Developer Network Magazine, illustrates his conception of elegance—as a combination of simplicity, efficiency and brilliance—with recursion"},{"children":[{"children":null,"tag":"literal","value":"dilascia_end_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", as seen in"},{"children":[{"children":null,"tag":"literal","value":"code:factorial_c"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/factorial.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Use of recursivity in the computation of a factorial"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:factorial_c"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Recursion, or the technique of defining something in terms of itself, is a positively valued feature of programming"},{"children":[{"children":null,"tag":"literal","value":"abelson_structure_1979"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", which we have seen an example of in"},{"children":[{"children":null,"tag":"literal","value":"code:scheme_interpreter"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":". In so doing, it minimizes the number of elements at play and constrains the problem domain into a smaller set of moveable pieces. Another example, provided in the same"},{"children":[{"children":null,"tag":"literal","value":"Stackexchange"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"discussion is the"},{"children":[{"children":null,"tag":"literal","value":"quicksort"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"algorithm, which can be implemented recursively or iteratively, with the former being significantly shorter (see"},{"children":[{"children":null,"tag":"literal","value":"code:recursion_iteration_csharp"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":")"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/recursive_iteration.cs"}],"tag":"code","value":"csharp"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Comparison two functions, one using recursion, the other one using iteration, https://stackoverflow.com/a/12553314/4665412"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:recursion_iteration_csharp"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Concluding this survey of how programmers perceive, define and exemplify elegance in source code, we can follow Mahmoud Efatmaneshik and Michael J. Ryan who, in the IEEE Systems journal, offer a definition of elegance which relies both on a romantic perception—including subjective perception, \"gracefulness\", \"appropriateness\" and \"usability\"—and practical assessment with terms such as \"simple\", \"neat\", \"parsimonious\" or \"efficient\""},{"children":[{"children":null,"tag":"literal","value":"efatmaneshnik_definitions_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In doing so, they ground source code aesthetics as a resolutely dualistic norm, between subjectivity and objectivity, qualitative and quantitative"},{"children":[{"children":null,"tag":"literal","value":"A duality we will investigate further through the prism of human and machine understanding in Chapter 2"}],"tag":"footnote","value":"79"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, rather than subjectivity and objectivity being opposites, one could also consider them as contingent. Due to the interchangeability in the use of the some of the terms we have seen by programmers, both qualitative—in terms of the language used—and quantitative—in terms of the syntax/semantics ratio—assessments of source seem to be complementary in considering it elegant. If"},{"children":[{"children":null,"tag":"literal","value":"clean"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"simple"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"elegant"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"seem to overlap, it is because they all seem to point at this maximization of meaning while appropriately minimizing syntax."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A complementary approach to understand what programmers mean when they talk about beautiful code is to look beyond the positive terms used to qualify it, and shift our attention to how other terms are used negatively. We have already touched upon qualifiers such as clever, or obfuscated, which have ambiguous statuses depending on the community that they're being used in—specifically hackers and literary artists. Further examination of negative qualifiers will enrich of understanding of what constitutes good code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"One of those hints comes from satirical accounts of how to write bad code. For instance, Green's post on"},{"children":[{"children":null,"tag":"literal","value":"How To Write Unmaintainable Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"suggests new kinds of obfuscation, such as double-naming in"},{"children":[{"children":null,"tag":"literal","value":"code:green_unmaintainable"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"or semantic interactions in"},{"children":[{"children":null,"tag":"literal","value":"code:green_unmaintainable_2"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":". The core ideas presented here revolve around creating as much friction to understanding as possible, by making it \"as hard as possible for [the reader] to find the code he is looking for\" and \"as awkward as possible for [the reader] to safely ignore anything.\""},{"children":[{"children":null,"tag":"literal","value":"green_how_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/unmaintainable.py"}],"tag":"code","value":"python"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Choose variable names that masquerade as mathematical operators"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:green_unmaintainable"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/unmaintainable_2.c"}],"tag":"code","value":"c"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Code That Masquerades As Comments and Vice Versa"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:green_unmaintainable_2"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"By looking at it from the opposite perspective of highly-confusing code, we see best how carefully chosen aesthetics, under the values of simplicity, clarity, cleanliness and elegance intend first and foremost to help alleviate human cognitive friction and facilitate understanding of what the program is doing. The opposite amounts to playing misleading tricks."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Along with this mental property, programmers have another way to refer to code that does not meet aesthetic criteria, which is also relates primarily to a non-cognitive aspect of source code, by refferring to material properties."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Spaghetti code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"refers to a property of source code where the syntax is written in such a way that the order of reading and understanding is akin to disentangling a plate of spaghetti pasta. While still linear in execution, this linearity loses its cognitive benefits due to its extreme convolution, making it unclear what starts and ends where, both in the declaration and the execution of source code. Rather than using a synonym such as"},{"children":[{"children":null,"tag":"literal","value":"convoluted"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the image evoked by spaghetti is particularly vivid on a sensual level, as a slimy, vaguely structured mass, even if the actual processes at play remain eminently formal"},{"children":[{"children":null,"tag":"literal","value":"steele_macaroni_1977"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Such a material metaphor can also be in Foote and Yoder's description of code as a \"big ball of mud\":"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated."},{"children":[{"children":null,"tag":"literal","value":"foote_big_1997"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A broader approach to these sensual perceptions of code involve the reference to"},{"children":[{"children":null,"tag":"literal","value":"code smells"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". These smells are described by Martin Fowler as \"surface indications that usually corresponds to a deeper problem in the system\""},{"children":[{"children":null,"tag":"literal","value":"fowler_refactoring_1999"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". They are aspects of source code which, by their syntax, might indicate deeper semantic problems, without being actual bugs. The name code smell evokes the fact that their recognition happens through intuition and experience of the programmer reading the code, rather than through careful empirical analysis"},{"children":[{"children":null,"tag":"literal","value":"It should be noted that more recent computer science research has recently also focused on developing such empirical techniques"},{"children":[{"children":null,"tag":"literal","value":"rasool_review_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", even though their practical usefulness is still debated"},{"children":[{"children":null,"tag":"literal","value":"santos_systematic_2018"}],"tag":"citation","value":""}],"tag":"footnote","value":"80"},{"children":null,"tag":"literal","value":". This points to a practice-based value system to evaluate the quality of source code, rather than to an evidence-based system, itself circling back to the qualifications of elegance discussed above, evaluated both as quantitative metric and as qualitative one."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In this section, we clarified the main terms used in programmers' discourse when discussing aesthetically pleasant code. Basing our interpretation of the gathered sources through discourse analysis, we specifically assumed a cooperative principle, in which all participants in the discourse intend to achieve writing the best source code possible. This analysis has confirmed and updated the findings of Piñeiro's earlier study. Across textbooks, blog posts, forums posts and trade books, the aesthetic properties of code are widely acknowledged and, to a certain extent, consistent in the adjectives used to qualify it (clean, elegant, simple, clear, but also clever, obscure, or dirty)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While there is a consistency in describing the means of beautiful code, by examining a lexical field with clear identifiers, this analysis also opens up additional pathways for inquiry. First, we see that there is a relationship between formal manifestations and cognitive burden, insofar as aesthetics help alleviate such a burden. Beautiful code makes the ideas which are embedded in it, and the world in which the code aims to translate and operate on, more accessible to the reader. Additionally, the negative adjectives mentioned when referring to the formal aspects of code (smelly, muddy, entangled) are eminently"},{"children":[{"children":null,"tag":"literal","value":"materialistic"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", indicating some interesting tension between the ideas of code, and the sensuality of its manifestation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Moving beyond strict lexical tokens, we have seen in the breadth of responses in a programmer's question of \"How can you explain \"beautiful code\" to a non-programmer?\""},{"children":[{"children":null,"tag":"literal","value":"stackoverflow_how_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", programmers also rely multiple aesthetic domains to which they refer: from engineering and literature to architecture and mathematics. We now turn to an investigation of each of these domains, and of how they can be related to code."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Aesthetic domains"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-domains"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This examination of which qualifiers programmers use when they relate to the aesthetic qualities  of source code (the way it looks) or the aesthetic experience that it elicits (the way they feel) has shown both a certain degree of coherence, and a certain degree of elusiveness. Subjectively, programmers associate their experience of encountering well-written code as an aesthetic one. However, on a normative level, things become a little more complicated to define: as we have seen in the previous section's discussion of forum exchanges, beauty in source code is not and explicited in and of itself, but is best illustrated by referring to to other domains."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The next step that we propose is to inquire into these specific domains, to examine in which capacity they are being summoned in relation to code, and how they help us further delineate the aesthetic qualities which belong to source code. The assumption here is that, following Neil Postman, a medium is a means of expression, and different mediums can support different qualities of expression"},{"children":[{"children":null,"tag":"literal","value":"postman_amusing_1985"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Since there seems to be some specific ways in which code can be considered beautiful, these contingent domains, and the specific parts of these domains which create this contingency, will prepare our work of defining source code-specific aesthetic standards."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"To do so, then, we will look at the three domains most often conjured by programmers when they mention the sensual qualities of, or the aesthetic experiences elicited by, source code: literature, mathematics and architecture. While there are accounts of parallels between programming and painting"},{"children":[{"children":null,"tag":"literal","value":"graham_hackers_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"or programming and music"},{"children":[{"children":null,"tag":"literal","value":"mclean_hacking_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", these refer rather to the painter or musician as an individual, rather to the specific medium, and there are, to the best of our knowledge, no account of code being like sculpture or film, for instance."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Literary Beauty"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:literary-beauty"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The most striking, and obvious similarity between code and another medium of expression is that of literature: perhaps because they both require, fundamentally, the use of alphanumeric characters laid out on a two-dimensional plane. Similarly, syntax and semantics interplay in order to convey meaning to a reader."},{"children":[{"children":null,"tag":"literal","value":"Code as literature"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", then, focuses on this intertwining of natural language and computer language, on its narrative, rhetorical and informative properties, and even on its ability to mimick the traditional forms of poetry."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Code as a linguistic practice"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:code-linguistic"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In"},{"children":[{"children":null,"tag":"literal","value":"Geek Sublime"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Vikram Chandra, novelist and programmer, lays out the deep parallels he sees between code and human language, specifically sanskrit. While stopping short of claiming that code is literature, he nonetheless makes the claim that sanskrit is, as a set of generative linguistic rules to compose meaning, a distant ancestor to computer code"},{"children":[{"children":null,"tag":"literal","value":"chandra_geek_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a fact corroborated by Agathe Keller in her studies of the Āryabhaṭa"},{"children":[{"children":null,"tag":"literal","value":"keller_textes_2021"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Sanskrit, like computer code, relies on context-free rules and exhibits similar properties as in code, such as recursion and inheritance."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With a similar syntactic structure between sanskrit and code, the former also exhibits a \""},{"children":[{"children":null,"tag":"literal","value":"search for clear, unambiguous understanding"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" through careful study, a goal equally shared by the writers of source code, as we have seen above. Specifically, the complexity of the linguistic system presented both in sanskrit and in machine language implies that enjoyment of works in either medium happens not through spontaneous, subjective appreciation, but through \"conoisseurship\", resulting from education, experience and temperament"},{"children":[{"children":null,"tag":"literal","value":"chandra_geek_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Similarly, in"},{"children":[{"children":null,"tag":"literal","value":"Words Made Flesh: Code and Cultural Imagination"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Florian Cramer touches upon code's ability to"},{"children":[{"children":null,"tag":"literal","value":"do"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"things, in order to inscribe it differently in a historical development of linguistics, connecting it to the symbolical works of the kabbalah and Lebniz's"},{"children":[{"children":null,"tag":"literal","value":"Ars Combinatoria"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Code, according to Cramer, is linguistic, not just because it is made up of words, but because it"},{"children":[{"children":null,"tag":"literal","value":"acts upon"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"words, influencing what we consider literature and human-language writing:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The step from writing to action is no longer metaphorical, as it would be with a semantic text such as a political speech or a manifesto. It is concrete and physical because the very code is thought to materially contain its own activation; as permutations, recursions or viral infections."},{"children":[{"children":null,"tag":"literal","value":"cramer_words_2003"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Those permutations and recursions are used in the different ways: natural language writers have attempted to apply formulas, or algorithms, to their works, from the Oulipo's"},{"children":[{"children":null,"tag":"literal","value":"Poèmes Algol"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to Cornelia Sollfrank's"},{"children":[{"children":null,"tag":"literal","value":"Net.Art Generator"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". The properties that Cramer identifies in machine languages, tensions between totality and fragmentation, rationalization and occultism, hardware and software, syntax and semantics, artificial and natural, are ascribed to the newest development of the interaction between program and expression, for instance through the shape of those combinatorial poetics"},{"children":[{"children":null,"tag":"literal","value":"cramer_words_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This resemblance, or"},{"children":[{"children":null,"tag":"literal","value":"Familienähnlichkeit"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", to other forms of linguistic expression, is explored further by Katherine Hayles' work on speech, writing and code. Specifically, she sees the linguistic practices of humans and intelligence machines as influencing and interpenetrating each other, considering code as language's partner"},{"children":[{"children":null,"tag":"literal","value":"Hayles's work on posthumanism should be acknowledged here, as she envisions the human brain as a platform on which code runs, both natural codes such as sanskrit, or more computational forms of codes."}],"tag":"footnote","value":"81"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Specifically, Hayles looks at how both literature and code can be expressive in a syntagmatic manner as well as in a paradigmatic manner. In the former, the meaning spread across the words of a sentence is considered fixed in literature, while it is dynamically generated in source code, depending of the execution state and the problem domain. In the latter, the meaning across synonyms in a (program) text is always potential in literature, but always present in code"},{"children":[{"children":null,"tag":"literal","value":"hayles_print_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"—highlighting different levels of interpretation. If code is a form of linguistic system, then it is a dynamic one in which the semantic charge is at least as volatile as in literature, but which possesses an additional"},{"children":[{"children":null,"tag":"literal","value":"dimension"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", as orality, literacy and digitality succeed each other by bringing the specificity of their media."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Code is thus considered a linguistic system in the technical sense, having a syntactic ruleset operating on words, it seems to also be a linguistic system in the cultural sense. As such, it deals with the occult, the magical and the obscure, but also exhibits a desire to communicate and execute unambiguous meaning."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This desire for explicit communication led literacy scholars to investigate source code's relationship to rhetoric. While digital systems seem to exhibit persuasive means of their own"},{"children":[{"children":null,"tag":"literal","value":"bogost_rhetoric_2008"}],"tag":"citation","value":""},{"children":[{"children":null,"tag":"literal","value":"frasca_simulation_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", the code that underpins them also presents rhetorical affordances. The work of Kevin Brock and Annette Vee in this domain has shown that source code isn't just a normative discourse to the machine, but also an argumentative one with respect to the audience: it tries to persuade fellow programmers of what it is doing. From points being made in large-scale software such as Mozilla's Firefox web browser, to more specific styles in job interviews, source code presents worldviews in its own specific syntax"},{"children":[{"children":null,"tag":"literal","value":"brock_rhetorical_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The connections of code to linguistics happens thus at the technical, media, and cultural levels, insofar as it can allow for the expression of ideas and arguments, straddling the line between the rational and the evocative. We now turn more specifically to two instances of program code being considered a literary text, by leading programmers in the field: Yukihiro 'Matz' Matsumoto and Donald Knuth."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Code as text"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:code-text"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Perhaps the most famous reference to code as a literary object is to be found in Donald Knuth's"},{"children":[{"children":null,"tag":"literal","value":"literate programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In his eponymous 1984 article in"},{"children":[{"children":null,"tag":"literal","value":"The Computer Journal"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Knuth advocates for a practice of programming in which a tight coupling of documentation with source code can allow one to consider programs as \"works of literature\""},{"children":[{"children":null,"tag":"literal","value":"knuth_literate_1984"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". It is unclear, however, what Knuth entails when he refers to a work of literature"},{"children":[{"children":null,"tag":"literal","value":"For instance, he refers in the rest of the article as \"constructing\" programs, rather than \"writing\" them."}],"tag":"footnote","value":"82"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Literate programming, a direct response to"},{"children":[{"children":null,"tag":"literal","value":"structured programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", enables the weaving of natural language blocks with machine language blocks, in order to be able to comile a single source into either a typeset documentation of the program, using the TeX engine"},{"children":[{"children":null,"tag":"literal","value":"In which this current thesis is written."}],"tag":"footnote","value":"83"},{"children":null,"tag":"literal","value":", or into a source file for a Pascal compiler. The literary, here, is only a new set of tools and practices of writing which result in a"},{"children":[{"children":null,"tag":"literal","value":"publishable work"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", rather than a"},{"children":[{"children":null,"tag":"literal","value":"literary work"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in which the program is described in natural language, with source code being interspersed as snippets throughout. While this approach fits aptly within Knuth's interest in typesetting and workflows of scientific publications, it does not explicitly address the relationship between literature and programming beyond this."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Still, his aim remains to support a clear understanding of a program by its reader, particularly emphasizing the complexity of such tasks. If he proposes something with regards to literature, it is in the process of meaning-making through reading, and its cognitive implications:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"This feature of WEB is perhaps its greatest asset; it makes a WEB-written program much more readable than the same program written purely in PASCAL, even if the latter program is well commented.  [...] a programmer can now view a large program as a web, to be explored in a psychologically correct order is perhaps the greatest lesson I have learned from my recent experiences."},{"children":[{"children":null,"tag":"literal","value":"knuth_literate_1984"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"For Knuth, then, code is a text: both in the traditional, publisher-friendly way, but also in a new, non-linear way. This attention to the materiality of the program—layout, typesetting—foresees subsequent technological solutions to allow natural language and machine language to co-exist"},{"children":[{"children":null,"tag":"literal","value":"See JavaDocs, Go docs, Jupyter Notebooks"}],"tag":"footnote","value":"84"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This new way to approach (digital, hybrid) texts is expressed by Yukihiro Matsumoto, the creator of the Ruby programming language, in his notion of"},{"children":[{"children":null,"tag":"literal","value":"Code as an Essay"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"oram_beautiful_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". While he doesn't deal directly with questions of eloquence and rhetoric, as opposed to Brock and Vee, it does however start from the premise that code is a kind of text, insofar as it has an a message being conveyed in a written form to an audience. However, it is not a kind of text which has a specific author, or a specific finite state:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Most programs are not write-once. They are reworked and rewritten again and again in their lived. Bugs must be debugged. Changing requirements and the need for increased functionality mean the program itself may be modified on an ongoing basis. During this process, human beings must be able to read and understand the original code."}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This conception, in which a text remains open to being modified further by subsequent voices, thus minimizing the aura of the original version, and possibly diluting the intent of the original author, echoes the distinction made by Roland Barthes between a"},{"children":[{"children":null,"tag":"literal","value":"text lisible"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(readerly text) and"},{"children":[{"children":null,"tag":"literal","value":"texte scriptible"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(writerly text). While the former aligns with classical conceptions of literature, with a clear author and life span for the literary work, the latter remains open to subsequent, subjective appropriations."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This appropriation is such that a modified program text does not result in a finite program text either; due to its very low barrier to modification and diffusion, program texts can act almost as a dialogue between two programmers. As Jesse Li puts it, building the linguistic theory of Volonishov and Bakhtin:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The malware author is in dialogue with the malware analyst. The software engineer is in dialogue with their teammates. The user of a piece of software is in dialogue with its creator. A web application is in dialogue with the language and framework it is written in, and its structure is mediated by the characteristics of TCP/IP and HTTP. And in the physical act of writing code, we are in dialogue with our computer and development environment."},{"children":[{"children":null,"tag":"literal","value":"li_where_2020"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"It is to support this act of dialogue, supported by code's affordance of rapid modification and redistribution, that Matusmoto highlights simplicity, brevity—his term for elegance— and balance—insofar as no one dimension alone is enough—as means to achieve writing beautiful code. His last criteria, lightness, applies not to the code being written, but to the language being used to write such code, adding one more dimension to the dialogue: between the writer(s), the reader(s) and the language designer(s), an additional aspect we will return to in chapter 3."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These two examples show us that source code can be considered a text, if not a literary work which needs to accomodate a hybrid of natural and machine languages, new modes of diffusion, and countless possibilities for being rewritten. In this technological environment of programming languages (from WEB to Ruby), the aim is to facilitate the understanding of what the program does, and of what it should do."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Beyond these theoretical and functional conceptions of code's textuality, a last approach to the literariness of source code can be found in the works of code poetry, in which this ambiguity is embraced."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Code poetry"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:code-poetry"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Daniel Temkin, in his"},{"children":[{"children":null,"tag":"literal","value":"Sentences of Code Art"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"A direct reference to Sol Lewitt's"},{"children":[{"children":null,"tag":"literal","value":"Sentences on Conceptual Art"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"85"},{"children":null,"tag":"literal","value":", suggests the ways in which code art (encompassing code poetry, esoteric languages and obfuscated code, among others) touches on code's linguistic features mentioned by Chandra and Cramer, while coming at it from a non-functional perspective, radically opposed to Knuth and Matsumoto."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The ambiguity of human language is present in code, which never fully escapes its status as human writing, even when machine-generated. We bring to code our excesses of language, and an ambiguity of semantics, as discerned by the human reader."},{"children":[{"children":null,"tag":"literal","value":"temkin_sentences_2017"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The artists whose main medium is source code explore the possibilities of meaning-making through mechanisms usually associated with poetry. For instance, code art is focused on the evokative possibilities of machine languages, and away from its exactness. This is a step further in a direction of semantic possibilities hinted at by Richard P. Gabriel when he mentions the parallels between writing code and writing poetry. In an interview with Janice J. Jeiss, he states:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"I'm thinking about things like simplicity -- how easy is it going to be for someone to look at it later? How well is it fulfilling the overall design that I have in mind? How well does it fit into the architecture? If I were writing a very long poem with many parts, I would be thinking, \"Okay, how does this piece fit in with the other pieces? How is it part of the bigger picture?\". When coding, I'm doing similar things, and if you look at the source code of extremely talented programmers, there's beauty in it. There's a lot of attention to compression, using the underlying programming language in a way that's easy to penetrate. Yes, writing code and writing poetry are similar."},{"children":[{"children":null,"tag":"literal","value":"jeiss_poetry_2002"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Further exploring the semantic possibilities of considering source code as a possible medium for poetic expression, one can turn to the analyses of code poems in publications such as Ishaac Bertram's edited volume,"},{"children":[{"children":null,"tag":"literal","value":"code \\{poems\\}"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and Nick Montfort's collected poems in"},{"children":[{"children":null,"tag":"literal","value":"\\#!"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the former's foreword, Jamie Allen develops further this ability to express oneself via machine languages, considering that programmers can have \""},{"children":[{"children":null,"tag":"literal","value":"passionate conversations in Python"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" or \""},{"children":[{"children":null,"tag":"literal","value":"with a line in a text file [...] speak directly to function, material action, and agency"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\" "},{"children":[{"children":null,"tag":"literal","value":"bertram_code_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This is done, not by relying on the computer as a generative device, but by harnessing from the form and subject matter of those very machine languages which subsequently can exhibit those generative properties. Focusing on the language part of the machine allows for an interplay between human and machine meanings."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Still, machine semantics are nonetheless considered as an essential device in writing code poetry, and exploring concepts that are not easily grasped in natural languages—e.g. hoisting or destructuring assignment. Additionally, the contrast between the source representation of the poem and its execution can add to the poetic tension, as we see in Nick Montfort's"},{"children":[{"children":null,"tag":"literal","value":"All The Names of God"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(2010) (source in"},{"children":[{"children":null,"tag":"literal","value":"code:all_the_names_of_god"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", and output in"},{"children":[{"children":null,"tag":"literal","value":"output:all_the_names_of_god"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":")."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/all_the_names_of_god.pl"}],"tag":"code","value":"perl"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"All The Names of God, Nick Montfort, 2010, source"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:all_the_names_of_god"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"breaklines=true,breakanywhere"},{"children":null,"tag":"literal","value":"./corpus/all_the_names_of_god.txt"}],"tag":"code","value":"text"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"All The Names of God, Nick Montfort, 2010, Selected output"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"output:all_the_names_of_god"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This poem is the object of close literary critical examination by Maria Aquilina, who notes that"},{"children":[{"children":null,"tag":"literal","value":"[t]he contrast between the economical minimalism of the program and the ordered but infinite series of letter combinations it produces is one of the aspects that make the poem striking"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"aquilina_computational_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Building on philosophy and literary theorists, Aquilina situates the expressive power of the poem in its engagement with the concept of"},{"children":[{"children":null,"tag":"literal","value":"eventualization"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", locating the semantic load of the poem in its existence both in a human-perception of the non-human (e.g. computer time) and the dialogue between source, output and title"},{"children":[{"children":null,"tag":"literal","value":"aquilina_computational_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Not only is there an aesthetic of minimalism present in the source (to which Perl lends itself perfectly), the output also represents the"},{"children":[{"children":null,"tag":"literal","value":"depth"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(in Hayles's sense) of the medium of writing. As we have seen above, a literary conception of source code aesthetic can, under certain circumstances, find its quality not just the limit in characters, but in the relationship between such a limit and the expansiveness of the ideas expressed."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From software developers to artists, different kinds of writers seem to equate code as a text, bringing forth multiple reasons to justify such a connection. Beyond the fact that source code is made up of textual characters, we see that these conceptions of code as literature are multiple`'. On the one side, it is focused on its need to communicate explicit concepts related to its function (Knuth, Matsumoto, Brock), all the while embracing the semantic ambiguity which exists in the use of natural language tokens, backed-up by the potential executable semantics enabled by its machine nature (Cramer, Hayles, Montfort, Temkin)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The last example, the tension between"},{"children":[{"children":null,"tag":"literal","value":"All The Names of God"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"'s source and output, between notation and ideas, suggests us to look at this kind of elegance not through a literary lens, but through a scientific one—another domain conjured by code writers and readers."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Scientific beauty"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:scientific-beauty"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Having strong roots in scientific thought and practice, via the connection of computer science, the aesthetic experiences of source code are also related to the scientific domain. Nonetheless, it seems to exist in two distinct ways: whether code is beautiful in a similar way that mathematics is, or wether code is beautiful according to equivalent principles at play in engineering."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Mathematics"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:beauty-mathematics"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A recurring point in programmers' discussions of beauty in programming is oftentimes the duality of the object of discussion: is one talking about an algorithm, or about a particular implementation of an algorithm? While this thesis is concerned with the latter, we now turn to how this relationship between algorithm and implementation presents a similar tension as the relationship between theorem and proof in mathematics."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"On the one side, there exists few discussions of a direct relation between code and beauty from a mathematical perspective beyond Edsger Dijkstra's discussion of the implementation of programming languages. In it, he starts from computer science's strong origin in mathematics (e.g. lambda calculus), to show that this relation exists in part through, again, the concept of"},{"children":[{"children":null,"tag":"literal","value":"elegance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Theorems and subroutines are compared as being similar essential building blocks in the construction of a correct system. Correctness as the ultimate aim of both mathematics and programming takes place, he writes, by the use of a limited, efficient amount of those building blocks, resulting in a set of small, general and systemic concepts, in an elegant structure"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_design_1963"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Gian-Carlo Rota, in his investigation into mathematical beauty, distinguishes between mathematical beauty, a property which in turn triggers an aesthetic experience, and mathematical elegance, the concrete implementation thereof."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Although one cannot strive for mathematical beauty, one can achieve elegance in the presentation of mathematics. In preparing to deliver a mathematics lecture, mathematicians often choose to stress elegance and succeed in recasting the material in a fashion that everyone will agree is elegant. Mathematical elegance has to do with the presentation of mathematics, and only tangentially does it relate to its content."},{"children":[{"children":null,"tag":"literal","value":"rota_phenomenology_1997"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This separation between the beauty of a mathematical concept (theorem) and its presentation (proof) is reflected in the separation between algorithm and computer program, as McAllister notes. According to him, the beauty of source code is considered closer to the beauty in mathematical proofs, and as such abides by norms of exactness (over approximation) and transparency (over cumbersoneness)"},{"children":[{"children":null,"tag":"literal","value":"mcallister_mathematical_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Specifically, mathematical proofs are supposed to fulfill the requirement of what McAllister calls"},{"children":[{"children":null,"tag":"literal","value":"graspability"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", that is, the tendency for a proof to have the theorem it depends on grasped in a single act of mental apprehension, which, in turn, provides genuine understanding of the reasons for the truths of the theorem. When seen as a form a mathematical beauty, code is therefore praised in being to convey its function through concrete syntax; and linking aesthetic satisfaction with an"},{"children":[{"children":null,"tag":"literal","value":"economy of thought"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The first to employ such an expression, the mathematician Henri Poincaré describes the rigor of a mathematical process as subsequently obtained by combining this economy of thought, a form of cognitive elegance, with the concept of"},{"children":[{"children":null,"tag":"literal","value":"harmony"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"poincare_science_1908"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". By virtue of mathematics being based on formal languages, this linguistic component introduces a certain kind of structure, and the complexity of the problem domain is made more harmonious by the reliance on such an invariant structure (i.e. the syntax of the formal language used). Source code as mathematics can thus be seen as a cognitive structure, which the elements, based on formal linguistics, can exhibit elegant aspects in their communication of a broader concept."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Engineering"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:beauty-engineering"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As we have seen in our discussion of the relationship between computer science and programming as a relationship between the abstract and the concrete, one can see in these two activities a parallel in mathematics and engineering. Engineering is, like programming, the concrete implementation backed by deliberate and careful planning, often with the help of formal notations, of a solution to a given problem. Mathematics, from this perspective, can be considered as one of the languages of engineering, among sketches, diagrams, techniques, tools, etc."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"One of the central concepts in the practice of mathematics, elegance, can also be found, along with its connection to source code, in engineering. Bruce McLennan examines such a connection from a more holistic angle than that of a single act of mental apprehension, when looking at a proof. He suggests that,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Since aesthetic judgment is a highly integrative cognitive process, combining perception of subtle relationships with conscious and unconscious intellectual and emotional interpretation, it can be used to guide the design process by forming an overall assessment of the myriad interactions in a complex software system."},{"children":[{"children":null,"tag":"literal","value":"schummer_aesthetic_2009"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"His point is that software is too complex to be easily verified, and that tools to help us do so are still limited. This complexity sets our intuition adrift and analytical resources do not help. In order to handle this, he proposes to shift the attention from an analytical to phenomenological one, from the details to the general impression. Engineering, like mathematics, ultimately aim at being correct. While the latter can rely on succint formal propositions and representations to achieve this purpose, engineering composes too many moving parts of different nature. The specificity lies in the nature of software engineering's materials:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"All arts have their formal and material characteristics, but software engineering is exceptional in the degree to which formal considerations dominate material ones."},{"children":[{"children":null,"tag":"literal","value":"schummer_aesthetic_2009"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, the development of his arguments remains on the phenomenological side, distant from the standards of mathematic abstraction. In engineering, he argues, the design looks unbalanced if the forces are unbalanced, and the design looks stable if it is stable.  By restricting our attention to designs in which the interaction of features is manifest—in which good interactions look good, and bad interactions look bad—we can let our aesthetic sense guide our design, relying on concepts of efficiency, economy and elegance"},{"children":[{"children":null,"tag":"literal","value":"mclennan_who_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The sciences, and specifically mathematics and engineering, have their own set of aesthetics standards, to which source code seems to be connected to, even though they might not always align. Still, the idea of elegance remains central to both mathematical and engineering approaches, as it measures the number and conciseness of the theory's basic principles, or of the structure's basic components, while keeping the need for an overall effect, whether as enlightenment (Rota) for mathematics, in which larger implications are gained from a particular way a proof of a theorem is presented, or as an ecompassing"},{"children":[{"children":null,"tag":"literal","value":"gestalt"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"impression in engineering, in which a program that looks correct, would most likely be correct."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another concept touched upon by both approaches is that of structure: mathematics deal with formal structures to represent and frame the complexity of the world, while engineering deal with concrete structures offered as solutions to a specific problem. The last of the main domains to which source code is referred to is at the intersection of concrete and abstract structures, of function and form—architecture."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Architectural beauty"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:beauty-architecture"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Formal organization"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:formal-organization"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software architecture emerged as a consequence of the structured revolution"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_chapter_1972"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", which was concerned more with the higher-level organization of code in order to ensure the quality of the software produced. Such an assurance was suggested by Djikstra in two ways: by ensuring the provability of programs in a rigorously mathematic approach, and by ensuring that programs remained as readable as possible for the programmers. Structure has therefore been an essential component of the intelligibility of software since the 1970s. It's only in the late 1990s that software architecture as a discipline has been recognized as such, stemming form a bottom-up approach of recognizing that some ways in which code is organized is better than others."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Today,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"software architectural models are intended to describe the structure and behavior of a system in terms of computational entities, their interactions and its composition patterns, so to reason about systems at more abstract  level, disregarding implementation details."},{"children":[{"children":null,"tag":"literal","value":"garland_software_2000"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"When Mary Shaw and David Garland publish their 1996 book"},{"children":[{"children":null,"tag":"literal","value":"Software architecture : perspectives on an emerging discipline"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", they represent the beginning of a trend of adoption of so-called architectural practices within the field of software development. This relation of the former with the latter has its origin in the structured programming shift in the late 1960s: the idea was to bring in a more normative approach to writing code, in the hope that this structure would support correctness and efficiency. Building on this need for structure, software architecture has thus developed into an approach to software patterns, modelling and documentation, through the overall processes, communications, inputs and outputs of a system can be formally described and verified."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This connection between the two fields is therefore established through the need for reliability in the structures being built, once programmers realized that the artefacts resulting from their work—software, in the form of source code—can exhibit certain structural properties, in a similar way that a surface of a particular material exhibits particular structural properties. Concepts such as modularity, spatial organization or inter-dependence, it turns out, could be applied to both fields."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Good source code, from a software architecture perspective, is code which is clearly organized, respecting a blueprint which, not being source code"},{"children":[{"children":null,"tag":"literal","value":"per se"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"as written in machine language and allowing for dynamic behaviour, is nonetheless formalized (see, for instance the Universal Modelling Language). These domain-specific architectures are then related to a given problem-domain (a university, a hospital, many-to-many secure communications, etc.). As Robin K. Hill mentions in her essay on software elegance:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Brevity by itself can't be enough; the C loop control"},{"children":[{"children":null,"tag":"literal","value":"while(i++ < 10)"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"may be terse, excelling in brevity, but its elegance is debatable. I would call it, in the architectural sense, brutalism. Architecture provides nice analogues because it also strives to construct artifacts that meet specifications under material constraints, prizing especially those artifacts that manifest beauty as well."},{"children":[{"children":null,"tag":"literal","value":"hill_what_2016"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another parallel between the two fields can be found in Eric Raymond's"},{"children":[{"children":null,"tag":"literal","value":"The Cathedral and the Bazaar"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". This essay describes the Linux project, the open-source philosophy it propelled into the limelight, and how the quantity of self-motivated workers without rigid working structures (which is not to say without clear designs) can result in better work than if made by a few, select, highly-skilled individuals"},{"children":[{"children":null,"tag":"literal","value":"raymond_cathedral_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". While the cathedral is traditionally considered more aesthetically pleasing than the bazaar, in terms of architectural canon, Raymond sides with a bazaar-like model of organization, in which all development is done in public, with a very loose, horizontal contribution structure at any stage of the software lifecycle—as opposed to a tightly guided software project whose development is done by a restricted number of developers. While he doesn't mention specific aesthetic standards in his essay, he does highlight parallels in practices and processes, laying foundations on which to build such standards. Architecture is thus both a model for the planning of the construction of artefacts, and a model for the organization of the persons constructing these artefacts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Simon Yuill, in the volume edited by Olga Goriunova and Alexei Shulgin, develop a parallel between code art and the brutalist style of architecture. A style characterized by its foregrounding of the raw materials constituting the building, Brutalism foregoes decoration or ornament to focus on direct utility. Yuill, building on the"},{"children":[{"children":null,"tag":"literal","value":"HAKMEM"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"document circulated at MIT's computer science department in 1972, equates this approach to a coding close to the \"bare metal\" of the computer, using the Assembly language. Contrary to higher-level languages such as C or Java, Assembly engages directly with the intricacies of specific machines, and underlines the fundamental necessity of the hardware and the need to acknowledge such a primacy. Beyond this materiality, he also equates other architectural values such as modularity present in the work of architects such as Le Corbusier or Kunio Mayekawa, as well as in programs such as the UNIX operating system"},{"children":[{"children":null,"tag":"literal","value":"yuill_code_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". What we see here is yet another reference from software to architecture, focusing this time on the reality of hardware, and on some theoretical principles similar in postwar Western architecture."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, the trade litterature has also been contributing to this overlap between between architecture and software as formal, high-level organization of inter-connected components. For instance, Robert Martin, in the influential"},{"children":[{"children":null,"tag":"literal","value":"Clean Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"mentions that the standards of software architecture are based on the"},{"children":[{"children":null,"tag":"literal","value":"5S"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"japanese workplace organization method, namely:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"seiri (整理) - naming and sorting all components used"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"seiton (整頓) - placing things where they belong"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"seisō (清掃) - cleanliness"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"seiketsu (清潔) - standardization and consistency in use"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"shitsuke (躾) - self-discipline"}],"tag":"paragraph","value":""}],"tag":"list","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We recognize here a focus on efficiency, organization and"},{"children":[{"children":null,"tag":"literal","value":"proper"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"use, along with the requirement of cleanliness of the tools, workbench and workplace, as a virtue of a good organization. While originally applied to manufacture, Martin makes the case that this can also apply to the knowledge economy—as in our case, with correct naming, correct placement, correct appearance and correct use."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Vernacular constructions"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:vernacular-construction"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"However, considering architecture as a strictly organizational practice does not show the whole picture. As Hill's quote above hints at, there is another side to architecture, concerned with details rather than with plans, feeling rather than rationalizing."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This is particularly salient in the development of software patterns, and their reference to a particular branch of architectural theory: Christopher Alexander's"},{"children":[{"children":null,"tag":"literal","value":"A Pattern Language"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"A Pattern Language"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"kickstarted a whole field of research based around this idea of distinct, self-contained but nevertheless composable components. In Alexandrian terms, they are a triad,"},{"children":[{"children":null,"tag":"literal","value":"which expresses a relation between a certain context, a problem, and a solution."}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Similarly to architectural patterns, these emerged in a bottom-up fashion: individual software developers found that particular ways of writing and organizing code were in fact extensible and reusable solutions to common problems which could be formalized and shared with others."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Besides the theoretical similarities between software and architecture mentioned above, it is the lack of learning from practical successes and failures in the field which prompted interest in Alexander's work, along with the development of Object-Oriented Programming, first through the Smalltalk language, then with C++,"},{"children":[{"children":null,"tag":"literal","value":"Today most of the programming languages allow for some object-oriented paradigm"}],"tag":"footnote","value":"86"},{"children":null,"tag":"literal","value":". The similarity between a pattern and an object, and their promise of using them which would lead to better results on multiple dimensions, made it very attractive to software developers. Writing in"},{"children":[{"children":null,"tag":"literal","value":"Patterns of Software"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(with a foreword by Alexander), Richard P. Gabriel illustrates that point:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The promise of object-oriented programming—and of programming languages themselves—has yet to be fulfilled. That promise is to make plain to computers and to other programmers the communication of the computational intentions of a programmer or a team of programmers, throughout the long and change-plagued life of the program. The failure of programming languages to do this is the result of a variety of failures of some of us as researchers and the rest of us as practitioners to take seriously the needs of people in programming rather than the needs of the computer and the compiler writer."},{"children":[{"children":null,"tag":"literal","value":"gabriel_patterns_1998"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Throughout his work, Gabriel weaves parallels between his experience as a software developer and as a poetry writer, drawing concepts from the latter field into the former, and inspecting it through the lens of pattern languages. Two concepts in particular are worth examining a bit further:"},{"children":[{"children":null,"tag":"literal","value":"compression"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"habitability"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Compression, in narrative and poetic text, is the process through which a word is given additional meaning through the rest of the sentence. In a sentence such as \""},{"children":[{"children":null,"tag":"literal","value":"Last night I dreamt I went to Manderley again."}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"\""},{"children":[{"children":null,"tag":"literal","value":"From Daphne DuMaurier's"},{"children":[{"children":null,"tag":"literal","value":"Rebecca"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"87"},{"children":null,"tag":"literal","value":", the reader is unlikely to be familiar with the exact meaning of"},{"children":[{"children":null,"tag":"literal","value":"Manderley"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", since this is the first sentence of the novel. However, we can infer some of the properties of Manderley from the rest of the sentence: it is most likely a place, and it most likely had something to do with the narrator's past, since it is being returned to. A similar phenomenon happens in source code, in which the meaning of a particular expression or statement can be derived from itself, or from a larger context. In object-oriented programming, the process of inheritance across classes allows for the meaning of a particular subclass to be mostly defined in terms of the fields and methods if its subclasses—its meaning is compressed by relying on a semantic environment, which might or not be immediately visible. This, Gabriel says, induces a tension between extendability (to create a new subclass, one must only extend the parent, and only add the differentiating aspects) and context-awareness (one has to keep in mind the whole chain of properties in order to know exactly what the definition of an interface that is being extended really is). Resolving such a tension, by including enough information to hint at the context, while not over-reaching into verbosity, is a thin line of being self-explanatory without being verbose."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, Gabriel, writing in 1998, mentions that compression isn't so much a problem in poetry since, ultimately, the definitions of each words aren't quite limited to the poet's own mind but exist as well in the broad conceptual structures which readers hold. However, since all aspects of a program is always by definition explicitly defined, programmers thus have the ultimate say on the definition of most of the data and functions described in code. Compression doesn't work as well because the reader cannot assume anything that is being mentioned in the code (and defined elsewhere), without risking the (error-raising) consequence of being wrong."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"His particular assumption that others will want to modify and extend source code is one that is influenced by his background as a commercial developer. Other pieces of code might just be satisfying in being read or deciphered (as we have seen in source code poetry) but this assumption of interaction with the code brings in another concept, that of"},{"children":[{"children":null,"tag":"literal","value":"habitability"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In his terms, it is"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"the characteristic of source code that enables programmers, coders, bug-fixers, and people coming to the code later in its life to understand its construction and intentions and to change it comfortably and confidently."},{"children":[{"children":null,"tag":"literal","value":"gabriel_patterns_1998"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In a sense, then, beautiful code is also code that is clear enough to inform action and, well-organized enough to warrant actually taking that action. It relates to Alexander's property of"},{"children":[{"children":null,"tag":"literal","value":"comfort"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", by affording involvement instead of estrangement: one is at ease when making changes to a program text, rather than fearing unknown consequences due to a lack of a clear mental model."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Architecture, when referenced by software, includes at least two distinct approaches: one tending to the objective, and one tending to the subjective. This distinction, operated by Roger Scruton, equates these to a tendency to, respectively, emotionality or rationality"},{"children":[{"children":null,"tag":"literal","value":"scruton_aesthetics_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This pair is reflected in how software also refers to architecture: as top-down planning or as bottom-up construction, both holding different, but overlapping aesthetic standards. One the one side, we have cleanliness, orderliness and appropriateness, following interpersonal conventions and style; on the other side, we have familiarity, compression and appropriateness of community patterns."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At its most common denominator, architecture is then concerned with the gross structure of a system. At its best, architecture can support the understanding of a system by addressing the same problem as cognitive mapping does: simplifying our ability to grasp large system.This phrase appears in Kevin Lynch's work on"},{"children":[{"children":null,"tag":"literal","value":"The Image of the City"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in which he highlighted that our understanding of an urban environment relies on combinations of patterns (node, edge, area, limit, landmark) to which personal, imagined identities are ascribed. The process is once again that of abstraction, but goes beyond that. In parallel, Garland notes that, in its most effective cases, software architecture can expose the high-level constraints on the design of a system, as well as"},{"children":[{"children":null,"tag":"literal","value":"the rationale for making specific architectural choices"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". The rationale, the deeper meaning of a program, seems to matter as much as the formal description of its system."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Architecture is indeed a field that exists at the intersection of multiple other fields: engineering, art, design, physics and politics. As the organization of space, one can project it onto non-physical spaces, such as software, and the way that it takes shape within the medium of source code will be more thoroughly explored in Chapter XXX. As such, it provides another peek into the relationship between function and form, and how it is mediated by the materials in which a certain structure is built, whether it is a physical structure, or a mental structure which only exists in a written form."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Buildings, like most things, are more than their surface, consisting of much that is not revealed. Particularly, their sensuous surfaces sometimes tend to obscure their main function"},{"children":[{"children":null,"tag":"literal","value":"Think of a building housing a stock-exchange disguided as a Greek temple."}],"tag":"footnote","value":"88"},{"children":null,"tag":"literal","value":". Carlson and Parsons, in their discussion of Functional Beauty, arguee that there is an ethical problem in this mystification; while art mystifies, assuming us to suspend our disbelief to enter into an artwork's appreciation, the things that are functional can have a much bigger and much worse consequence when they mystify, potentially rendering the whole construction useless, and its value null."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In summary, we have seen that the specific topic of the aesthetics of the aesthetics of software refers to three main, different domains. By referring to code as text, its linguistic nature is highlighted, along with its problematic relationship to natural languages—problematic insofar as its ambiguity can play against its desire to be clear and understood, or can play in favor of poetic undertones. The standards expressed here touch upon the specific tokens used to write programming, and thus involve the programming languages in the process of aesthetic judgement."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Also considering the formal nature of source code, scientific references equate source code as having the potential to exhibit similar properties as mathematical proofs and theorems, in which the elegance of the proof isn't a tight coupling with the theorem to be proved, but in which an elegant proof can (and, according to some, should) enlighten the reader to deeper truths. Conversely, these scientific references also include engineering, in which the applicability, its correctness and efficiency are of prime importance: the conception of elegance, accompanied by economy and efficiency, becomes a more holistic one, tending to the general feeling of the structure at hand, rather than to its specific formalisms."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These references to engineering then lead us to the last of the domains: architecture. Presented as both relevant from a top-down perspective (with formal modelling languages and descriptions, among others) or from a bottom-up (including software patterns and familiarity and appropriateness within a given context). These similarities between software in architecture, both in planning, in process and in outlook, touch upon another subject: the place of formal and informal knowledges in the construction, maintenance and transmission of those (software) structures."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"All of these three domains of references have in common the concept of elegance, and the concept of understanding, we will turn to the relationship between code and understanding next. However, we conclude this chapter by a last reference domain which, while not tied to a particular field, is a way of doing with which programmers have long associated themselves with. The next section thus examines the relationship between craftsmanship and knowledge in writing and reading source code."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Craft, knowledge and beauty"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:craft"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In their introduction to the field of sofware architecture, Shaw and Garland summon the need to formalise the practice as the practice moves from craft to engineering"},{"children":[{"children":null,"tag":"literal","value":"shaw_software_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Already mentioned by Dijkstra, Knuth and other early software practitioners, the conception of programming as a craft has become more and more popular amongst source code writers and readers"},{"children":[{"children":null,"tag":"literal","value":"See, for instance, Joel Spolsky"},{"children":[{"children":null,"tag":"literal","value":"spolosky_craftsmanship_2003,seibel_coders_2009"}],"tag":"citation","value":""}],"tag":"footnote","value":"89"},{"children":null,"tag":"literal","value":".  For instance, Paul Graham, LISP programmer, co-founder of the Y Combinator startup accelerator and widely-read blogger"},{"children":[{"children":null,"tag":"literal","value":"And even achieving god-like status among certain circles"},{"children":[{"children":null,"tag":"literal","value":"eadicicco_startup_2014"}],"tag":"citation","value":""}],"tag":"footnote","value":"90"},{"children":null,"tag":"literal","value":", highlights the status of programming languages as a medium and craft as a way to approach it, in his essay"},{"children":[{"children":null,"tag":"literal","value":"Hackers and Painters"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"graham_hackers_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Particularly, he stresses the materiality of code, depicting hackers and craftsmen as people who:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"are trying to write interesting software, and for whom computers are just a medium of expression, as concrete is for architects or paint for painters."}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"So, while links between craftsmanship and programming have existed as self-proclaimed ones by programmers themselves, as well as by academics and writers"},{"children":[{"children":null,"tag":"literal","value":"sennett_craftsman_2009,chandra_geek_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", they have not yet been elucidated under specific angles. Indeed, craftsmanship as such is an ever-fleeting phenomenon, a practice rather than a theory, in the vein of Michel De Certeau's"},{"children":[{"children":null,"tag":"literal","value":"tactics"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":", bottom-up actions designed and implemented by the users of a situation, product or technology as opposed to"},{"children":[{"children":null,"tag":"literal","value":"strategies"}],"tag":"italic","value":""},{"children":[{"children":null,"tag":"literal","value":"certeau_invention_1990"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", in which ways of doing are prescribed in a top-down fashion. It is this practical approach that this article chooses, the informal manners and standards of working, in order to provide an additional, cultural studies perspective, to its media and software studies counterparts."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Craftsmen and architects"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:craftsmen-architect"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A comparative approach of a broad mode of economic and cultural activity (craftsmanship) with a narrower technical know-how (software development) asks us first to verify to what extent such an approach is even valid. How, then, is the designation by software developers of their own practice as craftsmanship relevant?  By examining formal and informal texts, we focus on the fact that software developers ground their practice in passion, know-how and myths. Particularly, we inspect the place of architecture, both in historical craftsmanship and contemporary software development, in order to qualify further the relationship between design and implementation in those two fields."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Starting from programmers' self-identification with craftstmanship, we analyze how those references by programmers enter into a productive dialogue with our historical and cultural conception of craftsmanship. First, the focus is set on the historical unfoldings of craftsmanship and software development, showing parallels. After inquiring into the modes of organization and the economical development of both craftsmanship and software development, this section focuses on the particular comparison with building, and its involvement with knowledge management and aesthetic judgments.  Building on discussions of beautiful craft and beautiful code, the focus is not on the standards which allow practicioners to ascribe specific beauty to a specific piece of software; instead, we start a discussion into the materiality of code not in terms of bits, bytes and languages, but rather as a conceptual one which is to be worked with and worked through."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Craftsmanship through the ages"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:history-craftsmanship"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Craftsmanship in our contemporary discourse seems most tied to a retrospective approach: it is often qualified as that which was"},{"children":[{"children":null,"tag":"literal","value":"before"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"manufacture, and the mechanical automation of production"},{"children":[{"children":null,"tag":"literal","value":"thompson_study_1934"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". So while the practice of developing a skill in order to build something with a functional design has been considered at its apex of craftsmanship in Western late Middle-Ages, it should be noted here that non-Western craftsmanship are as equally rich and unique as their Western counterparts, for instance in China"},{"children":[{"children":null,"tag":"literal","value":"zhang_jingdezhen_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and Japan"},{"children":[{"children":null,"tag":"literal","value":"jordan_copying_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"; however, these lie beyond the immediate scope of this article. Following Sennett, we will use his definition of craftsmanship as"},{"children":[{"children":null,"tag":"literal","value":"hand-held, tool-based, intrinsically-motivated work which produces functional artefacts, and in the process of which is held the possibility for unique mistakes"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"sennett_craftsman_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Late Middle-Ages craftsmanship stands out as such for a couple of reasons: their socio-economic organization, and their relationship to knowledge. First and foremost, craftspeople were indissociable from the guilds they belonged to"},{"children":[{"children":null,"tag":"literal","value":"black_guilds_1984"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As tightly-knit communities, they exhibited strong cohesion: vertically, between a master and their apprentices, and horizontally, between equal practicioners, enforcing a uniform quality control assurance and price management (Managerial Techniques by Wolek). This cohesion, in turn, has limited the amount of individual fame and glory that craftspeople could accumulate, as compared to fine-artists"},{"children":[{"children":null,"tag":"literal","value":"thompson_materials_1956"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A key aspect of the craftsmanship of this time is the relationship that they maintained with explicit, formalized standards. While various crafts did include specific lexical fields to describe the details of their trade"},{"children":[{"children":null,"tag":"literal","value":"bassett_craftsman_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", usually compiled into glossaries, the standards for quality were less explicit. Cennino Cennini, in his"},{"children":[{"children":null,"tag":"literal","value":"Libro dell'arte"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", one of the first codexes to map out technical know-how necessary to a painter in the early Renaissance, lays out both practical advice on specific painting techniques, but does not explicitly lay out how to make something"},{"children":[{"children":null,"tag":"literal","value":"good"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"cennini_craftsman_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Further work, at the eve of the Industrial Revolution, continued on this intent to formalize the practice of craftsmanship"},{"children":[{"children":null,"tag":"literal","value":"pannabecker_diderot_1994"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In this sense, quality work is rooted in implicit knowledge: a good craftsman knows a quality work when they see it"},{"children":[{"children":null,"tag":"literal","value":"sennett_craftsman_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another component of craftsmanship is its alleged incompatibility with manufacture"},{"children":[{"children":null,"tag":"literal","value":"ruskin_seven_1920,sturt_wheelwright_1963"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". However, studies have shown that the craftsmanship, rather than standing at the strict opposite of the industrial"},{"children":[{"children":null,"tag":"literal","value":"jones_reckoning_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", has been integrated into the process of modern industrialization. The practice of the craftsman, then, integrates into the design and operation of machines and industrial-scale organizations, informing ways of making in our contemporary world"},{"children":[{"children":null,"tag":"literal","value":"gordon_who_1988,mcgee_craftsmanship_1999"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These characteristics of tight and rigid communities, implicit knowledge, and ambiguous separation with design, framing the foundation of a desire for good work are particularly highlighted in the field of the built environment, and later in the development of architecture. Before examining how such a field has a connection to software development, we take a look at programming's emergence as a field of craft."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Software developers as craftsmen"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:software-craftsmen"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Computer programming as an activity came to be as an offshoot of computer science, perhaps best illustrated by the collaboration of Charles Babbage and Ada Lovelace on The Analytical Engine, the prototype of the modern computer. With Babbage acting as the overall designer, Lovelace was key in practically implementing some of the mathematical formulas which The Analytical Engine was built to solve. What we see here is a dyad of work, distinguished between design and conception on one side, and implementation and practice on the other side. These two approaches are echoed throughout the early days of programming (1950s-1970s), with programmers becoming distinct from computer scientists by their approach to the problem (they'd rather write code on a terminal than write algorithms on a piece of paper) and by their background (trained as scientists but more comfortable with tinkering)"},{"children":[{"children":null,"tag":"literal","value":"ensmenger_computer_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In particular, the group of computer enthusiasts described as hackers developed organizational features similar to their historical counterparts: work was being done on distinct topics and fields in different geographic locations (Stanford, MIT, Bell Labs)"},{"children":[{"children":null,"tag":"literal","value":"raymond_cathedral_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", emphasis was put on engagement with tools, inquiring into peers' work"},{"children":[{"children":null,"tag":"literal","value":"levy_hackers_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and later formalized into bottom-up archives"},{"children":[{"children":null,"tag":"literal","value":"The most famous of which is the Jargon File, later to be published as the The New Hacker's Dictionary:"},{"children":[{"children":null,"tag":"literal","value":"http://www.catb.org/jargon/html/"}],"tag":"url","value":""}],"tag":"footnote","value":"91"},{"children":null,"tag":"literal","value":". Additionally, little accountability was required when it came to design explicitness. As examples, both the UNIX operating system and the TCP/IP protocol were originally realized without overarching supervision and without extensive ongoing documentation"},{"children":[{"children":null,"tag":"literal","value":"seibel_coders_2009,raymond_cathedral_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As computer science solidified as a distinct field in the 1960s"},{"children":[{"children":null,"tag":"literal","value":"tedre_development_2006"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", there was a process of formalizing the hitherto"},{"children":[{"children":null,"tag":"literal","value":"ad hoc"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":"techniques of programming computers. As a response to the myth of carefully hand-made code"},{"children":[{"children":null,"tag":"literal","value":"See The Story of Mel, A Real Programmer, a folktale of early programmers:"},{"children":[{"children":null,"tag":"literal","value":"https://www.cs.utah.edu/~elb/folklore/mel.html"}],"tag":"url","value":""}],"tag":"footnote","value":"92"},{"children":null,"tag":"literal","value":"and unconstrained approaches to writing code came the structured programming approach, initally proposed by E. W. Djisktra"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_chapter_1972"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". With the operating system and the personal computer revolutions, access to tools became widespread, and transformed tightly communities into a global network of exchange, first via Usenet, then through the Web. Inquiries into the relationship of craftsmanship with programming started to take place in the mid-1970s from an educational perspective"},{"children":[{"children":null,"tag":"literal","value":"dijkstra_craftsman_1982"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", from an organizational perspective"},{"children":[{"children":null,"tag":"literal","value":"brooks_mythical_1975"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and an inter-personal perspective"},{"children":[{"children":null,"tag":"literal","value":"weinberg_psychology_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and culminated with the publication of several trade books"},{"children":[{"children":null,"tag":"literal","value":"martin_clean_2008,hendrickson_software_2002"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", explicitly connecting the craft of programming with previous craft activities, and emphasizing the need for intrinsic motivation and the aim of a job well-done"},{"children":[{"children":null,"tag":"literal","value":"hoover_apprenticeship_2009,goodliffe_code_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Comparisons of software development with craftsmanship are abundant, and relate then mostly to the relationship between unstructured practice and formalized theory; as such, it is used to self-categorize programmers as skilled makers rather than passive thinkers"},{"children":[{"children":null,"tag":"literal","value":"See code monkey, as a derogative term for such passive, detached practice:"},{"children":[{"children":null,"tag":"literal","value":"http://www.techopedia.com/definition/31469/code-monkey"}],"tag":"url","value":""}],"tag":"footnote","value":"93"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Craft in architecture"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:craft-architecture"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The field of architecture helps us tie these two traditions together a little more explicitly. Architecture as a field and the architect as a role have been solidified during the Renaissance"},{"children":[{"children":null,"tag":"literal","value":"pevsner_term_1942"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", consecrating a separation of abstract design and concrete work, in which the craftsman is relegated to the role of executioner, until the arrival of civil engineering and blueprints overwhelmingly formalized the discipline."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The classical architect, here, serves as the counterpart to the computer scientist, except in an inverse relation: the architect emerged from centuries of hands-on work, while the computer scientist (formerly known as mathematician) was first to a whole field of practicioners as programmers, followed by a need to regulate and structure those practices. Different sequences of events, perhaps, but nonetheless mirroring each other. On one side, construction work without an explicit architect, under the supervision of bishops and clerks, did indeed result in significant results (Notre Dame de Paris, Basilica of Sienna). On the other side, letting go of structured and restricted modes of working characterizing computer programming up to the 1980s resulted in a comparison described in the aptly-named"},{"children":[{"children":null,"tag":"literal","value":"The Cathedral and the Bazaar"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":". This essay described the Linux project, the open-source philosophy it propelled into the limelight, and how the quantity of self-motivated workers without rigid working structures (which is not to say without clear designs) can result in better work than if made by a few, select, highly-skilled individuals"},{"children":[{"children":null,"tag":"literal","value":"raymond_cathedral_2001,henningsen_joys_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"What we see, then, is a similar result: individuals can cooperate on a long-term basis out of intrinsic motivation, and without clear, individual ownership of the result; a parallel seen in the similar concepts of"},{"children":[{"children":null,"tag":"literal","value":"collective craftsmanship"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":"in the Middle-Ages and the"},{"children":[{"children":null,"tag":"literal","value":"egoless programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of today"},{"children":[{"children":null,"tag":"literal","value":"brooks_mythical_1975"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The further sections will investigate how such a phenomena of building complex structures through horizontal networks is possible, from both epistemological and aesthetic perspectives."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Knowledge acquisition and production"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:craft-knowledge"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The problem of knowledge in software development can be examplified by the \"bus factor\""},{"children":[{"children":[{"children":null,"tag":"literal","value":"https://en.wikipedia.org/w/index.php?title=Bus_factor"}],"tag":"url","value":""}],"tag":"footnote","value":"94"},{"children":null,"tag":"literal","value":". It describes the risk of crucial information being lost due to the disappearance or incapacity of one of the programmers of the project, and aims at the problem of"},{"children":[{"children":null,"tag":"literal","value":"essential complexity"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"See the"},{"children":[{"children":null,"tag":"literal","value":"No Silver Bullet"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":"essay in"},{"children":[{"children":null,"tag":"literal","value":"The Mythical Man-Month"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", op.cit."}],"tag":"footnote","value":"95"},{"children":null,"tag":"literal","value":". Given the inherent complexity of programming as a task, along with the compulsive behaviours sometimes exhibited by programmers as a by-product of intrinsic motivation"},{"children":[{"children":null,"tag":"literal","value":"weizenbaum_computer_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", the gap between design and implementation---the domain of the craftsman---often relies on tacit knowledge"},{"children":[{"children":null,"tag":"literal","value":"collins_tacit_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Explicit knowledge, in programming as in most disciplines, is carried through books, academic programs and, more recently, web-based content that is either structured (e.g. MOOCs, Codeacademy, Khan Academy) or unstructured (e.g. blog posts, forums, IRC channels), but both seem to be insufficient to reach an expert level"},{"children":[{"children":null,"tag":"literal","value":"davies_models_1993"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As demonstrated by a popular comic"},{"children":[{"children":null,"tag":"literal","value":"See Randall Munroe,"},{"children":[{"children":null,"tag":"literal","value":"https://xkcd.com/844/"}],"tag":"url","value":""}],"tag":"footnote","value":"96"},{"children":null,"tag":"literal","value":", the road to good code is unclear, particularly when communicated in such a highly-formal language as diagramming. Given the fact that an individual can become a programmer through non-formal training---as opposed to, say, an engineer or a scientist---, the learning process must include implicit knowledge."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Apprentices and masters"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:apprentices-masters"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The acquisition of such implicit knowledge in craftsmanship takes place in two different ways: the apprentice-master relationship, and the act of copying. First comes the apprentice-master relationship, in which a learner starts by  imitating the way of working of the master (Sennett), resulting in a"},{"children":[{"children":null,"tag":"literal","value":"teaching by showing"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", where important aspects of the craft are being demonstrated to the apprentice by a more experienced practicioner, rather than formalized and learned"},{"children":[{"children":null,"tag":"literal","value":"a priori"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of the practice. Sometimes, this relationship to a master is implemented explicitly through practices such as pair programming"},{"children":[{"children":null,"tag":"literal","value":"williams_pair_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"or corporate mentorship programmings (IBM's Master programmer initiative). Other times, it is re-interpretated through fictional accounts designed to impart wisdom on the readers, and taking inspiration from Taoism and Zen"},{"children":[{"children":null,"tag":"literal","value":"james_tao_1987,raymond_new_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". From higher-level programming wisdom featuring leading programmers such as Marvin Minsky and Donald Knuth, this sort of informal teaching by showing has been implemented in various languages as a practical learning experience"},{"children":[{"children":null,"tag":"literal","value":"See, for instance:"},{"children":[{"children":null,"tag":"literal","value":"http://rubykoans.com/"}],"tag":"url","value":""}],"tag":"footnote","value":"97"},{"children":null,"tag":"literal","value":". Without the presence of an actual master, the programming apprentice nonetheless takes the program writer as their master to achieve each of the tasks assigned to them. The experience historically assigned to the master craftsman is delegated into the code itself, containing both the problem, the solution to the problem and hints to solve it, straddling the line between formal exercises and interactive practice."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Code's ability to be copied and executed on various machines provides a counterpoint to the argument of software as craftsmanship in terms of knowledge transmission. Traditionally, since craftsmanship has been understood as that which is done by hand, and since craftsmen were working with unique artefacts (i.e. no artefact can be perfectly copied), copying someone else's realization was physically inconceivable. The realm of software, on the opposite, relies heavily on the technical affordance of code to be duplicated, uploaded, downloaded and executed on multiple platforms through source code files"},{"children":[{"children":null,"tag":"literal","value":"manovich_language_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The first immediate consequence of this is the ability for all to inspect and use source code, both on an institutional level (as guaranteed by projects such as GNU"},{"children":[{"children":null,"tag":"literal","value":"See:"},{"children":[{"children":null,"tag":"literal","value":"https://gnu.org"}],"tag":"url","value":""}],"tag":"footnote","value":"98"},{"children":null,"tag":"literal","value":"), and on a vernacular level (as enabled by Web 2.0 platforms such as StackOverflow and GitHub). Even though the ability to perfectly copy anyone else's work became widely available to programmers, the difference between amateur and expert programmers lied in the extent to which they indeed blindly copy external code, or write their own, inspired by the external code"},{"children":[{"children":null,"tag":"literal","value":"See the discussions on"},{"children":[{"children":null,"tag":"literal","value":"https://softwareengineering.stackexchange.com/questions/36978"}],"tag":"url","value":""}],"tag":"footnote","value":"99"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Practices from Eastern craftsmanship further qualify these essentially different approaches to copying."},{"children":[{"children":null,"tag":"literal","value":"Moxie"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", a Chinese term for copying and practice, is a key concept to understand how an apprentice can equal his master through thougtful replication"},{"children":[{"children":null,"tag":"literal","value":"man_influence_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", an approach equally present in Japanese crafts histor"},{"children":[{"children":null,"tag":"literal","value":"jordan_copying_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Here again, manually copying from established quality work to seize their elusive essence is an essential aspect to craftsmanship."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"The problem with copying"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:craft-copying"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"If implicit knowledge can be acquired through a showing and copying of code, software development as a craft presents an additional dimension to this, a sort of"},{"children":[{"children":null,"tag":"literal","value":"piecemeal knowledge"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Best represented by Stack Overflow, a leading question and answer forum for programmers, on which code snippets are made available as part of the teaching by showing methodology, this piecemeal knowledge can both help programmers in solving issues as well as deter them in solving issues"},{"children":[{"children":null,"tag":"literal","value":"properly"}],"tag":"italic","value":""},{"children":[{"children":null,"tag":"literal","value":"treude_understanding_2017"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Code as such is freely and easily accessible as piecemeals, but often lacks the essential context."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"So while programmers are to acquire implicit knowledge through a process of learning by doing (realizing koans, coding small projects, re-using copied code), we now need to assess how much of it happens through observing. Implied in the apprentice-master relationship is that what is observed should be of"},{"children":[{"children":null,"tag":"literal","value":"good quality"}],"tag":"italic","value":""},{"children":null,"tag":"literal","value":"; one learns through ones own mistakes, and through ones presentation with exmaples of good work. Coming back to the relationship between architecture and software development, Christopher Alexander asks, in the preface of Richard P. Gabriel's"},{"children":[{"children":null,"tag":"literal","value":"Patterns of Software"}],"tag":"italic","value":""},{"children":[{"children":null,"tag":"literal","value":"gabriel_patterns_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":","}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"For a programmer, what is a comparable goal? What is the Chartres of programming? What task is at a high enough level to inspire people writing programs, to reach for the stars?"}],"tag":"italic","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"If a craftsman learns their trade by comparing their work with work of a higher quality (either their master's, or publicly available works, assembled as a canon"},{"children":[{"children":null,"tag":"literal","value":"taylor_patterns_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"), the programmer is faced with a different problem: a lot of examples, but a few good ones.  Copyright stands in the way of pedagogical copying. With software becoming protectable under copyright laws in the 1980s"},{"children":[{"children":null,"tag":"literal","value":"oman_computer_2018"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", great works of programming craft became unacessible to programmers, despite the value they would bring in knowledge acquisition"},{"children":[{"children":null,"tag":"literal","value":"gabriel_mob_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". One of the most famous examples is"},{"children":[{"children":null,"tag":"literal","value":"Lions' Commentary on UNIX 6th Edition, with Source Code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"by John Lions, an annotated edition of the UNIX source code, which was circulated illegaly in classrooms for twenty years before its official publication was authorized by the copyright owners"},{"children":[{"children":null,"tag":"literal","value":"lions_lions_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With implicit knowledge being a key component in both disciplines, its manifestation through the copying of source code in software development is hampered either by decontextualized, uploaded code snippets or by copyrighted protection on works, leading to a lack in an established canon of great works. Nonetheless, the other advice given to beginner programmers—practice"},{"children":[{"children":[{"children":null,"tag":"literal","value":"https://quora.com/What-are-some-of-the-best-ways-to-learn-programming"}],"tag":"url","value":""}],"tag":"footnote","value":"100"},{"children":null,"tag":"literal","value":"—hints at another aspect: direct engagement with code."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Material aesthetics"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:material-aesthetic"}],"tag":"label","value":"ideals"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At the heart of knowledge transmission and acquisition stands the"},{"children":[{"children":null,"tag":"literal","value":"practice"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and inherent in the practice is the"},{"children":[{"children":null,"tag":"literal","value":"good practice"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the one leading to a beautiful result. The existence of an aesthetic experience of code, and the adjectives used to qualify it (smelly, spaghetti, muddy), already pointed at in the previous section, already points at an appreciation of code beyond its formalisms and rationalisms. We now turn to the aesthetic experience of code within the broader context of the aesthetics of craftsmanship, highlighting code's specificity as a material."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A traditional perspective is that motor skills, with dexterity, care and experience, are an essential feature of a craftsman's ability to realize something beautiful"},{"children":[{"children":null,"tag":"literal","value":"osborne_aesthetic_1977"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", along with self-assigned standards of quality"},{"children":[{"children":null,"tag":"literal","value":"pye_nature_2008,sennett_craftsman_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". These qualitative standards which, when pushed to their extreme, result in a craftsperson's"},{"children":[{"children":null,"tag":"literal","value":"style"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", are to be gained through practice and experience, rather than by explicit measurements"},{"children":[{"children":null,"tag":"literal","value":"pye_nature_2008"}],"tag":"citation","value":""},{"children":[{"children":null,"tag":"literal","value":"See Pye's account of craftsmanship, and his intent to make explicit the question of quality craftsmanship and"},{"children":[{"children":null,"tag":"literal","value":"\"answer factually rather than with a series of emotive noises such as protagonists of craftsmanship have too often made instead of answering it.\""}],"tag":"emph","value":""}],"tag":"footnote","value":"101"},{"children":null,"tag":"literal","value":". Two things are concerned here, supporting the final result: tools and materials"},{"children":[{"children":null,"tag":"literal","value":"pye_nature_2008"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". According to Pye, a craftsperson should have a deep, implicit knowledge of both, what they use to manipulate (chisels, hammers, ovens, etc.) as well as what they manipulate (stone, wood, steel, etc)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This relationship to tools and materials is expected to have a relationship to"},{"children":[{"children":null,"tag":"literal","value":"the hand"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and at first seems to exclude the keyboard-based practice of programming. But even within a world in which automated machines have replaced hand-held tools, Osborne writes:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"In modern machine production judgement, experience, ingenuity, dexterity, artistry, skill are all concentrated in the programming before actual production starts."},{"children":[{"children":null,"tag":"literal","value":"osborne_aesthetic_1977"}],"tag":"citation","value":""}],"tag":"italic","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"He opens here up a solution to the paradox of the hand-made and the computer-automated, as programming emerges from the latter as a new skill. This very rise of automation has been criticized for the rise of a Osborne's \"soulless society\""},{"children":[{"children":null,"tag":"literal","value":"osborne_aesthetic_1977"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and has triggered debates about authorship, creativity and humanity at the cross-roads between artificial intelligence and artistic practice"},{"children":[{"children":null,"tag":"literal","value":"mazzone_art_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". One avenue out of this debate is human-machine cooperation, first envisioned by Licklider and proposed throughout the development of Human-Computer Interaction"},{"children":[{"children":null,"tag":"literal","value":"licklider_mancomputer_1960,grudin_tool_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". If machines, more and more driven by computing systems, have replaced traditional craftsmanship's skills and dexterity, this replacement can nonetheless suggest programming as a distinctly 21st-century craftsmanship, as well as other forms of cratsmanship-based work in an information economy."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Beautiful code, code well-written, is indeed an integral part of software craftsmanship"},{"children":[{"children":null,"tag":"literal","value":"oram_beautiful_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". More than just function for itself, code among programmers is held to certain standards which turn out to hold another relationship with traditional craftsmanship—specifically, form following function."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A craftsman's material consciousness is recognized by the anthropomorphic qualities ascribed by the craftsman to the material"},{"children":[{"children":null,"tag":"literal","value":"sennett_craftsman_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", the personalities and qualities that are being ascribed to it beyond the immediate one it posseses. Clean code, elegant code, are indicators not just of the awareness of code as a raw material that should be worked on, but also of the necessities for code to exist in a social world. As software craftsmen assemble in loose hierarchies to construct software, the aesthetic standard is"},{"children":[{"children":null,"tag":"literal","value":"the respect of others"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"abelson_structure_1979"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another unique feature of software craftsmanship is its blending between tools and material: code, indeed, is both. This is, for instance, represented at its extreme by languages like LISP, in which functions and data are treated in the same way"},{"children":[{"children":null,"tag":"literal","value":"mccarthy_lisp_1965"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In that sense, code is a material which can be almost seamlessly converted from information to information-"},{"children":[{"children":null,"tag":"literal","value":"processing"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and vice-versa; code as a material is perhaps the only non-finite material that craftspeople can work with---along with words"},{"children":[{"children":null,"tag":"literal","value":"Disregarding for now the very real impact of computing on the environment"},{"children":[{"children":null,"tag":"literal","value":"kurp_green_2008"}],"tag":"citation","value":""}],"tag":"footnote","value":"102"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Code, from the perspective of craft, is not just an overarching, theoretical concept which can only be reckoned with in the abstract, but also the very material foundation from which the reality of software craftsmanship evolves. An analysis of computing phenomena, from software studies to platform studies, should therefore take into account the close relationship to their material that software developers can have. As Fred Brooks put it,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures."},{"children":[{"children":null,"tag":"literal","value":"brooks_mythical_1975"}],"tag":"citation","value":""}],"tag":"italic","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"So while there are arguments for developing a more rigorous, engineering conception of software development"},{"children":[{"children":null,"tag":"literal","value":"ensmenger_computer_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a crafts ethos based on a materiality of code holds some implications both for programmers and for society at large: engagement with code-as-material opens up possibilities for the acknowledgement of a different moral standard. As Pye puts it,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"["},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"] the quality of the result is clear evidence of competence and assurance, and it is an ingredient of civilization to be continually faced with that evidence, even if it is taken for granted and unremarked."},{"children":[{"children":null,"tag":"literal","value":"pye_nature_2008"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Code well-done is a display of excellence, in a discipline in which excellence has not been made explicit. If most commentators on the history of craftsmanship, following Ruskin, lament the disappearance of a better, long-gone way of doing things, before computers came to automate everything, locating software as a contemporary iteration of the age-old ethos of craftsmanship nonetheless situates it in a longer tradition of intuitive, concrete creation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We covered, in this first chapter, several aspects of an aesthetic conception of code. First, we have established who writes code: far from a homogeneous crowd which would reflect an abstraction conception of \"code\", code writers include inviduals which can be categorized as engineers, hackers, scientists or poets. While these categories do not have rigid boundaries and can easily overlap, they do allow us to establish more clearly the contexts and purposes within which code can be read and written. Hacker code and engineer code look different from each other, achieve different purposes than poetic code, abide by different requirements than scientific code, and so on. Within each of these conceptions, a judgment of what looks good will therefore be different. A conception of the aesthetics of code seems then, at first, to possess some degree of relativity."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Second, we have built on Erik Pineiro's work to complete a survey of the lexical fields that programmers use when they describe or refer to beautiful code. In so doing, we have highlighted certain desired properties, such as clarity, cleanliness, and elegance—as opposed to, say, thrilling, moving, or delicate. This survey involved an analysis of textual instances of programmers' discourses: through blog posts, forum discussions, journal articles or textbooks, showing a steadiness in the expression of an aesthetic posture since the beginning of the trade. Additionally, the study of our negative terms pointed further to sensual metaphors of code, using parallels with smell and texture. As a a \"big ball of mud\", a \"pile of spaghetti\" or full of \"smelly corners\", ugly code is something where its sensual appearance prevents the reader or writer to grasp its true purpose—what it actually does."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While those terms are being recurrrently used to qualify aesthetically pleasing code, our survey has also noticed specific domains which programmers refer to, consciously or unconsciously, as they try to build up metaphors to communicate the nature of their aesthetic appreciation: by referring to science, literature and architecture. The summoning of each of these domains, sometimes simultaneously, does, however, only select specific parts in order to adapt it to the felt potential of source code. Literature brings linguistics, but not narrative; science brings formalism and engineering, but not numbers nor universality; architecture brings planning and construction, but not socio-economic purposes or end-usage. These domains are thus better understood as the different parts of a Venn diagram, as practictionners attempt to define what it means to do what they do well. This was confirmed by our investigation into the connections between craft and code, looking specifically at the knowledge transmission in both non-code and code craftsmanship, the place that informal knowledge holds in such transmission, and in the value judgment produced by the craftsperson as to whether a work is a good one."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The region of overlap of these different domains has to do, it turns out, with cognitive clarity. Whether wrangling with the linguistic tokens in literary exercises, structuring various pieces of code such that their organization is robust and communicated to others such that it allows for future maintenance and expansion, or writing lines of code in a certain way in order to hint at some larger concepts and ideas beyond their immediate execution result, these domains are all mentioned in their ability to vehiculate ideas from one individual to another—as opposed to, say, elicit self-reflection or sublime physical pleasure. It seems that beautiful code is then both functional code and understandable code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The next chapter explores this idea futher, building on the emerging development in aesthetics of integrating both function and cognition, two fundamental aspects of software, as a criteria for an aesthetic experience."}],"tag":"paragraph","value":""}],"tag":"root","value":""}],"tag":"include","value":"ideals.tex"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Understanding source code"}],"tag":"chapter","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"chap:understanding"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Aesthetics in source code are thus primarily related to cognitive load. In the previous chapter, we have highlighted a focus on understanding when it comes to aesthetic standards: whether obfuscating or illuminating, the process of acquiring a mental model of a given object is a key determinant in the value judgment as applied to source code. In this chapter, we focus on the reason for which such a cognitive load exists in the first place, before surveying the means—both linguistic and mechanistic—that programmers deploy in order to relieve such a load."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This is related to one of the essential features of software: it must be"},{"children":[{"children":null,"tag":"literal","value":"functional"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". As mentioned in our discussion of the differences between source code and software in the introduction, source code is the latent description of what the software will ultimately"},{"children":[{"children":null,"tag":"literal","value":"do"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Similarly to sheet music, or to cooking recipes"},{"children":[{"children":null,"tag":"literal","value":"Recipes are a recurring example taken to communicate the concept of an algorithm to non-experts"},{"children":[{"children":null,"tag":"literal","value":"zeller_algorithms_2020"}],"tag":"citation","value":""}],"tag":"footnote","value":"103"},{"children":null,"tag":"literal","value":", they require to be put into action in order for their users (musicians and cooks, respectively) to assess their value. Therefore, buggy or dysfunctional software is going to be of less value than correct software"},{"children":[{"children":null,"tag":"literal","value":"hill_what_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", regardless of how aesthetically pleasing the source is."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The assessment of whether a piece of software functions correctly is essentially an assessment of whether what the software does is what the software is supposed to do, which in turn entails knowing what it does, what it is supposed to do, and being able to tell whether these two things are aligned. Any value judgment regarding the aesthetics of the source code at hand would be subject to whether or not the software functions correctly, and such judgment is rendered moot if that software does not work."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"After deciding on a benchmark to assess the functionality of the source code at hand (understanding what it should be doing), one must then determine the actual behavior of the source code at hand once it is executed (understanding what it is actually doing). This chapter examines what goes into understanding source code. The first part will lay out our definition of understanding, presenting it as a dual phenomenon, between formalism and contextualism. Starting with 20"},{"children":[{"children":null,"tag":"literal","value":"th"}],"tag":"superscript","value":""},{"children":null,"tag":"literal","value":"century epistemology, we will see that a dominantly rational, cognitivist perspective on the nature of understanding, as it has been hailed by theoretical computer science research, shows its limits when confronted with practice. Having highlighted this tension, we then turn to how understanding the phenomenon of computation specifically, both on an ontological level, and on a psychological level. The ontological approach will show some of the features of software give it the status on an \"abstract artifact\", making it a complex object to grasp; the psychological approach will show how such a comprehension takes place for a varity of programmers. Finally, we will conclude with the means that programmers deploy to grasp the concepts at play with software: starting from metaphors used by the general public, we will go down this ladder of abstraction in order to reach the technical apparatuses used in the development and inspection of source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The main questions that this chapter addresses are the following: given a certain nature of knowledge acquisition, what are some of the features of computers that make them hard to grasp, and what kind of techniques are deployed in order to address these hurdles and in order to understand what the code is actually doing. This will have us investigate the relationship of knowing and doing, the nature of computation (what is software?) and its relationship to the world as it appears to us (how does modelling and abstraction translate a problem domain into software?), and the cognitive scaffoldings set up to facilitate that task."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Formal and contextual understandings"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:formal-contextual-understandings"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This section focuses on our definition of understanding—the process of acquiring a working knowledge of an object. Such definition relies on two main aspects: a formal, abstract understanding, and a more subjective, empirical one. We will see how the former had some traction in computer sciences circles, while the second gained traction in programming circles. To support those two approaches, we first trace back the genealogy of understanding in theoretical computer science, before outlining how concrete experience and situatedness outline an alternative tradition."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Between formal and informal"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:formal-informal"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Theoretical foundations of formal understanding"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:theoretical-understanding"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"To start this inquiry, we go back to the early 20"},{"children":[{"children":null,"tag":"literal","value":"th"}],"tag":"superscript","value":""},{"children":null,"tag":"literal","value":"century in Cambridge, when the theoretical roots of modern computation were being laid by both philosophers of logic and mathematicians, such as Bertand Russell, Ludwig Wittgenstein, and Alan Turing, as they worked on the formalization of thinking."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Wittgenstein, in particular, bases his argumentation in his"},{"children":[{"children":null,"tag":"literal","value":"Tractatus Logico-philosophicus"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"on the fact that much of the problems in philosophy are rather problems of understanding between philosophers—if one were to express oneself clearly, and to articulate one's through clear, unambiguous language, a common conclusion could be reached without much effort:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Most questions and propositions of the philosophers result from the fact that we do not understand the logic of our language."},{"children":[{"children":null,"tag":"literal","value":"wittgenstein_tractatus_2010"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Language and logic are, as we see here, closely connected. Articulated in separate points and sub-points, his work conjugates aphorisms with logical propositions depending on one another, developing from broader statements into more specific precisions. Wittgenstein hints at the intertwining of language as a form of logic, and as logic as a form of language. In this, he follows in the footsteps of Gottfried Leibniz's"},{"children":[{"children":null,"tag":"literal","value":"Ars Combinatoria"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", insofar Leibniz views reasoning and inter-subjective understanding as a formal problem. A universal, and universally-understandable language, called a"},{"children":[{"children":null,"tag":"literal","value":"characteristica universalis"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"could resolve any misunderstanding issues. Quoted by Russell, Leibniz notes that:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"If we had it [a characteristica universalis], we should be able to reason in metaphysics and morals in much the same way as in geometry and analysis"},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"If controversies were to arise, there would be no more need of disputation between two philosophers than between two accountants ["},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"] Let us calculate."},{"children":[{"children":null,"tag":"literal","value":"russell_logical_1950"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Centuries after Leibniz's declaration, Wittgenstein presents a coherent, articulated theory of meaning through the use of mathematical philosophy, and logic, and his work fits with that of Russell"},{"children":[{"children":null,"tag":"literal","value":"In his"},{"children":[{"children":null,"tag":"literal","value":"Principia Mathematica"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", he lays out a theory of logical expression"}],"tag":"footnote","value":"104"},{"children":null,"tag":"literal","value":"and Frege"},{"children":[{"children":null,"tag":"literal","value":"The"},{"children":[{"children":null,"tag":"literal","value":"Begriffschrift"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"similarly attempts to constitute a language in which all scientific statements could be evaluated"},{"children":[{"children":null,"tag":"literal","value":"korte_frege_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", while"},{"children":[{"children":null,"tag":"literal","value":"Über Sinn und Bedeutung"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"clarifies the semantic uncertainties between a specific sentence and how it means, or refers to a concept"}],"tag":"footnote","value":"105"},{"children":null,"tag":"literal","value":"; even though these are different theories, they are part of a similar endeavour to find a basis od formal propositions through which one could establish truth-values. Such attempt was a direct influence in the work on mathematician Alan Turing—who studied at Cambridge and followed some of Wittgenstein's lectures—, as he developed his own formal system for solving complex, abstract mathematical problems, manifested as a symbolic machine"},{"children":[{"children":null,"tag":"literal","value":"turing_computable_1936"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The design of the Turing machine is a subsequent step engagement with the question of understanding in the philosophical sense, as well as in the practical sense—a formal proof to the"},{"children":[{"children":null,"tag":"literal","value":"Entscheidungsproblem"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"solved mechanically. Indeed, it is a response to the questions of translation (of a problem) and of implementation (of a solution). This formal approach to instructing machines to operate on logic statements then prompted Turing to investigate the question of intelligence and comprehension in"},{"children":[{"children":null,"tag":"literal","value":"Computing Machinery and Intelligence"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In it, he translates the hazy term of \"thinking\" machines into that of \"conversing\" machines, conversation being a practical human activity which involves listening, understanding and answering (i.e. input, process and output)"},{"children":[{"children":null,"tag":"literal","value":"turing_computing_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This conversational test, which has become a benchmark for machine intelligence, does rely on the need for a machine to"},{"children":[{"children":null,"tag":"literal","value":"understand"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"what is being said. Throughout the article, however, Turing does not yet address the need for a purely formal approach of whether or not a problem can be translated, as Leibniz would have it, into atomistic symbols which would be provided as an input to a digital computer. Such a process of translation would rely on a formal approach, similar to that laid out in the"},{"children":[{"children":null,"tag":"literal","value":"Tractatus Logico-philosophicus"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", or on Frege's formal language described in the"},{"children":[{"children":null,"tag":"literal","value":"Begriffschrift"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Following a cartesian approach, the idea in both authors is to break down a concept, or a proposition, into sub-propositions, in order to recursively"},{"children":[{"children":null,"tag":"literal","value":"although it was not called as such at the time"}],"tag":"footnote","value":"106"},{"children":null,"tag":"literal","value":"establish the truth of each of these sub-propositions, and then re-assembled to deduce the truth-value of the original proposition. While Turing focuses on the philosophical and moral arguments to the possibility for machines to think, he does address the issue of artificial intelligence."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"With these sophisticated syntactic systems developed a certain approach to cognition, as Turing clearly establishes parallels between the digital computer and the human brain. We now turn to the form of these systems, looking at how their form addresses the problem of clearly understanding and operating on mathematical and logical statements."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Logical calculus, as the integration of the symbol into relationships of many symbols formally takes place through two stylistic mechanisms, the"},{"children":[{"children":null,"tag":"literal","value":"symbol"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and the"},{"children":[{"children":null,"tag":"literal","value":"list"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Each of the works by Frege, Russell and Wittgenstein quoted above are structured in terms of lists and sub-lists, representing the stylistic pendant to the epistemological approach of related, atomistic propositions and sub-propositions. A list, far from being an innate way of organizing information in humans, is a particular approach to language: extracting elements from their original, situated existence, and reconnecting ways in very rigorous, strictly-defined ways. As Jack Goody writes in"},{"children":[{"children":null,"tag":"literal","value":"The Domestication of the Savage Mind"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":","}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"[List-making] ["},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"] is an example of the kind of decontextualization that writing promotes, and one that gives the mind a special kind of lever on 'reality'."},{"children":[{"children":null,"tag":"literal","value":"goody_domestication_1977"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As inventories, early textbooks, administrative documents as public mnemotechnique, the list is a way of taking symbols, pictorial language elements in order to re-assemble them to reconstitute the world, then re-assemble it from blocks, following an assumption that the world can always be decomposed into smaller, discreete and"},{"children":[{"children":null,"tag":"literal","value":"conceptually coherent"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"units (i.e. symbols). The list, Goody continues, establishes clear-cut boundaries, they are simple, they are abstract and discontinuous."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Being based on some singular, symbolical entity, applying logical calculus to lists and their symbols, and doing so in a computing environment, becomes the next step in exploring these tools for thinking. Indeed, the engineering development of digital computers in post-war United States as described in"},{"children":[{"children":null,"tag":"literal","value":"subsec:software-developers"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", allowed for the putting into practice of these languages, in the budding field of artificial intelligence (AI)."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Practical attempts at implementing formal understanding"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:practical-understanding"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This putting into practice took the form of subsequent programming languages, relying on a certain conception of human cognition—abstract, logical, as shown above."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"IPL, the Information Processing Language, was created by Allen Newell, Cliff Shaw and Herbert A. Simon.  The idea was to make programs understand and solve problems, through \"the simulation of cognitive processes\""},{"children":[{"children":null,"tag":"literal","value":"newell_information_1964"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". IPL achieves this with the symbol as its fundamental construct, which at the time was still largely mapped to physical addresses and cells in the computer's memory, and not yet decoupled from hardware."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A link between the ideas exposed in the writing of the mathematical logicians and the actual design and construction of electrical machines activating these ideas, IPL was originally designed to demonstrate the theorems of Russell's"},{"children":[{"children":null,"tag":"literal","value":"Principia Mathematica"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", along with a couple of early AI programs, such as the"},{"children":[{"children":null,"tag":"literal","value":"Logic Theorist"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", the"},{"children":[{"children":null,"tag":"literal","value":"General Problem Solver"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". More a proof of concept than a versatile language, IPL was then quickly replaced by LISP as the linguistic means to express intelligence in digital computers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"LISP ("},{"children":[{"children":null,"tag":"literal","value":"LIst Processor"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":") was developed in 1956 was Joseph McCarthy"},{"children":[{"children":null,"tag":"literal","value":"McCarthy coined the phrase"},{"children":[{"children":null,"tag":"literal","value":"Artificial Intelligence"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"during the 1956 Dartmouth workshop"}],"tag":"footnote","value":"107"},{"children":null,"tag":"literal","value":". The base structural elements of LISP are not symbols, but lists (of symbols, of lists, of nothing), and they themselves act as symbols (e.g. the empty list)"},{"children":[{"children":null,"tag":"literal","value":"mccarthy_history_1978"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". By manipulating those lists recursively—that it, processing something in terms of itself—Lisp shows a tendency for a formal system to separate itself from the problem domain. This is facilitated by its atomistic and relational structure: in order to solve what it has do, it evaluates each symbol and traverses a tree-structure in order to find a terminal symbol, without the explicit need to refer to an external table, for instance."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This sort of heuristic is quite similar to the approach suggested by Noam Chomsky in his"},{"children":[{"children":null,"tag":"literal","value":"Syntactic Structures"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", where he posits the tree structure of language, as a decomposition of sentences until the smallest conceptually coherent parts (e.g. Phrase -> Noun-Phrase + Verb-Phrase -> Article + Substantive + Verb-Phrase). The style is similar, insofar as it proposes a general ruleset (or the at least the existence of one) in order to construct complex structures through simple parts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Through its direct manipulation of conceptual units upon which logic operations can be executed, LISP became the language of AI, an intelligence conceived first and foremost as logical understanding. The use of LISP as a research tool culminated in the"},{"children":[{"children":null,"tag":"literal","value":"SHRDLU"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"program, a natural language understanding program built in 1968-1970 by Terry Winograd which aimed at tackling the issue of situatedness—AI can understand things abtractly through logical mathematics, but can it apply these rules within a given context? The program had the particularity of functioning with a \"blocks world\" a highly simplified version of a physical environment—bringing the primary qualities of abstraction into solid grasp. The computer system was expected to take into account the rest of the world and interact in natural language with a human, about this world ("},{"children":[{"children":null,"tag":"literal","value":"Where is the red cube?"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"Pick up the blue ball"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", etc.). While incredibly impressive at the time,"},{"children":[{"children":null,"tag":"literal","value":"SHDRLU"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"'s success was nonetheless relative. It could only succeed at giving barely acceptable results within highly symbolic environments, devoid of any noise. In 2004, Terry Winograd writes:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"There are fundamental gulfs between the way that SHRDLU and its kin operate, and whatever it is that goes on in our brains. I don’t think that current research has made much progress in crossing that gulf, and the relevant science may take decades or more to get to the point where the initial ambitions become realistic."},{"children":[{"children":null,"tag":"literal","value":"nilsson_quest_2009"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This attempt, since the beginning of the century, to enable thinking, clarify understanding and implement it in machines, had first hit an obstacle. The world, also known as the problem domain, exhibits a certain complexity which did not seem to be easily translated into singular, atomistic symbols. Around the same time, however, was developed another approach to formalizing the intricacies of cognition."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Warren McCullough's seminal paper,"},{"children":[{"children":null,"tag":"literal","value":"A logical calculus of the ideas immanent in nervous activity"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", co-written with Walter Pitts, offers an alternative based on the embodiment of cognition. They present a connection between the systematic, input-output procedures dear to cybernetics with the predicate logic writing style of Russell and others"},{"children":[{"children":null,"tag":"literal","value":"mcculloch_logical_1990"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This attachment to input and output, to their existence in complex, inter-related ways, rather than self-contained propositions is, interestingly, rooted in his activy as a literary critic"},{"children":[{"children":null,"tag":"literal","value":"Even at the Chicago Literary book club, he argues for a more sensuous approach to cognition:"},{"children":[{"children":null,"tag":"literal","value":"\"In the world of physics, if we are to have any knowledge of that world, there must be nervous impulses in our heads which happen only if the worlds excites our eyes, ears, nose or skin.\""}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"mcculloch_delusion_1953"}],"tag":"citation","value":""}],"tag":"footnote","value":"108"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Going further in the processes of the brain, he indeed finds out, in another paper with Letvinn and Pitts"},{"children":[{"children":null,"tag":"literal","value":"lettvin_what_1959"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", that the organs through which the world excites the brain"},{"children":[{"children":null,"tag":"literal","value":"are themselves"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"agents of process, activating a series of probabilistic techniques, such as noise reduction and softmax, to provide a signal to the brain which isn't the untouched, unary,"},{"children":[{"children":null,"tag":"literal","value":"symbolical"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"version of the signal input by the external stimuli, and nor does it seem to turn it into such."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We see here the development of a theory for a situated, embodied stance towards cognition, which would ultimately resurface through the rise of machine learning via convoluted neural networks in the 2000s"},{"children":[{"children":null,"tag":"literal","value":"nilsson_quest_2009"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In it, the senses are as essential as the brain for an understanding—that is, for the acquisition, through translation, of a conceptual model which then enable deliberate and successful action. It seems, then, that there are other ways to know things than to rely on description through formal propositions."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A couple of decades later, Abelson and Sussman still note, in their introductory textbook to computer science, the difficulty to convey meaning mechanically:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Understanding internal definitions well enough to be sure a program means what we intend it to mean requires a more elaborate model of the evaluation process than we have presented in this chapter."},{"children":[{"children":null,"tag":"literal","value":"abelson_structure_1979"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While formal notation is able to enable digital computation, it nonetheless proved to be limited when it came to accurately and expressively  conveying meaning. This limitation, of being able to express formally what we understand intuitively (e.g."},{"children":[{"children":null,"tag":"literal","value":"what is a chair?"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"A question addressed by Joseph Kosuth in his artwork"},{"children":[{"children":null,"tag":"literal","value":"One and Three Chairs"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", 1965"}],"tag":"footnote","value":"109"},{"children":null,"tag":"literal","value":") appeared as computers applications left the domain of logic and arithmetic, and were applied to more social domains."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"After having seen the possibilities and limitations of making machines understand through the use of formal languages, and the shift offered by taking into account sensory perception as a possible locus of cognitive processes, we now turn to these ways of knowing that exist in humans in a more embodied capacity."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Knowing-what and knowing-how"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:knowing-what-how"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"1953 saw a radical posture change from one of the logicians whose work underpinned AI research, briefly before the start of these attempts to implement artificial intelligence in digital computers. This was the publication of Wittgenstein's"},{"children":[{"children":null,"tag":"literal","value":"Philosophical Investigations"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In his second work, he disown his previous approach to language as seen in the"},{"children":[{"children":null,"tag":"literal","value":"Tractatus Logico-philosophicus"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and favors a more contextual, use-centered frame. Rather than what knowledge is, he looks at how knowledge is acquired and used; while (formal) lanuage was previously defined as the exclusive means to translation concepts in clearly understandable terms, he broadens his perspective in the"},{"children":[{"children":null,"tag":"literal","value":"Inquiries"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"by stating that language is"},{"children":[{"children":null,"tag":"literal","value":"\"the totality of language and the activities with which it is intertwined\""}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and that"},{"children":[{"children":null,"tag":"literal","value":"\"the meaning of a word is its use within language\""}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"wittgenstein_recherches_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", noting context and situatedness as a important factors in the understanding process."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At first, then, it seemed possible to make machines understand through the use of formal languages. The end of the first wave of AI development, as a branch of computation specifically focused on cognition, have shown some limits to this approach.  We now turn to theories which support this approach of an embodied and contextualized knowing, complemented by a constructivist approach to building an understanding."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Knoweldge and situation"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:knowledge-situation"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As hinted at by the studies of McCullough and Levitt, understanding a situation doesn't rely exclusively on abstract logical processes, but also on the processes involved in grasping this situation, such as, in their case, peripheral vision processing. It is not just what things are, but how they are, and how they are"},{"children":[{"children":null,"tag":"literal","value":"perceived"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", which matters. Different means of inscription and description do tend to have an impact on the ideas communicated and understood."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In his book"},{"children":[{"children":null,"tag":"literal","value":"Making Sense: Cognition, Computing, Art and Embodiment"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Simon Penny refutes the so-called unversality of formulating cognition as a formal problem, and develops an alternative history of cognition, akin to Michel Foucault's archeology of knowledge. Drawing on the works of authors such as William James, Jakob von Uexküll and Gilbert Ryle, he refutes the Cartesian dualism thesis which acts as the foundation of AI research"},{"children":[{"children":null,"tag":"literal","value":"penny_making_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". A particular example of the fallacy of dualism, is the use of the phrase"},{"children":[{"children":null,"tag":"literal","value":"implementation details"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", which he recurringly finds in the AI literature, such as Herbert Simon's"},{"children":[{"children":null,"tag":"literal","value":"The Sciences of the Artificial"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"simon_sciences_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The phrase refers to the gap existing between the statement of an idea, of an algorithm, and a procedure, and its concrete, effective and functional manifestation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"For instance, pseudo-code is a way to sketch out an algorithmic procedure, which might be considered agnostic when it comes to implementation details. One can consider the pseudo-code in"},{"children":[{"children":null,"tag":"literal","value":"code:nielsen_chalktalk"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", which describes a procedure to recognize a free-hand drawing and transform it into a known, formalized glyph. Disregarding the implementation details means disregarding any reality of an actual system: the operating system (e.g. UNIX or MSDOS), the input mechanism (e.g. mouse, joystick, touch or stylus), the rendering procedure (e.g. raster or vector), or the programming language (e.g. JavaScript or Python)."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/pseudocode.txt"}],"tag":"code","value":"text"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Example of pseudo-code attempting to reverse-engineer a software system, ignoring any of the actual implementation details, taken from"},{"children":[{"children":null,"tag":"literal","value":"nielsen_working_2017"}],"tag":"citation","value":""}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:nielsen_chalktalk"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Refuting the idea that pseudo-code is all that is necessary to communicate and act upon a concept, Penny  argues on the contrary that information is relativistic and relational; relative to other pieces of information (intra-relation) and related to contents and forms of presenting this relation (extra-relation). Pseudo-code will only ever make sense in a particular implementation context, which then affects the product."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"He then follows Philip Agre's statement that a theory of cognition based on formal reason works only with objects of cognition whose attributes and relationships can be completely characterized in formal terms; and yet a formalist approach to cognition does not prove that such objects exist or, if they exist, that they can be useful. Uses of formal systems in artificial intelligence in specific, and in cognitive matters in general, is yet another instance of the map and the territory problem—it only goes so far."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Beyond the syntax of formal logic, there are different ways to transmit cognition in actionable form, depending on the form, the audience and the purpose. In terms of form, a symbol system of formal logic is only one of many possibilities for systems of forms. In his"},{"children":[{"children":null,"tag":"literal","value":"Languages of Art"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Nelson Goodman elaborates a theory of symbol systems, which he defines as formal languages composed of syntactic and semantic rules"},{"children":[{"children":null,"tag":"literal","value":"goodman_languages_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", further explored in"},{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-cognition"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":". Logical notation exists along with music, painting, poetry and prose. What follows, argues Goodman, is that all these formal languages involve an act of"},{"children":[{"children":null,"tag":"literal","value":"reference"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Through different means (exemplification, denotation, resemblance, representation), formal systems act as sets of symbols which can denote or exemplify or refer to in more complex and indirect ways, yet always between a sender and a receiver"},{"children":[{"children":null,"tag":"literal","value":"Understood as the eponymous entities  in Jakobsen's model of communication functions."}],"tag":"footnote","value":"110"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Communication, as the transfer of meaning from one individual to one or more other individuals, does not exclusively rely on the use of mathematical based use of formal languages. From Goodman to Goody, the format of representation also affords differences in what can be thought and imagined. Something that was always implicit in the arts—that representation is a complex and ever-fleeting topic—is shown more recently in Marchand-Zañartu and Lauxerois's work on pictural representations made by philosophers, visual artists and novelists (such as Claude Simon's sketches for the structure of his novel"},{"children":[{"children":null,"tag":"literal","value":"La Route des Flandres"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", shown in"},{"children":[{"children":null,"tag":"literal","value":"graphic:routedesflandres"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":") "},{"children":[{"children":null,"tag":"literal","value":"marchand-zanartu_32_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". How specific domains, from mathematics to visual arts and construction, engage in the relation between form and cognition is further adressed in chapter"},{"children":[{"children":null,"tag":"literal","value":"chap:beauty"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"width=\\textwidth,height=\\textheight,keepaspectratio"},{"children":null,"tag":"literal","value":"routedesflandres.png"}],"tag":"image","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Tentative d'organisation visuelle pour le roman La Route des Flandres, années 1960 - Claude Simon, écrivain"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"graphic:routedesflandres"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""}],"tag":"center","value":""}],"tag":"paragraph","value":""}],"tag":"figure","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Going beyond logical notation, we have seen that there are other conceptions of knowledge which take into account the physical, social and linguistic context of an action. Nonetheless, these can still be systematized, as Goodman highlights in his investagation of referential systems, with a focus on reference of the ideas at hand."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Constructing knowledge"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:constructing-knowledge"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"There are multiple ways to express an idea: on can use formal notation or draft a rough sketch with different colors. These all highlight different degrees of expression, but one particular way can be considered problematic in its ambition. Formal languages rely on the assumption, that all which can be known can ultimately be expressed in unambiguous terms. First shown by Wittgenstein in the two main eras various eras of his work, we know focus on the ways of knowing which cannot be explicited."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"First of all, there is a separation between"},{"children":[{"children":null,"tag":"literal","value":"knowing-how"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"knowing-that"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"; the latter, propositional knowledge, does not cover the former, practical knowledge, as shown by Ryle"},{"children":[{"children":null,"tag":"literal","value":"ryle_concept_1951"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Perhaps one of the most obvious example of this duality is in the failure of Leibniz to construct a calculating machine, as told by Matthew L. Jones in his book"},{"children":[{"children":null,"tag":"literal","value":"Reckoning with Matter"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". In it, he traces the history of philosophers to solve the problem of constructing a calculating machine, a problem which would ultimately be solved by Charles Babbage, with the consequences that we know"},{"children":[{"children":null,"tag":"literal","value":"jones_reckoning_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Jones depicts Leibniz in his written correspondence with watchmaker Ollivier, in their fruitless attempt to construct Leibniz's design; the implementations details seem to elude the German philosopher as he refers to the \"confused\" knowledge of the nonetheless highly-skilled Parisian watchmaker. The (theoretical) plans of Leibniz do not match the (concrete) plans of Ollivier."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These are two complementary approaches to the knoweldge of something: to know"},{"children":[{"children":null,"tag":"literal","value":"what"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"constructing calculating machine entails and knowing"},{"children":[{"children":null,"tag":"literal","value":"how"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to construct such a machne. In the fact that Ollivier could not communicate clearly to Leibniz what his technical difficulties, we can see an instance of something which would be theorized centuries later by Michael Polanyi as"},{"children":[{"children":null,"tag":"literal","value":"tacit knowledge"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", knowledge which cannot be entirely made explicit."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Polanyi, as a scientist himself, starts from another assumption: we know more than we can tell. In his eponymous work, he argues against a positivist approach to knowledge, in which empirical and factual deductions are sufficient to achieve satisfying epistemological work. What he proposes, derived from"},{"children":[{"children":null,"tag":"literal","value":"gestalt"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"psychology, is to consider some knowledge of an object as the knowledge of an integrated set of particulars, of which we already know some features, by virtue of the object existing in an external approach. This integrated set, in turn, displays more properties than the sum of its parts. While formal notation suggests that the combination of formal symbols does not result in additional knowledge, Polanyi rather argues, against Descartes, that relations and perceptions do result in additional knowledge."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The knowledge of a problem is, therefore, like the knowing of unspecifiables, a knowing of more than you can tell."},{"children":[{"children":null,"tag":"literal","value":"polanyi_knowing_1969"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Rooted in psychology, and therefore in the assumption of the embodimed of the human mind, Polanyi posits that all thought is incarnate, that it lives by the body and by the favour of society, hence giving it a physio-social dimension. This confrontation with the real-world, rather than being a strict hurdle that has to be avoided or overcome, as in the case of SHRDLU above, becomes one of the two poles of cognitive action. Knowledge finds its roots and evaluation in concrete situations, as much as in abstract thinking. In the words of Cecil Wright Mills, writing about his practice as a social scientist research,"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Thinking is a continuous struggle between conceptual order and empirical comprehensiveness."},{"children":[{"children":null,"tag":"literal","value":"MillsC.WrightCharlesWright2000Tsi"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Polanyi's presentation of a form of knowledge following the movement of a pendulum, between dismemberment and integration of concepts finds an echo in the sociological work of Mills: a knowledge of some objects in the world happens not exclusively through formal descriptions in logical symbol systems, but involves imagination and phenomenological experience—wondering and seeing. This reliance on vision—starting by recognizing shapes, as Polanyi states—directly implies the notion of aesthetic assessment, such as a judgement of typical or non-typical shapes. He does not, however, immediately elucidate how aesthetics support the formation of mental models at the basis of understanding, only that this morphology is at the basis of higher order of represenations."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Seeing, though, is not passive seeing, simply noticing. It is an active engagement with what is being seen. Mills's quote above also contains this other aspect of Polanyi's investigation of knowledge, and already present in Ollivier's relation with Leibniz: knowing through doing."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This approach has been touched upon from a practical programmer's perspective in section"},{"children":[{"children":null,"tag":"literal","value":"subsec:craft-knowledge"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", through a historical lens but it does also posses theoretical grounding. Specifically, Harry Collins offers a deconstruction of the Polanyi's notion by breaking it down into"},{"children":[{"children":null,"tag":"literal","value":"relational"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"somatic"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"collective"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"tacit knowledges"},{"children":[{"children":null,"tag":"literal","value":"collins_tacit_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". While he lays out a strong approach to tacitness of knowledge (i.e. it cannot be communicated at all), his distinction between relational and somatic is useful here"},{"children":[{"children":null,"tag":"literal","value":"His definition of collective tacit knowledge touches on the knowledge present in any living species and is impossible to ever be explicited, and is therefore out of scope here."}],"tag":"footnote","value":"111"},{"children":null,"tag":"literal","value":". It is possible to think about knowledge as a social construct, acquired through social relations: learning the linguo of a particular technical domain, exchanging with peers at conferences, imitating an expert or explaining to a novice. Collective, unspoken agreements and implicit statements of folk wisdom, or implicit demonstrations of expert action are all means of communication through which knowledge gets replicated across subjects."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Concurrently, somatic tacit knowledge tackles the physiological perspective as already pointed out by Polanyi. Rather than knowledge that exists in one's interactions with others, somatic tacit knowledge exists within one's physical perceptions and actions. For instance, one might base one's typing of one's password strictly on one's muscle memory, without thinking about the actual letters being typed, through repetition of the task. Or one might be spotting a cache bug which simply requires a machine reboot, due to experience machine lifecycles, package updates, networking behaviour. Not completely distinct from its relational pendant, somatic knowledge is acquired through experience, repetition and mimeomorphism—replicating actions and behaviours, or the instructions, often under the guidance of someone more experienced."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We started our discussion of understanding by defining it as the acquisition of the knowledge of a object—be it a concept, a situation, an individual or an artfefact,, which is accurate enough that it allows us to predict the behaviour and to interact with such object. Within this defintion, one could take the example of a human discussion as a demonstration of advanced understanding, as something that is both situated, and formalized."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Theories of how individuals acquire understanding (how they come to know things, and know conceptual representations of things), have been approached from an explicit perspective, and an implicit one. In the rationalist, logical philosophical tradition, we have seen that the belief that meaning can be rendered unambiguous through the use of specific notation. This has led to the development of logic and computer science, as this meaning got mechanized. Explicit understanding is therefore the theoretical lineage of computation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"However, as we have seen in the first hurdles of artificial intelligence research, explicit specification of meaning falls short of handling everyday tasks which humans would consider to be menial. This has led us to consider a more implicit approach to understanding, in which it is acquired by tacit means. Particularly, we have identified this tacit knowledge as relying on a social component, as well as on a somatic component."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code, as a formal system with a high dependence of context, intent and implementation, mobilizes both approaches to understanding. Before we dive deeper about how these two modes of understanding are mobilized at the end of this chapter, we now turn to what makes computation a cognitively complex object, and what are some cognitive reactions that humans display in situations where they have to understand, and work with, software."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Understanding computation"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:understanding-computation"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the previous chapter, we have laid out the groundwork by showing that there are multiple ways to understand something. We now turn to the thing we want to understand. What makes it challenging to understand computation?"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"First, we will inquire into some distinguishing features of software in terms of levels of abstractions, and in terms of types of complexity. This will highlight some of the theoretical properties that make it hard to understand, such as its relation to hardware, its relation to a specification, and its relation to time and space."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Then, we will shift our perspective to a more abstract point of view, investigating the ontological status of software. This will highlight how software exists as an"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", simultaneously on the ideal, practical and physical plane."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, we will conclude this section by looking specifically at the source code component of software, and how programmers deploy strategies to understand it. Approaching it from a cognitive and psychological perspective, this will give us a better picture of the concrete process of understanding source code—a process which aesthetics are primarily intended to affect."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Software complexity"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:software-complexity"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software exhibits several particularities, which result in a compex whole—meaning that software possesses several independent components which interact with each other in non-trivial, and non-obvious ways. This subsection focuses on these particularies; that is, on the"},{"children":[{"children":null,"tag":"literal","value":"properties"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of software, and hence how these properties manifest themselves concretely, leading to those complex interactions. We will start by looking at the different levels at which software exists, before turning to the different kinds of complexity which make software hard to grasp."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Levels of software"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:levels-software"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"One of the essential aspects of software is that of"},{"children":[{"children":null,"tag":"literal","value":"implementation"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Implementation is the realization of a plan, the concrete manifestation of an idea, and therefore hints at a first tension in software's multiple facets. It can happen through individuation, instantation, exemplification and reduction"},{"children":[{"children":null,"tag":"literal","value":"rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". On the one side, there is what we will call here"},{"children":[{"children":null,"tag":"literal","value":"ideal"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"software, often existing only as a shared mental representation by humans (not limited to programmers), or as printed documentation, as a series of specifications, etc. On the other side, we have"},{"children":[{"children":null,"tag":"literal","value":"actual"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"software, which is manifested into lines of code, written in one or more particular languages, and running with more or less bugs."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The relationship between the"},{"children":[{"children":null,"tag":"literal","value":"ideal"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and the"},{"children":[{"children":null,"tag":"literal","value":"actual"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"versions of the same software is not straightforward. Ideal software only provides an intent, a guidance towards a goal, assuming, but not guaranteeing, that this goal will be reached. A popular engineering saying is that complements this approach by stating that:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"In theory, there is no difference between theory and practice. In practice, there is."},{"children":[{"children":null,"tag":"literal","value":"Sometimes mis-attributed to Richard P. Feynman or Albert Einstein, but traced to Benjamin Brewster, writing in the Yale Literary Magazine of 1882."}],"tag":"footnote","value":"112"}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Actual software, as most programmers know, differs greatly from its ideal version, largely due to the process of implementation, translating the purpose of the software from natural and diagrammatic languages, into programming languages, from what it should do, into what it actually does."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Writing on the myths of computer science, James Moor"},{"children":[{"children":null,"tag":"literal","value":"moor_three_1978"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"allows us to think through this distinction between ideal and practical along the lines of the separation between a theory and a model. The difference between a model and a theory is that both can exist independently of one another—one can have a theory for a system without being able to model it, while one can also model a system using"},{"children":[{"children":null,"tag":"literal","value":"ad hoc"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"programming techniques, instead of a coherent theory."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Most of the practice of programmers (writing and reading code for the purposes of creating, maintaining and learning software) depends on closing this gap between the ideal and the practical existences of software."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The third level at which software exists is that of hardware. While the ideal version of software is presented in natural language, diagrams or pseudo-code, and while the practical version of software exists as executable source code, software also exists at a very physical level—that of transistors and integrated circuits."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The distinction between software and hardware has been examined thoroughly"},{"children":[{"children":null,"tag":"literal","value":"kittler_there_1997,chun_sourcery_2008,rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", but never strictly defined. Rather, the distinction between what is hardware and what is software is relative to where one draws the line: to a front-end web developer writing JavaScript, the browser, operating system and motherboard might all be considered hardware. For a RISC-V assembly programmer, only the specific CPU chip might be considered hardware, while the operating system being implemented in C, itself compiled through Assembly, would be considered software. A common definition of hardware, as the physical elements making up the computer system, overlooks the fact that software itself is, ultimately, physical changes in the electrical charge of the components of the computer."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software can be characterized the dynamic evolution of logical processes, described as an ideal specification in natural languages, as a practical realization in programming languages, and in specific states of hardware components. Furthermore, the relations between each of these levels is not straightforward: the ideal and the practical can exist independently of each other, while the practical cannot exist independently of a machine"},{"children":[{"children":null,"tag":"literal","value":"Even if that machine is a"},{"children":[{"children":null,"tag":"literal","value":"virtual machine"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", further complicating the boundary between hardware and software"}],"tag":"footnote","value":"113"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Types of complexity"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:types-complexity"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Along with different levels of existence needed to be taken into account by the programmer, software also exhibits specific kinds of complexity. Our definition of complexity will be the one proposed by Warren Weaver. He defines problems of (organized) complexity as those which involve dealing simultaneously with a sizable number of factors which are interrelated into an organic whole"},{"children":[{"children":null,"tag":"literal","value":"weaver_science_1948"}],"tag":"citation","value":""},{"children":[{"children":null,"tag":"literal","value":"As opposed to disorganized complexity, which are dealt with statistical tools."}],"tag":"footnote","value":"114"},{"children":null,"tag":"literal","value":". Specifically, there are four different types of software complexity that we look at: conceptual complexity, modeling complexity, temporal complexity and spatial complexity."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Conceptual complexity, as refered to by Lando et. al. in their ontology of computer programs, addresses the necessity to model complex objects at different abstraction levels"},{"children":[{"children":null,"tag":"literal","value":"lando_general_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". As mentioned above, software exists at least on three somewhat distinct levels: the ideal, the practical, and the physical. This means that software, in its source code representation, should be able to provide the programmer with tools to engage with its intended function and its actual function at each of these levels. For instance, comments might relate to the ideal behaviour of the software, function declarations to its practical behaviour, while macro definitions can point to the specific hardware on which the code is run."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Additionally, conceptual complexity involves the distinction of the different elements of a computer program at the source code level, and keep track of their ontological status, sometimes independently from its level of existence. This distinction should be made notwithstanding the naming conventions assigned by different platforms, vendors, or programming languages, and rather based on ontological properties of the elements at hand. For instance, the distinction between"},{"children":[{"children":null,"tag":"literal","value":"endurants"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"perdurants"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"by Lando et. al. focuses on the temporal dimension of software components (i.e. a data structure declaration has a different temporal property than a function call). Here we have a second, complementary frame to that of the levels of existence, through which we can analyze source code; being somewhat related but an exact mapping of one another."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Modeling complexity addresses the hurdles in translating a non-discrete, non-logical object, event, or action, into a discreete, logical software description through source code. Indeed, the history of software development is also the history of the extension of the application of software, and the hurdles to be overcome in the process. From translation of natural languages"},{"children":[{"children":null,"tag":"literal","value":"poibeau_machine_2017"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", to education"},{"children":[{"children":null,"tag":"literal","value":"watters_teaching_2021"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"or psychological treatment"},{"children":[{"children":null,"tag":"literal","value":"weizenbaum_computer_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", it seems that problems that seem somehat straightforward from a human perspective become more intricate once the time for implementation has come."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"we have seen so far the complexities tied to the conceptualization and modelization of the components of software. Two other significant contributions to the cognitive load of understanding software happen are more closely related to the concrete execution of the software—temporal and spatial complexity."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Temporal complexity relates to the discrepancy between the way the computer was first thought of —i.e. as a Turing machine which operates linearly, on a one-dimensional tape—and further technological developments. Originally, the Turing machine would involve the ability for the head of the machine to jump at different locations. This meant that the execution and reading of a program would be non-linear, jumping from one routine to another across the source code. Such an entanglement is particulary obvious in Ben Fry's Distellamap series of visualizations of source code ("},{"children":[{"children":null,"tag":"literal","value":"graphic:pacman-visualization"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"represents the execution of the source code for the arcade game Pac-Man), and led to Edsger W. Dijkstra's statement on the harmfulness of such jumps on the cognitive abilities of programmers."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"options","value":"width=\\textwidth,height=\\textheight,keepaspectratio"},{"children":null,"tag":"literal","value":"distellamap_pacman.png"}],"tag":"image","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Visualization of the execution of Pac-Man's source code"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"graphic:pacman-visualization"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""}],"tag":"figure","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Later on, the introduction of multi-core architecture for central processing units in the late 2000s has enabled the broad adoption of multithreading and threaded programming. As a result, source code has transformed from a single non-linear execution to a multiple non-linear process, in which several of these non-linear executions are happening in parallel. Keep tracking of what is executing when on which resource is involved in problems such as"},{"children":[{"children":null,"tag":"literal","value":"race conditions"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", when understanding the scheduling of events (each event every e.g. 1/18000000th of a second on a 3.0 Ghz CPU machine) becomes crucial to ensuring the correct behaviour of the software."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Conversely, the locii of the execution of software creates contributes to those issues. Software can be (dis-)located across multiple files on a single machine, on multiple processes on a single machine, or on multiple processes on multiple machines (on a local-area or wide-area network)"},{"children":[{"children":null,"tag":"literal","value":"berry_philosophy_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This further fragments the interface to the object of understanding. For instance, the asynchronicity of requesting and processing information from distinct processes is a spatial separation of code which has temporal implications (e.g. due to network latency)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software, then, exhibits certain properties which make it difficult to understand, from conception to application: software in the real-world involves implementing concepts that lose in translation, interfacing the world through discreete representations, and following the execution of these representations through space and time, as software executes more and more in a distributed and parallel fashion."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Software ontology"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:software-ontology"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Now that we have clarified some of what software complexity consists of, we will frame these difficulties in a philosophical context, more specifically the philosophy of technology. We will investigate how these complexities can be seen as stemming from the nature of technology itself, and how this allows us to reconnect it to aesthetic perception. Before moving back to practical inquiries into how specific individuals engage with this nature, this section will help provide a theoretical backdrop, framing technology as a relational practice, complementing other modes of making sense of and taking action on the world. This conceptual framework will start with an investigation into the denomination of software as an"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", followed by an analysis of technology as a specific mode of being, and concluding on how it is related to an aesthetic mode of being."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Software as abstract artifact"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:abstract-artifact"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"When he coins the phrase"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Nurbay Irmak addresses software partly as an abstract object, similar in his sense to Platonic entities"},{"children":[{"children":null,"tag":"literal","value":"Like Joseph Kosuth's aforementioned trio of chairs.."}],"tag":"footnote","value":"115"},{"children":null,"tag":"literal","value":". Nonetheless, he also grants that software holds spatio-temporal properties"},{"children":[{"children":null,"tag":"literal","value":"irmak_software_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Indeed, software does need to exist as an implementation, in the form of source code"},{"children":[{"children":null,"tag":"literal","value":"suber_what_1988"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"; this implies that software is composed of files, has a beginning (start) and an end (exit), meanwhile also representing ideas of structure and procedure which go beyond these limitations of being written to a disk and having an execution time. Typically, the physical aspects of software (its manifestation as source code) can be changed"},{"children":[{"children":null,"tag":"literal","value":"A process called"},{"children":[{"children":null,"tag":"literal","value":"refactoring"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"116"},{"children":null,"tag":"literal","value":"without changing any of the ideas expressed by the software"},{"children":[{"children":null,"tag":"literal","value":"A phenomenon one can also observe in natural languages, in which one can radically change a syntax without drastically changing the semantics of a sentence."}],"tag":"footnote","value":"117"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Complementing Irmak, Colburn's phrasing is that of a"},{"children":[{"children":null,"tag":"literal","value":"concrete abstraction"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", an oxymoron which echoes the tensions denoted by the concept of an abstract artifact."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"He grounds these tensions in the distinction between a medium of execution (a—potentially virtual—machine) and a medium of description (source code). He considers that, while any high-level programming language is already the result of layers of abstraction, such language gets reduced to the zeroes and ones input to the central processing unit"},{"children":[{"children":null,"tag":"literal","value":"colburn_philosophy_2000"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Here, he sees the abstraction provided by languages ultimately bound to the concrete state of being of hardware and binary. And yet, if we follow along along his reasoning, these representations of voltage changes into zeroes and ones are themselves abstractions over yet another concrete, physical event."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Writing on computational artefacts, of which software is a subset, Raymond Turner formalizes this specificity of in a three-way relationship. Namely, abstract artefact A is an implementation in medium M of the definition F. For instance, concerning the medium:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Instead of properties such as"},{"children":[{"children":null,"tag":"literal","value":"made from carbon fiber"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", we have properties such as"},{"children":[{"children":null,"tag":"literal","value":"constructed from arrays in the Pascal programming language, implemented in Java"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". "},{"children":[{"children":null,"tag":"literal","value":"turner_computational_2018"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This metaphor provides an accurate but limited account of the place of source code within the definition of software: the Java implementation is itself a definition implemented in a specific bytecode, etc. Nonetheless, source code is that which gives shape to the ideas immanent in software—through a process of concretization—and which hides away the details of the hardware—through abstraction. This metaphor of"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"thus helps to clarify the tensions within software, and to locate the specific role of source code within the different moving parts of definition, medium and model."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Recalling that software has a somewhat unique relatoin between its"},{"children":[{"children":null,"tag":"literal","value":"functional"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"properties (i.e. purpose that are intended to be achieved through their use) and"},{"children":[{"children":null,"tag":"literal","value":"structural"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"ones (physical configuration which are involved in the fullfilment of the functional purpose)"},{"children":[{"children":null,"tag":"literal","value":"turner_computational_2018"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", it remains nonetheless a kind of technology. As such, it also holds some of the specifities of this lineage, into which we can extend our inquiry."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Software as a relational object"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:software-relational"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The technological object underwent a first qualitative shift during the European Industrial Revolution, and a second one with the advent of computing technologies. The status of its exact nature is therefore a recent object of inquiry. Here, we will start from Gilbert Simondon's understanding of technology as a"},{"children":[{"children":null,"tag":"literal","value":"mode"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in order to ultimately contrast it with the"},{"children":[{"children":null,"tag":"literal","value":"aesthetic mode"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"According to Simondon, the technical object is a relation between multiple structures and the result of a complex operation of various knowledges"},{"children":[{"children":null,"tag":"literal","value":"simondon_mode_1958"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", some scientific, some practical, some social, some material. The technical object is indeed a scientific object, but also a social object and an artistic object at the same time. Differentiated in its various stages (object, individual, system), it is therefore considered as relational, in that its nature changes through its dependance and influence on its environment."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From this relational standpoint, one could complement Bernard Stiegler's statement that technology is a dynamic of organized, but inorganic matter"},{"children":[{"children":null,"tag":"literal","value":"stiegler_technics_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", if we are to consider inorganized matter to include social influences, personal practices, and forms of tacit and explicit knowledges. That is, the ambiguity of the technical object is that it extends beyond itself as an object, entering into a relation with its surrounding environment, including the human individual which makes use of it. Up until the invention of the clock, technology remained bound to practical matter. With the invention of seconds, its action reached into another domain—that of mechanical operation on abstract ideas"},{"children":[{"children":null,"tag":"literal","value":"mumford_technics_1934"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The domain of abstract ideas was hitherto reserved to different modes than technology: that of religion and philosophy, and technology holds a particularly interesting relation with these two. According to Simondon, philosophy followed religion as a means of relating to, and making sense of, the abstract such the divine and the ethical. Tracing back the genesis of the technological object, e writes that the technical mode of existence is therefore just another mode through which the human can relate to the world, similar to the religious, the philosophical, and the aesthetic mode"},{"children":[{"children":null,"tag":"literal","value":"simondon_mode_1958"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While both technology, religion and philosophy are based on theoretical knowledge, technology is specifically manifested in practice, and while it is manifested in ethics, in religion. Technology is thus seen as the combination of a theory of knowledge and a theory of action. Such a combination has since been extended into the abstract domain, leading to computers, as a form of technology through which"},{"children":[{"children":null,"tag":"literal","value":"meaning is mechanically realized"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Simondon complements the technical and the religious modes with the aesthetic mode, and as such counter-balances the apparent split between technics and religion by striving for unity and totality, for the balance between the objective and the subjective. Yet, rather than being a monadic unity of a single principle, Simondon considers the aesthetic mode as a unifying a network of relationships, a form of organizing Stiegler's inorganized matter. He further argues that the aesthetic mode goes beyond taste and subjective preference, into a fundamental aspect of the way in which human beings relate to the world around them. An aesthetic object therefore acquires the property of being beautiful by virtue of its relationships, of its connections between the subject and the objective, between one's history and one's perceptions, and the various elements of the world, and the actions of the individual. Finally, the aesthetic thought when related to the technical object consists in preparing the communication between different communities of users, between different perspectives on the world, and different modes of action upon this world. An aesthetic object can therefore be seen as a nexus of relationships found in its environment, echoing how Goodman considers an aesthetic language as way for worldmaking."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software is therefore a manifestation of technology as both knowledge and action. Furthermore, it also enables ways to act mechanically on knowledge and ideas, an affordance named"},{"children":[{"children":null,"tag":"literal","value":"epistemic action"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"by David Kirsh and Paul Maglio"},{"children":[{"children":null,"tag":"literal","value":"kirsh_distinguishing_1994"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". They define epistemic actions as actions which facilitate thinking through a particular situation or environment, rather than having an immediate functional effect on the state of the world. As technology changes the individual's relationship to the world, software does so by being the dynamic notion of a state of a process"},{"children":[{"children":null,"tag":"literal","value":"rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", ever evolving around a fixed structure, and by changing the conceptual understanding of said world. Such examples of world related to the environment in which software exists, e.g. the social environment, or hardware environment, or the environment which has been recreated within software. David M. Berry investigates this encapsulation of world in his"},{"children":[{"children":null,"tag":"literal","value":"Philosophy of Software"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":":"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"The computational device is, in some senses, a container of a universe (as a digital space) which is itself a container for the basic primordial structures which allow further complexification and abstraction towards a notion of world presented to the user."},{"children":[{"children":null,"tag":"literal","value":"berry_philosophy_2011"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Software-as-world is the material implementation of a proposed model, itself derived from a theory. It therefore primarily acts at the level of"},{"children":[{"children":null,"tag":"literal","value":"episteme"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", sometimes even limiting itself to it"},{"children":[{"children":null,"tag":"literal","value":"Functional programming languages take pride in the fact that they have no effect on the world around them, being composed exclusively of so-called"},{"children":[{"children":null,"tag":"literal","value":"pure functions"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and no external side-effects, or input/output considerations"}],"tag":"footnote","value":"118"},{"children":null,"tag":"literal","value":". Paradoxically, it is only through peripherals that software can act as a mechanical technology in the industrial sense of the word."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Along with software's material and theoretical natures (i.e. in contemporary digital computers, it consists of electrons, copper and silicium and of logical notations), another environment remains—that of the intent of the humans programming such software. Since it can be so many things, it might not be exactly clear what a specific piece of software, manifested in source code, is exactly about."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Indeed, thinking through the function of computational artefacts, Turner states that it is"},{"children":[{"children":null,"tag":"literal","value":"agency"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"which determines what the function is: and he defines agency as the resolution of the difference between the specification (intent-free, external to the program) and semantic interpretation (intent-rich, internal to the programmer)"},{"children":[{"children":null,"tag":"literal","value":"turner_computational_2018"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In order to understand a computer program, to understand how it exists in mutliple worlds, and how it represents the world, we need to give it meaning. To make sense of it, a certain amount of interpretation is requiredin relation to that of the computer's—such that the question \"what does a Turing machine do?\" has"},{"children":[{"children":null,"tag":"literal","value":"n+1"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"answers. 1 syntactic, and"},{"children":[{"children":null,"tag":"literal","value":"n"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"semantic (e.g. however many interpretations as there can be human interpreters)"},{"children":[{"children":null,"tag":"literal","value":"rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". In his investigation into what software is, Suber corroborates:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"This suggests that, to understand software, we must understand intentions, purposes, goals, or will, which enlarges the problem far more than we originally anticipated. ["},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"] We should not be surprised if human compositions that are meant to make machines do useful work should require us to posit and understand human purposiveness. After all, to distinguish"},{"children":[{"children":null,"tag":"literal","value":"literature"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"from noise requires a similar undertaking."},{"children":[{"children":null,"tag":"literal","value":"suber_what_1988"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In conclusion, we have seen that while software can be given the particular status of an"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", these tensions are shared across technological objects. Technology, as a combination of a theory of knowledge and a theory of action, as an interface to the world and a recreation of the world, is furthermore related to other modes of existence—and in particular the aesthetic mode. All of these tensions and paradoxes, from the various levels of existence, the various types of complexities, the different kinds of actions and interpretations that it allows, contribute to the cognitive hurdles encountered when attempting to understanding software."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, programmers, have been understanding software as long as they have been writing and reading it. We now turn to understanding how programmers understand software, through a empirical perspective of the psychology of programming.."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"The psychology of programming"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:psychology-programming"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"How programmers deal with such a complex object as software has been a research topic which appeared much later than software itself. This field aims at understanding how programmers process code, and with which level of success, and under which conditions. How do they build up their understanding(s), in order to afford appropriate modification, re-use or maintenance of the software? What cognitive abilities do they summon, and what kind of technical apparatuses play a role in this process? Specifically, we will see how hard it is to answer these questions, and how diversity and multiplicity are recurrent patterns in sketching out answers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Epistemic actions thus contribute to reducing the kinds of complexities involved with software. Concretely, this involves the creation of mental models of the software system with which the indvidual is interacting. In their work on computer-enabled cognitive skills, Kirsh and Maglio develop on the use of epistemic actions:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"More precisely, we use the term epistemic action to designate a physical action whose primary function is to improve cognition by:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"reducing the memory involved in mental computation, that is, space complexity;"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"reducing the number of steps involved in mental computation, that is, time complexity;"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"item","value":""},{"children":null,"tag":"literal","value":"reducing the probability of error of mental computation, that is, unreliability."}],"tag":"paragraph","value":""}],"tag":"list","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"kirsh_distinguishing_1994"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Psychological studies of programming practices have been focused on the identification and analysis of these mental models, as well as on their optimization through experimental devices, and the social behaviour of programmers within a context of practice"},{"children":[{"children":null,"tag":"literal","value":"weinberg_psychology_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Mental models, as kinds of internal symbolic representation of an external reality, are a rigorous, personal and conceptual structure. They are related to knowledge, since the construction of accurate and useful mental models through the process of understanding underpins knowledge acquisition. However, mental models need not be correlated with empirical truth, due to their personal nature, but are extensive enough to be described by formal (logical or diagrammatical) means. Mental models can be informed, constructed or further qualified by the use of metaphors, but they are nonetheless more precise than other cognitive structures such as metaphors—a mental model can be seen as a more specific instance of a conceptual structure."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The earliest studies of how computer programmers understand the code they are presented with consisted mostly in pointing out the methodological difficulties in doing so"},{"children":[{"children":null,"tag":"literal","value":"sheil_psychological_1981,shneiderman_measuring_1977"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This is mainly due to three parameters. First, programming is an intertwined combination of notation, practices, tasks and management, each of which have their own impact on the extent to which a piece of source code is correctly understood, that it is hard to clearly establish the impact of each of these. Second, program comprehension is strongly influenced by practice—the skill level of the programmer therefore also influences experimental conditions. Third, these early studies have found that programmers have organized knowledge bases, if informal. This means that, while programmers demonstrate epistemic mastery, they are limited in their ability to explain the workings of such ability—that is, the constitution and use of their own epistemic models, which she calls knowledge maps."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Shifting to qualitative interviews, rather than quantitative and performative assessments, Marian Petre and Alan Blackwell attempted in their 1992 study to identify these mental models and their uses. They asked 10 expert programmers from North America and Europe to describe the thought process in source code-related problem-solving and design solutions in code. The main conclusion of their study is that, beyond the fact that each programmer had slightly different descriptions of their mental process, there a some commonalities to what is happening in someone's thoughts as they start to design software. The behaviour is dynamic, but controlled; the resolution of that behaviour was also dynamic, with some aspects coming in and out of focus that the will of the programmer, providing more or less uncertainty, level of details and fuzziness on-demand; and those images co-existed with other images, such that one representation could be compared with another representation of a different nature"},{"children":[{"children":null,"tag":"literal","value":"petre_glimpse_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Finally, while most imagery was non-verbal, all programmers talked about the need to have elements of this imagery labelled at all times, hinting at a relationship between syntax and semantics to be translated into source code. While this study was an investigation into the design of code, before any writing happens, one of the limitations is that it did not investigate the understanding of code, which takes places once the writing has been done (by oneself, or someone else), and the code now needs to be read."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Francoise Détienne, in her study of how computer programmers design and understand programs"},{"children":[{"children":null,"tag":"literal","value":"detienne_software_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", defines the activity of designing and understanding programs in activating"},{"children":[{"children":null,"tag":"literal","value":"schemas"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", mental representations that are abstract enough to encompass a wide use (web servers all share a common schema in terms of dealing with requests and responses), but nonetheless specific enough to be useful (requests and responses are qualitatively different subsets of the broader concept of inputs and outputs). An added complexity to the task of programming comes with the one of the dual nature of the mental models needing to be activated: the computer's actions and responses are comprised of the prescriptive (what the computer should do) to the effective (what the computer actually does). In order to be appropriately dealt with, then, programmers must activate and refine mental models of a program which resolves this tension."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In programming, within a given context—which includes goals and heuristics—, elements are being perceived, processed through existing knowledge schemas in order to extract meaning. Starting from Kintsch and Van Dijk's approach of understanding text"},{"children":[{"children":null,"tag":"literal","value":"kintsch_model_1978"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", Détienne nonetheless highlights some differences with natural language understanding. In program texts, she finds, there is an entanglement of the plan, of the arc, of the tension, which does not happen so often in most of the traditional narrative text. A programmer can jump between lines and files in a non-linear, explorative manner, following the features of computation, rather than textuality. Program texts are also dynamic, procedural texts, which exhibit complex causal relations between states and events, which need to be kept track of in order to resolve the prescriptive/effective discrepancies. Finally, the understanding of program text is first a general one, which only subsequently applies to a particular situation (a fix or an extension needing to be written), while narrative texts tend to focus on specific instances of protagonists, scenes and descriptions, leading to broad thematic appreciation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Conversely, a similarity in understanding program texts and narrative texts is that the sources of information for understanding either are: the text itself, the individual experience and the broader environment in which the text is located (e.g. technical, social). Building on Chomsky's concepts, the activity of understanding in programming can be seen as understanding the"},{"children":[{"children":null,"tag":"literal","value":"deep structure"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"of a text through its"},{"children":[{"children":null,"tag":"literal","value":"surface structure"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"chomsky_aspects_1965"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". One of the heuristics deployed to achieve such a goal is looking out for what she calls"},{"children":[{"children":null,"tag":"literal","value":"beacons"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", as thematic organizers which structure the reading and understanding process. For instance, in traditional narrative texts, beacons might be represented by section headings, or the beginning or end of paragraphs. However, one of the questions that her study hasn't answered specificall, how the specific surface structure in programming results in the understanding of the deep structure—in other terms, what is the connection between source code syntax, programmer semantics and program behavior."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Due to its relation to text, syntax and semantics, it has often been assumed by programmers and researchers that reading and writing code is akin to reading and writing natural languag prose. Additional recent research in the cognitive responses to programming tasks, conducted by Ivanova et. al., do not appear to settle the question of whether programming is rather dependent on language processing brain functions, or on functions related to mathematics (which do not rely on the language part of the brain)"},{"children":[{"children":null,"tag":"literal","value":"ivanova_comprehension_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", but contributes empirical evidence to that debate. They conclude that, while language processing might not be one of the essential ways that we process code—excluding the"},{"children":[{"children":null,"tag":"literal","value":"code is language"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"hypothesis—, it also does not rely on exclusively mathematical functions. Stimulating in particular the so-called multi-demand system, it seems that programming is a polymorphous activity involving multiple exchanges between different brain functions. What this implies, though, is that neither literature, linguistics nor mathematics should be the only lens through which we look at code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In a way, then, programming is a sort of fiction, in that the pinpointing of its source of existence is difficult, and in that it affords the experience of imagining contents of which one is not the source, and of which the certainty of isn't defined. Both programming and fiction suggest surface-level guiding points helping the process of constructing mental models as a sort of conceptual representation. It is also something else than fiction, in that it deals with concrete issues and rational problems"},{"children":[{"children":null,"tag":"literal","value":"more often than not, a pestering bug"}],"tag":"footnote","value":"119"},{"children":null,"tag":"literal","value":", and that it provides a pragmatic frame for processing representations, in which assumptions stemming from burgeoning mental models can be easily verified or falsified, through the taking of epistemic actions. It might then be appropriate to treat it as such, simultaneously fiction and non-fiction, as knowledge and action, mathetmatic and artistic. Indeed, it is also an artistic activity which, in Goodman's terms, might be seen as"},{"children":[{"children":null,"tag":"literal","value":"an analysis of [artistic] behavior as a sequence of problem-solving and planning activities.\""}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"goodman_basic_1972"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Remains the interpretation issue mentioned above: the interpretation of the machine is different from the interpretation of the human, of which there are many, and therefore what also needs to be intepreted is the intent of the author(s). Reading is then akin to constructing a"},{"children":[{"children":null,"tag":"literal","value":"cognitive cartography"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", allowing for an experience to be made intelligible, sensible, and verifiable, and when an experience is made sensible is when it enters the realm of the aesthetic. In a very immediate understanding of aesthetics, we conclude on the role of form in cognition in those psychological studies. One of the focus was on demonstrating the impact that formal arrangement has on program comprehension"},{"children":[{"children":null,"tag":"literal","value":"oman_typographic_1990,oliveira_systematic_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Spacing, alignment, syntax highlighting and casing are all parameters which have an impact on the readability, and therefore understandability of code. The next section therefore looks at two ways in which meaning can be extracted from intention and source code; this means how individuals use metaphors to communicate complex ideas, and how they use computational tools in order to navigate program texts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The fact that software exists between the state of being conceptually designed and materially implemented predates software itself, and can be observed in modern technological developments at large. Furthermore, these complexities are echoed in how programmers evoke their experience of either designing or, comprehending code. They have shown to use multiple cognitive abilities, without being strictly limited to narrative, or mathematic frames of understanding, and making use of notions of scale and focus to disentangle complexity. For the remaining section of this chapter, we will focus on two specific means that contribute to this process of building a mental model of software-as-source code. Based on the reports that programmers use mental images and play with dynamic mental structures to comprehend the functional and structural properties of software; we thus inquire into the role that metaphors play in translating computational concepts into ones which can be grasped by an individual. Conversely, in response to the role of indentation, typography and navigation, we will see how cognition is also distributed in a programmers' tools."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Means of understanding"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:means-understanding"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Drawing on the ambivalence of software's existence—both concrete and abstract—we now investigate the means deployed to graps software on both of these levels. As we have seen in empirical studies, programmers resort to both conceptual techniques to visualize and grasp a piece of software, along with more practical and technical tools. In this spirit, we will look at the ubiquity of metaphors in computing,  both from users and programmers, and how they act as a cognitive mechanism. We will also look at how cognitive tools can be manifested concretely though the extension of mind through software tools, and particularly on the role of"},{"children":[{"children":null,"tag":"literal","value":"Integrated Development Environments"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(IDEs). This will establish the research ground of the subsequent chapters, in which we establish aesthetics as one of the cognitive tools used by programmers."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Metaphors in computation"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:metaphor-computation"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This part of the thesis relies on the work of George Lakoff and Mark Johnson, and on that of Paul Ricoeur, due to their requalification of the nature and role of metaphor in the 20th century. While Lakoff and Johnson's approach to the conceptual metaphor will serve a basis to explore metaphors in as a cognitive means across software and narrative, I also argue that Ricoeur's focus on the tension of the"},{"children":[{"children":null,"tag":"literal","value":"statement"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"rather than primarily on the"},{"children":[{"children":null,"tag":"literal","value":"word"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"will help us better understand some of the aesthetic manifestations and workings of software metaphors. Following a brief overview of their contributions, I examine the various uses of metaphor in software."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Theoretical background"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:metaphors-background"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We depart here from the most commonly used definition of metaphor: that of labeling one thing in terms of another, thereby granting additional meaning to the subject at hand. Our approach here will also bypass some of the more minute distinctions made between metonymy (in which the two things mentioned are already conceptually closely related), comparison (explicitly assessing differences and similarities between two things, often from a value-based perspective) and synechdoche (representing a whole by a subset), as they all relate to a larger, more contemporary definition of the concept."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Such a definition stems from Lakoff and Johsnon's seminal work through which they develop a theory of conceptual metaphors by highlighting their essential dependence on pre-existing cognitive structures, which we associate with already-understood concepts. The metaphor maps a source domain (made up of cognitive structure(s)) to a target domain. In the process, they extend the field of applicability of metaphors from the strictly literary to the broadly cultural: metaphors work because each of us has some conception of those domains involved in the metaphorical process. Metaphors rely in part on a static understanding, resulting in a fixed meaning from the application of a given source to a given target. Some of these sources are called"},{"children":[{"children":null,"tag":"literal","value":"schemas"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and are defined enough to not be mistaken for something else, but broad enough to allow for multiple variants of itself to be applied to various targets"},{"children":[{"children":null,"tag":"literal","value":"lakoff_metaphors_1980"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", providing both diversity and reliability. As we will see below, their approach allows us to focus not just on textual objects, but on the vast range of metaphors used also in computing-related environments. Given that the source of the metaphor should be well-grounded, with as little invariablity as possible, in order to qualify a potentially ill-defined target domain, we see how this is a useful mechanism to provide an entrypoint to end users and novice programmers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Going beyond the role of metaphors manifested in expressions such as"},{"children":[{"children":null,"tag":"literal","value":"the desktop"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"the mouse"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", or"},{"children":[{"children":null,"tag":"literal","value":"the cloud"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", we will explore Lakoff's understanding of the specifically poetic metaphor further below as preliminary work to assess the linguistic component of computing—source code. For now, to complement his broadening of the metaphorical field, we turn to Paul Ricoeur's assessment of it."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Writing in"},{"children":[{"children":null,"tag":"literal","value":"The Rule of Metaphor"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", Ricoeur operates two shifts which will help us better assess not just the inherent complexity of program texts, but the ambivalence of programming languages as well. His first shift regards the locus of the metaphor, which he saw as being limited to the single word—a semiotic element—to the whole sentence—a semantic element"},{"children":[{"children":null,"tag":"literal","value":"ricoeur_rule_2003"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This operates in parallel with his attention to the"},{"children":[{"children":null,"tag":"literal","value":"lived"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"feature of the metaphor, insofar it exists in a broader, vital, experienced context"},{"children":[{"children":null,"tag":"literal","value":"Similar to Simondon's characterization of the technological mode as a mode of relations."}],"tag":"footnote","value":"120"},{"children":null,"tag":"literal","value":". Approaching the metaphor only through words is counterproductive because words refer back to \"contextually missing parts\"—they are eminently overdetermined, polysemic, and belong to a wider network meaning than a single, one-to-one relationship"},{"children":[{"children":null,"tag":"literal","value":"As Ricoeur sees it being considered in the traditional, Aristotelician sense of the term."}],"tag":"footnote","value":"121"},{"children":null,"tag":"literal","value":". Looking at it from the perspective of the sentence brings this rich network of potential meanings and narrows the scope for interpretation. As we have briefly touched upon in the previous section when reading"},{"children":[{"children":null,"tag":"literal","value":"self_inspect.rb"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", all of the evocative meaning of the poem isn't contained exclusively in each token, and the power of the whole is greater than the sum of its parts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Secondly, Ricoeur inspects a defining aspect of a metaphor by the"},{"children":[{"children":null,"tag":"literal","value":"tensions"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"it creates. His analysis builds from the polarities he identifies in discourse between event (time-bound) and meaning (timeless), between individual (subjective, located) and universal (applicable to all) and between sense (definite) and reference (indefinite)"},{"children":[{"children":null,"tag":"literal","value":"For the extent to which source code can be considered discourse has been discussed, see: Cox and McLean,"},{"children":[{"children":null,"tag":"literal","value":"Speaking Code"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"cox_speaking_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"122"},{"children":null,"tag":"literal","value":". The creative power of the metaphor is its ability to both create and resolve these tensions, to maintain a balance between a literal interpretation, and a metaphorical one—between the immediate and the potential, so to speak. Tying it to the need for language to be fully realized in the lived experience, he poses metaphor as a means to creatively redescribe reality. One of the realities needing to be described is the foreign land of computing."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Metaphors for end-users"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:metaphors-users"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"It is interesting to consider that the first metaphor in computing might be concommitant with the first instance of modern computing—the Turing"},{"children":[{"children":null,"tag":"literal","value":"machine"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". While Turing machines are widely understood as being manifested into what we call digital computers (laptops, tablets, smartphones, etc.), and thus definitely within the realm of machines, the Turing machine isn't strictly a machine"},{"children":[{"children":null,"tag":"literal","value":"per se"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Rather, it is more accurately defined as a mathematical model which in turn defines an abstract machine. Indeed, computers cannot be proved or assumed to be machines, because their terminology comes from logic, textual, or discursive traditions (e.g. reference, statement, names, recursion, etc.) and yet they are still"},{"children":[{"children":null,"tag":"literal","value":"built"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"smith_origin_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Humans can be considered Turing machines (and, in fact, one of the implicit requirements of the Turing machine is that, given enough time and resources, a human should be able to compute anything that the Turing machine can compute), and non-humans can also be considered Turing machines"},{"children":[{"children":null,"tag":"literal","value":"See research in biological computing, using DNA and protein to perform computational tasks"}],"tag":"footnote","value":"123"},{"children":null,"tag":"literal","value":". Debates in computer science related to the nature of computing"},{"children":[{"children":null,"tag":"literal","value":"rapaport_philosophy_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"have shown that computation is far from being easily reduced to a simple mechnical concern, and the complexity of the concept is perhaps why we ultimately revert to metaphors in order to better grasp them."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Jumping ahead to the 1980s, these uses of metaphors became more widespread and entered public discourse once personal computing became available to ever larger audiences. With the release of the XEROX Star, features of the computer which were until then described as data processing were given a new life in entering the public discourse. The Star was seminal since it introduced technological innovations such as a bitmapped display, a two-button mouse, a window-based display including icons and folders. For instance, the desktop metaphor relies on previous understanding of what a desktop is, and what it is used for in the context of physical office-work; since early personal computers were marketed for business applications (such as the Star), these metaphors built on the broad cognitive structures of the user-base in order to help them make sense of this new tool. Paul DuGay, in his cultural study of the Sony Walkman, makes a similar statement when he describes the Sony Walkman, a never-before-seen compound of technological innovations, in terms of pre-existing, and well-established technologies"},{"children":[{"children":null,"tag":"literal","value":"gay_doing_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The icon of a floppy disk for writing data to disk, the sound of wrinkled paper for removing data from disk, the designation of a broad network of satellite, underground and undersea communications as a cloud, these are all metaphors which help us make a certain sense of the broad possibilities brought forth by the computing revolution"},{"children":[{"children":null,"tag":"literal","value":"wyatt_danger_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Even the"},{"children":[{"children":null,"tag":"literal","value":"clipboard"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", presented to the user to copy content across applications, does not believe at all like a real clipboard"},{"children":[{"children":null,"tag":"literal","value":"barrera_how_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The work of metaphors takes on an additional dimension when we introduce the concept of interfaces. As permeable membranes which enable (inter)actions between the human and the machine, they are essential insofar as they allow for various kinds of agency, based on different degrees of understanding. Departing from the physically passive posture of the reader towards an active engagement with a dynamic system, interfaces highlight even further the cognitive role of the metaphor. These depictions of things-as-other-things influence the mental model which we build of the computer system we engage in. For instance, the prevalent windows metaphor of our contemporary desktop and laptop environments obfuscates the very concrete action of the CPU (or CPUs, in the case of multi-core architecture) of executing one thing at a time, except at speeds which cannot be intuitively grasped by human perception. Alexander Galloway 's work on interfaces as metaphorical representations suggests a similar concern when he bases it on Jameson's theory of cognitive mapping. While Jameson uses it in a political and historical context, the heuristic is nonetheless useful here: cognitive mapping is the process by which the individual subject situates himself within a vaster, unrepresentable totality, a process that corresponds to the workings of ideology. Substituting ideology with the computer"},{"children":[{"children":null,"tag":"literal","value":"The relation between which has been explored by Galloway, Chun, Holmes and others, and is particularly apparent in how an operating system is designated in French:"},{"children":[{"children":null,"tag":"literal","value":"système d'exploitation"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"124"},{"children":null,"tag":"literal","value":", we can see how such a process helps make sense of the unthinkable, of that which is too complex to grasp and therefore must be put into symbols (words, icons, sounds, etc.)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Moving away from userland, in which most of these metaphors exist, we now turn to examine the kinds of metaphors that are used by programmers and computer scientists themselves. Since the sensual reality of the computer is that it is a high-frequency vibration of electricity, one of the first steps taken to productively engage with computers is to abstract it away. The word"},{"children":[{"children":null,"tag":"literal","value":"computer"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"itself can be considered as an abstraction: originally used to designate the women manually inputting the algorithms in room-scale mainframes, the distinction between the machine and its operator was considered to be unnecessary. The relation between metaphor and abstraction is a complex one, but we can say that metaphorical thought requires abstraction, and that the process of abstraction ultimately implies designating one thing by the name of another (a woman by a machine's, or a machine by a woman's), being able to use it interchangeably, and therefore lowering the cognitive friction inherent to the process of specification, freeing up mental resources to focus on the problem at hand"},{"children":[{"children":null,"tag":"literal","value":"chun_software_2005"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This need to get away from the specificities of the machines has been one of the essential drives in the development of programming languages. Since we cannot easily and intuitively deal with binary notation to represent complex concepts, programming helps us deal with this hurdle by presenting things in terms of other things. Most fundamentally, we represent binary signs in terms of English language (e.g. from binary to Assembly). This is, again, by no means a metaphorical process, but rather an encoding process, in which tokens are being separated and parsed into specific values, which are then processed by the CPU as binary signs. Still, this abstraction layer offered by programming languages allowed us to focus on"},{"children":[{"children":null,"tag":"literal","value":"what"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"we want to do, rather than on"},{"children":[{"children":null,"tag":"literal","value":"how"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to do it. The metaphorical aspect comes in when the issue of interpretation arises, as the possibility to deal with more complex concepts required us to grasp them in a non-rigorous way, one which would have a one-to-one mapping between concepts. Allen Newell and Herbert A. Simon, in their 1975 Turing Award lecture, offer a good example of symbolic manipulation relates inherently to understanding and interpretation:"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"In none of [Turing and Church's] systems is there, on the surface, a concept of the symbol as something that"},{"children":[{"children":null,"tag":"literal","value":"designates"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The complement to what he calls the work of Turing and Church as automatic formal symbol manipulation is to be completed by this process of"},{"children":[{"children":null,"tag":"literal","value":"interpretation"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", which they define simply as the ability of a system to designate an expression and to execute it. We encounter here one of the essential qualities of programming languages: the ambivalence of the term"},{"children":[{"children":null,"tag":"literal","value":"interpretation"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". A machine interpretation is clearly different from a human interpretation: in fact, most people understand binary as the system comprised of two numbers, 0 and 1, when really it is intepreted by the computer as a system of two distinct signs (red and blue, Alex and Max, hot and cold, etc.). To assist in the process of human interpretation, metaphors have played a part in helping programmers construct useful mental representations related to computing. These metaphors can go both ways: helping humans understand computing concepts, and to a certain extent, helping computers understand human concepts."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Programmer-facing metaphors"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:metaphors-programmers"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Perhaps one of the first metaphors a programmer encounters when learning about the discipline is that which states that the function is like a kitchen recipe. You specify a series of instructions which, given some input ingredients (arguments), result in an output result (return value). The difficulty in explaining, in that context, the need for a"},{"children":[{"children":null,"tag":"literal","value":"void"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"keyword to individuals with limited experience and knowledge of how programming works is a good example of the non-straightforwardness of computing concepts. Similarly, the use of the term"},{"children":[{"children":null,"tag":"literal","value":"server"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is conventionally associated and represented as a machine sending back data when asked for it, when really it is nothing but an executed script or process running on said machine. Incidentally, a server is also a style of software architecture, to which we will return later."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Another instance of synbolic use relying on metaphorical interpretation can be found in the word"},{"children":[{"children":null,"tag":"literal","value":"stream"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Originally designating a flow of water within its bed, it has been gradually accepted as designating a continuous flow of contingent binary signs."},{"children":[{"children":null,"tag":"literal","value":"Memory"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", in turn, stands for record, and is stripped down of its essentially partial, subjective and fantasized aspects usually highlighted in literary works (perhaps"},{"children":[{"children":null,"tag":"literal","value":"volatile memory"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"gets closer to that point). Finally,"},{"children":[{"children":null,"tag":"literal","value":"objects"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", which came to prominence with the rise of object-oriented programming, have only little to do with the physical properties of objects, with no affordance for being traded, for acting as social symbols, for gaining intrinsic value, but rather the word is used as such for highlighting its boundedness, and ability to be manipulated without interfering with other objects."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Most of these designations, stating a thing in terms of another aren't metaphors in the full-blown, poetic sense, but they do hint at the need to represent complex concepts into humanly-graspable terms, what Paul Fishwick calls"},{"children":[{"children":null,"tag":"literal","value":"text-based aesthetics"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"fishwick_aesthetic_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The need for these is only semantic insofar as it allows for an intended interaction with the computer to be carried out successfully—e.g. one has an intuitive understanding that interrupting a stream is an action which might result in incompleteness of the whole. This process of linguistic abstraction doesn't actually require clear definitions for the concepts involved. The example of the terminology in modern so-called cloud computing uses a variety of terms stacked up to each other in what might seem to have no clear"},{"children":[{"children":null,"tag":"literal","value":"denotative"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"meaning (e.g. Google Cloud Platform offers"},{"children":[{"children":null,"tag":"literal","value":"Virtual machine compute instances"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"), but nonetheless have a clear"},{"children":[{"children":null,"tag":"literal","value":"operative"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"meaning (e.g. the thing on which my code runs). This further qualifies the complexity of the sense-making process in dealing with computers: we don't actually need to truly understand what is precisely meant by a particular word, as long as we use it in a way which results in the expected outcome"},{"children":[{"children":null,"tag":"literal","value":"See the famous comment in the UNIX source:"},{"children":[{"children":null,"tag":"literal","value":"You are not expected to understand this"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"footnote","value":"125"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The reverse process also brings forth issues of conceptual representation through formal symbolic means. The work of early artifical intelligence researchers consists not just in making machines perform intelligent tasks, but also implies that intelligence itself should be clearly and inambiguously represented. The work of Terry Winograd, for instance, was concerned with language processing (intepretation and generation)"},{"children":[{"children":null,"tag":"literal","value":"winograd_language_1982"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Through his inquiry, he touches on the different ways to represent the concept of language in machine-operational terms, and highlights two possible represenations which would allow a computer to interact meaningfully with language. He considers a"},{"children":[{"children":null,"tag":"literal","value":"procedural"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"representation of language, one which is based on algorithms and rules to follow in order generate an accurate linguistic model, and a"},{"children":[{"children":null,"tag":"literal","value":"declarative"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"representation of language, which relies on data structures which are then populated in order to create valid sentences. At the beginning of his exposé, he introduces the historically successive metaphors which we have used to build an accurate mental representation of language (language as law, language as biology, language as chemistry, language as mathematics). As such, we also try to present language in other terms than itself in order to make it actionable within a computing environment."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As we have seen, metaphors are implicitly known not to be true in their most literal sense. Max Black in"},{"children":[{"children":null,"tag":"literal","value":"Models and Metaphors"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"argues that metaphors are too loose to be useful in analytic philosophy, and therefore too loose for programming languages, heavily based on the analytic tradition. Yet, they still rely heavily on models in order to make human concepts graspable and operation to the computer. These tools deployed during the representational process differ from conventional or poetic metaphors insofar as they can be logically operated upon and therefore empirically verifiable or falsifiable. These models are means through which we aim at taking the conceptual structures on which metaphors also operate, and explicit them in formal symbol systems."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Abstraction, metaphors and symbolic representations are therefore used tools when it comes to understanding some of the structures and objects which constitute computing and software, in terms of trying to represent to ourselves what it is that a computer can and effectively does, and in terms of explaining to the computer what it is we're trying to operate on (from an integer, to a non-ASCII word, to a renewable phone subscription or to human language). Further more, the implication of spatial and visual components in mental models already highlighted by Lakoff and Johnson, and pointed out through the psychology experiments on programmers allow us to turn to metaphors as an architecture of thought"},{"children":[{"children":null,"tag":"literal","value":"forsythe_cathedrals_1986"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", a concept that will be further developed in section XXX."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Metaphors are used as cognitive tools in order to facilitate the construction of mental models of software systems. Following the line of thought traced by Brian Cantell-Smith on his conception of computation as"},{"children":[{"children":null,"tag":"literal","value":"meaning mechanically realized"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", we can also trace the mechanical realization of the metaphor through the interfaces of software tools. This next section thus focuses on how metaphors get reified in tools, and how tools help programmers think."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Tools as a cognitive extension"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:tools-cognition"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"First, we will be looking at interfaces, and how interfaces in the traditional sense of the term, where it can help with the manipulation of things. This will connect the abstract perspective of the metaphor with the concrete perception of the manipulation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As we have seen in the previous sections, metaphors can be embedded within a  particular technical environment in order to allow users to build an effective mental model of what the system is or does, and thus to effectively act in  a way whereby the result of these actions will conform to their intent and expected result (e.g. put a file in the trash to make it disappear)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Specifically, Nielsen and Gentner develop on some challenges that arise when one uses metaphors not just for conceptual understanding, but for further conceptual manipulation. In"},{"children":[{"children":null,"tag":"literal","value":"The Anti-Mac Interface"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", they point out that differences in features between target domain and source domain are inevitable. For instance, a physical pen would be able to mark up any part of a physical form, whereas a tool symbolize by a pen icon on a document editing software might restrict an average user to specific fields on the form. Their study leads to assess alternatives to one kind of interface"},{"children":[{"children":null,"tag":"literal","value":"The one designed by Apple for the Macintosh in the 1990s."}],"tag":"footnote","value":"126"},{"children":null,"tag":"literal","value":", in order to highlight how a computer system with similar capabilities (both being Turing-complete machines), could differ in (a) the assumptions made about the intent of the user, (b) the assumptions made about the expertise level of the user and (c) the means presented to the user in order to have them fulfill their intent"},{"children":[{"children":null,"tag":"literal","value":"gentner_antimac_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Interfaces decide on the way the abstract entities are delimited and represented: through icons or text, with grouped actions or granular actions, weak object-orientation or strong object-orientation, etc. By affecting their manipulation, via their affordances, they also affect the kinds of epistemic actions that can be performed in order to complete the mental model of the objects at hand. For instance, Ken Perlin's"},{"children":[{"children":null,"tag":"literal","value":"Chalktalk"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"focuses on freehand input creation and programmatic input modification in order to explore properties and relations of mathematical objects (e.g. geometrical shapes, vectors, matrices)"},{"children":[{"children":null,"tag":"literal","value":"perlin_chalktalk_2022"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", while Brett Victor's"},{"children":[{"children":null,"tag":"literal","value":"Tangled"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"focuses in a very sparse textual representation of a dynamic numerical model. The epistemic actions taken within this sysmte thus consists in manipulating the numbers presented in the text result in the modification of the text based on these numbers"},{"children":[{"children":null,"tag":"literal","value":"victor_tangle_2011,victor_explorable_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Digital interfaces therefore represent, but also aim to disappear from representation: that is, they aim at providing as direct access as possible to the underlying abstract entities hosted on and performed by the computer."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The kind of dedicated tool used to deal with source code is called"},{"children":[{"children":null,"tag":"literal","value":"Integrated Development Environment"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(IDE), and covers multiple features to support software writing, reading, versioning and executing. With a specific set of features developing over time, and catered to the needs and practices of programmers, its integral part in software development is such that this tool can be considered an integral part of an extended cognitive process."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"One of the first interfaces for writing computer code included the text editor called"},{"children":[{"children":null,"tag":"literal","value":"EMACS"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(an acronym for"},{"children":[{"children":null,"tag":"literal","value":"Editor MACroS"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"), with a first version released in 1976. Containing tens of thousands of commands to be input by the programmer at the surface-level in order to affect the deeper level of the computing system,"},{"children":[{"children":null,"tag":"literal","value":"EMACS"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"allows for remote access of files, modeful and non-linear editing, as well as buffer-based manipulation"},{"children":[{"children":null,"tag":"literal","value":"greenberg_multics_1996"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", also present in its competitor,"},{"children":[{"children":null,"tag":"literal","value":"Vim"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". This use of tools is, at this point, to design an interfaced system which allows for the almost real-time manipulation of digitized objects (e.g. a paragraph)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While software such as"},{"children":[{"children":null,"tag":"literal","value":"EMACS"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"Vim"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"are mostly focused on productivity of text-editing, other environments such as"},{"children":[{"children":null,"tag":"literal","value":"Turbo Pascal"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"Maestro I"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"focused specifically on software development tasks in a particular programming language in software such as the Apple WorkShop (1985)"},{"children":[{"children":null,"tag":"literal","value":"west_macintosh_1987"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", or the Squeak system for the Smallktalk programming language"},{"children":[{"children":null,"tag":"literal","value":"ingalls_back_1997"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". The idea is to integrat the various tasks of software development (such as linking, compiling, debugging, block editing and refactoring) into one software, allowing the programmer to switch seamlessly from one task to another, or allowing a task to run in parallel to another task (e.g. indexing and editing)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Throughout this evolution, and with the development of more powerful hardware, IDEs started to develop more elaborated user-interfaces, involving more traditional concepts of aesthetics (such as shape, color, balance, distance, symmetry). IDEs attempt to solve some of the mental operations performed by programmers as they engage with source code. These, mentioned in the previous section, include as chunking, tracing, detecting beacons, and organizing the code space. One specific technical feature, syntax highlighting, shows how a technical system with primarily aesthetic consequences influence"},{"children":[{"children":null,"tag":"literal","value":"understandability"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Understanding the source code is impacted both by"},{"children":[{"children":null,"tag":"literal","value":"legibility"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(concerning syntax, and whether you can quickly visually scan the text and determine the main parts of the text, from blocks to words themselves) and"},{"children":[{"children":null,"tag":"literal","value":"readability"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"(concerning semantics, whether you know the meaning of the words, and their role in the group)"},{"children":[{"children":null,"tag":"literal","value":"oliveira_evaluating_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Indeed, the way that the presentation of source code can be modified through extensive customization has been the object of research, and has shown that understanding is indeed impacted by presentation"},{"children":[{"children":null,"tag":"literal","value":"jacques_understanding_2015"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This move from legibility (clear syntax) to readability (clear semantics) is what can be called"},{"children":[{"children":null,"tag":"literal","value":"fluency"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Fluency is, in part, the process of building mental structures that disappear in the interpretation of the representations. The letters and words of a sentence are experienced as meaning rather than markings, the tennis racquet or keyboard becomes an extension of one's body, and so forth. Well-functioning interfaces are thus interfaces which disappear from the cognitive process of their user, allowing them to focus on ends, rather than on means"},{"children":[{"children":null,"tag":"literal","value":"galloway_interface_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", leading to what Paul A. Fishwick has coined"},{"children":[{"children":null,"tag":"literal","value":"aesthetic programming"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", an approach of how attention paid to the representation of code in sensory ways results in better grasping of the metaphors at play in code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The automation of tooling and workflow increased in software such as Eclipse, IntelliJ, NetBeans, WebStorm Visual Studio Code"},{"children":[{"children":null,"tag":"literal","value":"With which this thesis is written."}],"tag":"footnote","value":"127"},{"children":null,"tag":"literal","value":"has led to further entanglements of technology and appearance. One of these is the use of automated styleguides. The evolution of software engineering, from the individual programmer implementing ad hoc and personal solutions to a group of programmers coordinating across time and space to build and maintain large, distributed pieces of software, brought the necessity to harmonize and standardize how code is written—style guides started to be published to normalize the visual aspect of source code. Furthermore, due to their existence within a computational environment, IDEs include software which automatically stylizes code. These, called"},{"children":[{"children":null,"tag":"literal","value":"linters"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", are programs which analyzes the source code being written in order to flag suspicious writing (which could either be suspicious from a functional perspective, or from a stylistic perspective). They act as a sort of"},{"children":[{"children":null,"tag":"literal","value":"intermediary object"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", insofar as they assist individuals in the process of creating another object"},{"children":[{"children":null,"tag":"literal","value":"jeantet_objets_1998"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The problem of style is a problem framed by Georg Simmel's statement regarding the observation that"},{"children":[{"children":null,"tag":"literal","value":"the practical existence of humanity is absorbed in the struggle between individuality and generality"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"simmel_problem_1991"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Simmel's investigation of the topic, which will serve as the foundation for our definition of style, focuses on the dichotomy between works of fine art and mass-produced works of applied arts. Indeed, Simmel draws a distinction between the former, as indiosyncratic objects displaying the subjectivity of its maker, and the latter, as industrially produced and replicated, in which the copy cannot be told apart from the original. The work of fine art, according to him, is"},{"children":[{"children":null,"tag":"literal","value":"a world unto itself, is its own end, symbolizing by its very frame that it refuses any participation in the movements of a practical life beyond itself"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", while the work of applied arts only exists beyond this individuality, first and foremost as a practical object. As these two kinds of work exist at the opposite extremes of a single continuum, we can insert a third approach: that of the crafted object, as a repeated display of its maker's subjectivity, destined for active use rather than passive contemplation. So while style can be seen as a general principle which either mixes with, replaces or displaces individuality, style in programming doesn't stand neatly at either extreme. It involves individual preferences, but also transitions through the objective via such intermediary objects that are linters."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Therefore, automatic tools are also integrated at the surface-level (indentation, line breaks, etc.) but also with consequences at the deep-level, by facilitating human reasoning about these, and by ensuring, to a certain extent, machine readability and execution. In this case, we witness how computer-aided software engineering in the form of IDEs can be both considered as traditional interfaces (surface representation affording direct interfaction) as well as mental interface (formal arrangements whose aim is to facilitate direct engagement with the conceptual structures that it represents, and with the ultimate goal of no long being noticeable). Perception and comprehension of source code is therefore more and more entangled with its automated representation."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Extended cognition"}],"tag":"subsubsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsubsec:extended-cognition"}],"tag":"label","value":"understanding"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"There is a long history of computer-mediated knowledge-management, one that finds its roots in the pre-computer era. For instance, the work of the encyclopedists, and scientists in seventeenth-century europe approached knowledge as something which could, and should be rationalized, organized and classified in order to be retrievable, comparable, and actionable"},{"children":[{"children":null,"tag":"literal","value":"sack_software_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Scholars such as Roland Barthes, Jacques Derrida or Umberto Eco had specific knowledge-management techniques in order to let them focus on the arguments and ideas at hand, rather than on smaller organizational details, through the use of index cards. Perhaps, as Bernard Stiegler argued, technology itself is already a prosthesis for memory"},{"children":[{"children":null,"tag":"literal","value":"wilken_card_2010"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", an external storage which offloads the cognitive burden of having to remember things."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This approach was taken to another level with the emergence of the computer. Laying out his vision for a"},{"children":[{"children":null,"tag":"literal","value":"Man-Computer Symbiosis"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", J.C.R. Licklider, project leader of what would become the Internet and trained psychologist, emphasized information management. He saw the computer as a means to \"augment the human intellect by freeing it from mundane tasks\""},{"children":[{"children":null,"tag":"literal","value":"licklider_mancomputer_1960"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". By being able to delegate mundane tasks, one could therefore focus on the most cognition-intensive tasks at hand. While improving speed and memory of contemporary hardware has supported Licklider's perspective a single limitation that he pointed out in the 1950s remains: the problem of language."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"What is it that we want to accomplish, and how do we want to accomplish it, are complex questions for a computer to process. The subtleties of language, as highlighted at the beginning of this chapter, result in some ambiguities which is not the preferred mode of working of a logical arithmetic machine. If machines can help us think, there are therefore some aspects of that thinking which cannot cannot easily be translated in the computer's native terms, and the work of interface designers and tool constructors has therefore been to automate most of what can be automated away, and faciltate the more mundane, yet complex if done by hand, tasks done a by a programmer"},{"children":[{"children":null,"tag":"literal","value":"Such as batch refactoring, or updating dependency versions."}],"tag":"footnote","value":"128"},{"children":null,"tag":"literal","value":". Software tools are therefore used to think and explore concepts, by supporting epistemic actions in various modalities"},{"children":[{"children":null,"tag":"literal","value":"victor_humane_2014"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The computer therefore supports epistemic actions through its use of metaphors (to establish a fundamental base of knowledge) and of actions (to probe and refine the validity of those metaphors) to build a mental model of the problem domain. In the case of IDEs, the problem domain is the source code, and these interfaces, by allowing means of scanning and navigating the source code, are part of what Simon Penny calls, after Clark and Chalmers,"},{"children":[{"children":null,"tag":"literal","value":"extended cognition"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"penny_making_2019"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Extended cognition posits that our thinking happens not only in our brains, but is also located in the tools we use to investigate reality and to deduce a conceptual model of this reality based on empirical results. IDEs are a specific manifestation of embodied cognition, actively helping the programmer to define, reason about, and explorer a code base. The means of taking epistemic action, then, are also factors in contributing to our understanding of the object at hand (here, source code). In this spirit, David Rokeby goes as far as qualifying the computer as a"},{"children":[{"children":null,"tag":"literal","value":"prosthetic organ for philosophy"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", insofar as it helps him formulate accurate mental models as he interacts with them through computer interfaces."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Programmers face the complexity of software on a daily basis, and therefore use specific cognitive tools to help them. While our overall argument here is that aesthetics is one of those cognitive tools, we focused on this section on two different, yet widely used kinds: the metaphor and the integrated development environment."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We pointed out the role that metaphors play in creating connections between pre-existing knowledge and current knowledge, building connections between both in order to implicitly establish some knowledge of the target domain. Presented to end-users, metaphors are also used by programmers at a different level, helping them grasp concepts (e.g. memory, objects, package) without having to bother with details. As we will see in the following chapters, metaphors are also used by programmers in the source code they write in order to elicit this ease of comprehension for their readers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Concurrently, programmers also rely on specific software tools, in order to facilitate the scanning and the exploring of source code files, while running mundane tasks which should not require particular programmer attention, such as linking or refactoring. The use of software to understand software is indeed paradoxical, but nonetheless participates in extended cognition; the means which we use to reason about problems affect, to a certain extent, the quality of this reasoning."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Code is therefore technical and social, and material and symbolic simultaneously. Rather, code needs to be approached in its multiplicity, that is, as a literature, a mechanism, a spatial form (organization), and as a repository of social norms, values, patterns and processes."},{"children":[{"children":null,"tag":"literal","value":"berry_philosophy_2011"}],"tag":"citation","value":""}],"tag":"paragraph","value":""}],"tag":"quote","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This chapter has shown that software is a complex object, an"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", existing at multiple levels, and in multiple dimensions. Programmers therefore need to deal with this complexity and deploy multiple techniques to do so. Psychology studies, investigating how programmers think, have pointed out several interesting findings. First, reading and understanding source code is not an activity which relies exclusively on the part of the brain which reads natural language, nor on the part which does mathematical operations. Second, the reasoning style is multimodal, yet spatial; programmers report working and thinking at multiple levels of scale, represent parts of code as existing closer or further from one another, in non-linear space. Third, the form affects the content. That is, the way that code is spatially and typographically laid out helps, to a certain, with the understanding of said code, without affecting expertise levels, or guaranteeing success."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In order to deal with this complexity, some of the means deployed to understand and grasp computers and computational processes are both linguistic and technical. Linguistic, because computer usage is riddled with metaphors which facilitate the grasping of what the presented entities are and do. These metaphors do not only focus on the end-users, but are also used by programmers themselves. Technical, because the writing and reading of code has relied historically more and more on software which allows programmers to perform tasks specific to source code, in a seamless manner"},{"children":[{"children":null,"tag":"literal","value":"Using, for instance, macros or keyboard shortcuts."}],"tag":"footnote","value":"129"},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In the next chapter, we turn to the meeting point of the linguistic and the technical, and to what are yet another hybrid type of interface to source code—programming languages. This exploration will show what status they have in relation to source code, and what kind of aesthetic manifestations they support."}],"tag":"paragraph","value":""}],"tag":"root","value":""}],"tag":"include","value":"understanding.tex"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Beauty and understanding"}],"tag":"chapter","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"chap:beauty"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This chapter focuses on what beauty has to do with understanding, first from a theoretical perspective, and then diving specifically into how specific domains approach this relation. Our theoretical approach will be based on the aesthetic theory of Nelson Goodman, and a lineage which links aesthetics to cognition, most recently aided by the contribution of neurosciences."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"After argumenting for a conception of aesthetics which tends to intellectual, rather than emotional, engagement, we will pay attention to how surface structure and conceptual assemblages relate. That is, we will highlight how each of the domains contigent to source code— literature, mathematics and architecture—communicate certain concepts through their respective and specific means of symbolic representation."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Aesthetics and cognition"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-cognition"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Starting this research with the assumption that aesthetics exist beyond the work of art, it is nonetheless from philosophy of art that we draw from, in order to map out the expressive power of a given formal representation, as a traditional pre-requisite to the gaining of art status of an object."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The aesthetic experience—that is, the positively received perception of a natural or crafted object—has traditionally been laid out across multiple axes, with more or less overlap. Whether this positive perception is due to an emotional response, to a harmonious assessment, to an axiomatic adherence or to disinterested pleasure has indeed been the topic of debates amongst philosophers for centuries"},{"children":[{"children":null,"tag":"literal","value":"peacocke_aesthetic_2023"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Noël Carroll sums up these different directions under the broad areas of affect, axiom and content"},{"children":[{"children":null,"tag":"literal","value":"carroll_aesthetic_2002"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". He underlines how an aesthetic experience dictated by affect removes the object from one's assessment of purpose, value and effect, and limiting it to form, following Kant's principle of disinterested pleasure via passive contemplation. As such, a flower, a sunset or a musical melody can evoke affective aesthetic experiences. Yet, the supposed tendency of this kind of experience to release us from worldly concerns fails, for Carroll, to encompass aesthetic experiences that are rooted in so-called worldly concerns—such as a documentary photography, skillful physical performance, or delicatedly crafted glassware—and is therefore unsatisfying as a root explanation for the aesthetic experience."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"An axiomatic aesthetic experience is, in turn, based on the sort of value that the object is being associated with—such as depiction of religious topics or a manifestation of a particular style. While Carroll does acknowledge a certain virtue of this aesthetic experience in terms of contribution to group cohesion through shared values and imaginaries, its limitations are found in a pre-existing answer to the value judgment that is being bestowed upon the object—the material and sensual properties of the object at hand are irrelevant since their quality is already decided"},{"children":[{"children":null,"tag":"literal","value":"a priori"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"It is in the content approach that Carroll finds the most satisfying answer to what the aesthetic experience is. Content, here, is defined as the forms being apprehended, along with its combinations, juxtapositions and comparisons with other forms. When we engage with the sensual aspects or an object, our attention is indeed directed first and foremost at what the object looks like. More specifically, Carroll notes, if attention is directed with understanding to the form of the art work or to its expressive and aesthetic properties or to the interaction between those features, then the experience is said to be aesthetic"},{"children":[{"children":null,"tag":"literal","value":"carroll_aesthetic_2002"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Form, and the attention to form, will thus be taken as our starting point.  This content approach to form, i.e. the set of appearing choices intended to realize the purpose of the artwork, involves questions of function, implied by the presence of purpose pertaining to an artwork. Particulary, how does the object of aesthetic experience manifest this purpose, in such a way that it can be correctly judged, insofar as its perceived form and perceived purpose are aligned, distinct from any emotional or axiomatic charge?"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This analysis is complemented by the study conducted by Anjan Chatterjee and Oshin Vartanian on the evaluation of the aesthetic experience from a neuroscientific point of view. Like Carroll, they highlight three different perspectives: a sensory-motor perspective, loosely mapped to an affective experience, an emotion-valuation perspective, similar to an axiological experience, and a meaning-knowledge experience, which we equate to the content approach to the aesthetic experience"},{"children":[{"children":null,"tag":"literal","value":"chatterjee_neuroscience_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Additionally, they make the distinction between an aesthetic judgment, which emanates from the process of understanding the work, and an aesthetic emotion, which follows from the ease of acquisition of such an understanding. Without being mutually exclusive, these two pendants are related to the amount of engagement provided by the person who aesthetically experiences the object. One can have an aesthetic emotion without being able to provide an aesthetic judgment, a case in which one does not hold enough expertise to apprehend or appreciate a particular realisation. In this sense, the aesthetic judgment, unlike the aesthetic emotion, requires something additional. This conditioning of the aesthetic experience to a certain kind of pre-existing knowledge or skill is supported by the authors' mention of the theory of fluency-based aesthetics"},{"children":[{"children":null,"tag":"literal","value":"chatterjee_neuroscience_2016"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", and their view builds on models that frame aesthetic experiences as the products of sequential and distinct information-processing stages, each of which isolates and analyzes a specific component of a stimulus (e.g., artwork). These stages, based on Leder et. al's model"},{"children":[{"children":null,"tag":"literal","value":"leder_model_2004"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", evolve form perception, to implicit classification, explicit classification, cognitive mastering and evaluatio—that is, fully-qualified aesthetic judgment."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These studies thus show a particular empirical attention to the cognitive engagement with respect to the apprehension an object from an aesthetic perspective, as opposed to passive contemplation or value-driven aggreement. While these other types of experiences remain valid when apprehending such an object, we focus here on this specific kind of experience: the cognitive approach to the aesthetic experience."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"And yet, the fact that there is cognitive engagement supporting an aesthetic experience does not immediately explicit the nature and details of such engagement. Speaking in terms of form and object are higher-level concepts which tend to erase the specificities of the various systems of aesthetic properties, and how their arrangement expresses various concepts. We now turn to Goodman's analysis of the languages of art as a representational symbol systems to frame our analysis of specific aesthetic domains, and analyse how each."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Source code as a language of art"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:source-code-language-art"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From the question of the nature of the aesthetic experience from the perspective of the audience, whether as an aesthetic emotion being felt or as an aesthetic judgment being given, we shift our attention to the object of aesthetic experience, and to the questions of"},{"children":[{"children":null,"tag":"literal","value":"how does a work represent?"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"what does a work represent?"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". To answer these, we rely on answers provided by by Nelson Goodman in the"},{"children":[{"children":null,"tag":"literal","value":"Languages of Art: An Approach to a Theory of Symbols"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"goodman_languages_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"The Structure of Appearance"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"goodman_structure_1966"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The starting point for Goodman's analysis is that production and understanding in the arts involve human activities that, though they differ in specific ways among themselves and from other activities, are nevertheless generically related to perception, scientific inquiry, and other cognitive activity, and such an activity specifically involves symbolic systems. It is those two components that Goodman aims at expliciting: what constitutes an aesthetic symbol system, and how does it express?"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Goodman develops a systematic approach to symbols in art, freed from any media-specificity (e.g. from pictorial symbols to musical notations and even time marks on clocks and watches). A symbolic system, in his definition, consists of characters, along with rules to govern their combination with other characters, itself correlated with a field of reference. These symbols and their arrangement within a work of art supports an aesthetic experience"},{"children":[{"children":null,"tag":"literal","value":"It should be noted here that Goodman does not limit the aesthetic experience to a positive, pleasurable one. An artistic symbolic system can be seen even if the result is considered bad."}],"tag":"footnote","value":"130"},{"children":null,"tag":"literal","value":". A work, as a part, particular arrangement of a symbol system according to specific syntactic and semantic rules, can therefore enable an aesthetic experience."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A symbol system is based on five requirements: a system should be composed of signs which are unambiguous, syntactically and semantically disjointed, and differentiated"},{"children":[{"children":null,"tag":"literal","value":"goodman_languages_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". This classification makes it possible to compare the various symbolization systems used in art, science, and life in general: from clocks to counters, from diagrams to maps models, from musical scores to painters’ sketches and scripts (intended in a broad sense as the characters of natural languages). In our case, this provides us for a framework to investigate the extent to which source code qualifies as a language of art."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code is written in a formal linguistic system called a programming language. Such a linguistic system is, obviously, digital in nature, and therefore satisfies at least the syntactic requirements of disjointedness, differentiation (a mark only ever corresponds to that symbol, such as a variable or function name), as well as syntactic repleteness (relatively fewer factors need to be taken into account during the interpretative process)"},{"children":[{"children":null,"tag":"literal","value":"This does not mean that any program text written in this symbolic system will tend to be syntactically replete. On the contrary, the tendency of program text to veer towards verbosity implies the desirable state of repleteness."}],"tag":"footnote","value":"131"},{"children":null,"tag":"literal","value":". This does qualify source code as a potential language for art, through which aesthetic expressiveness can emerge."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"As Goodman notes, the distinct signs that compose a symbols system do not have intrinsic properties, but a thing serves as a sign only in relation to a symbol system, and a field of reference. Some requirements need to be fulfilled for such a symbol to be what is called a symptom of the aesthetic. Amongst exemplification, syntactic density, semantic density and syntactic repleteness, source code fulfills the last two criteria: with a limited set of symbols (at one of the lowest levels, only two symbols, traditionally marked as 0 and 1), programs can refer to and enact complex states and behaviours."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The field of reference is understood her as being the set of concepts which are being referred to by a symbolic system. For instance, a symbolic system such as western classical music can refer to concepts such as lament, piety, heroism or grace, while a chine"},{"children":[{"children":null,"tag":"literal","value":"shanshui"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"painting has a landscape composed of mountains and rivers as its field of reference. The combination of both the problem domain, as evoked in"},{"children":[{"children":null,"tag":"literal","value":"chap:understanding"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", and of the technological environment on which the source code is to be executed, is posited here as an equivalent to the Goodman's field of reference."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Now that we have highlighted what a symbolic system is, we turn to how such a system can signify and reference a particular field of reference."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Goodman highlights the ways in which symbols systems communicate, through the notion of"},{"children":[{"children":null,"tag":"literal","value":"reference"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". To refer to, in this sense, is the action by which a symbol stands in for an item. Reference, he sketches out, takes place through the different dyads of denotation and exemplification, description and representation, possession and expression"},{"children":[{"children":null,"tag":"literal","value":"goodman_languages_1976"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". We will see how these various means of referring can be instantiated in the symbolic system of source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"First, then, denotation; it is the core of representation, a reference from a symbol to one or many objects it applies to and is independent of resemblance. Rather, it uses a particular relationship via the use of labels; that is, a symbol stands in for an item in the field of reference. For instance, a name denotes its bearer and a predicate each object in its extension. Names such as variable names or function names thus denote a particular item in the field of reference, and act as their label. For instance,"},{"children":[{"children":null,"tag":"literal","value":"var auth_level"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"denotes an ability to access and modify resources."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The labelling process therefore serves as the symbolic expression for a particular field. In source, this can happen through variable naming (as seen above), but also through type definition"},{"children":[{"children":null,"tag":"literal","value":"For instance, a particular choice of a numeric value, such as"},{"children":[{"children":null,"tag":"literal","value":"int"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"float"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"denote a particular level of preciseness"}],"tag":"footnote","value":"132"},{"children":null,"tag":"literal","value":", as well as additional affordances which we look at in"},{"children":[{"children":null,"tag":"literal","value":"sec:programming-aesthetic-framework"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code also make extensive use of description. If we consider a program text as a series of steps, a series of states, or a series of instructions, then it follows that source code is leaning heavily on the side of description, when it comes to its power of reference. Indeed, a program text is a description of how to solve a problem from the computer's perspective, written extensively in machine language"},{"children":[{"children":null,"tag":"literal","value":"Pseudo-code is therefore a representation of a potential source code written in a specific language."}],"tag":"footnote","value":"133"},{"children":null,"tag":"literal","value":". All source code can therefore be said to be a description of a combination of action and states."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"States are also a particular case in source code: they are both a description and, because they are not the thing itself, they are also a representation. As one can see in"},{"children":[{"children":null,"tag":"literal","value":"code:representation"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", an individual can be represented within source code with a particular construct (here called a"},{"children":[{"children":null,"tag":"literal","value":"struct"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":")."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/representation.rs"}],"tag":"code","value":"rust"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"An example of how source code can be a representation an individual, and can exemplify encapsulation, written in Rust."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:representation"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This representation, in the specific instance of object-oriented programming in"},{"children":[{"children":null,"tag":"literal","value":"code:representation"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", also manifests Goodman's aesthetic symptom of possession. Here, the source code posseses similar properties as the thing referenced (since our prototypal image of a person has an age, a name and interests). Through this possession of a property, it acts as an example of a prototypal person."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Exemplification is another aspect of Goodman's theory, which has nonetheless remained somewhat limited"},{"children":[{"children":null,"tag":"literal","value":"elgin_making_2011"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". A symbol exemplifying, also called an examplar, is considered as a stand-in for an item in the field of reference. Specifically for source, code, this is a case that we have seen in"},{"children":[{"children":null,"tag":"literal","value":"subsec:scientists"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", where a particular source code is written in order to act as an example of a broader concept. For instance, a program text can, at a lower level, exemplify a particular kind of procedure, such as encapsulation or nestedness. The program text therefore exemplifies the constitutive element of the linked list"},{"children":[{"children":null,"tag":"literal","value":"A linked list is a basic data structure in computer science, which consists in a succession of connected objects."}],"tag":"footnote","value":"134"},{"children":null,"tag":"literal","value":". However, a similar program text can also be an example of cleanliness, of clarity, or elegance (see"},{"children":[{"children":null,"tag":"literal","value":"sec:ideals-beauty"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"): a program text written by a software developer can be seen as possessing the property of cleanliness, by virtue of its implementation of syntactic and semantic rules, while another program text written by a hacker can be seen as highlighting detailed hardware knowledge."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Additionally, the features a symbol exemplifies depends on its function (or, more precisely, its functional context)"},{"children":[{"children":null,"tag":"literal","value":"elgin_understanding_1993"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". A symbol can perform a variety of function: a piece of code in a textbook might exemplify an algorithm, while the same piece of code in production software might be seen as a liability, or as a boring section in a code poem."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Source code maintains specific features on its relation to the field of reference. On the one hand, a particular class of characters employed as symbols (also called"},{"children":[{"children":null,"tag":"literal","value":"tokens"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in the context of programming languages), do not maintain a clear relationship with the items in the field of reference. That is, in program texts, two distinct symbols can be referring to the same concept, value, or place in memory (see"},{"children":[{"children":null,"tag":"literal","value":"chap:programming"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"for a further explanation of these differences and"},{"children":[{"children":null,"tag":"literal","value":"code:multiple_references"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"for an example), something Goodman nonetheless assigns as another symptom of the aesthetic: multiple and complex references."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/multiple_references.rs"}],"tag":"code","value":"rust"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"The system of value, references and pointers make source code into a highly complex symbolic system."}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:multiple_references"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"On the other hand, the representation of a field of reference is done through a disjointed and differentiated system: the boundaries of each items in the field of reference are clearly defined, in virtue of the specific symbol system that programming languages are. These programming languages do dictate the rules of engagement of the symbolic system with the field of reference."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"We have shown here that source code qualifies as a symbolic system susceptible of affording symptoms of the aesthetic. We have also highlighted its specificities, particularly in terms of descriptions and representations, and of complex and multiple references. Source code being a dual language, between human and machine, makes it have such complex and multiple references. A final aspect to investigate is the expressiveness of source code, with a particular attention to how source code can manifest of metaphorical exemplification and representation."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"MAYBE: beardsley - the metaphorical twist / fauconnier-turner-conceptual-blending.md"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"complement with the fluency-based theory that involves skill as well:"},{"children":[{"children":null,"tag":"literal","value":"https://journals.sagepub.com/doi/10.1207/s15327957pspr0804_3"}],"tag":"url","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"but also PARTICULARLY catherine elgin:"},{"children":[{"children":null,"tag":"literal","value":"http://www.catherineelgin.com/Understanding.html"}],"tag":"url","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"goody-logic-of-writing.md, goody comes here because he is dealing at the same higher level of the symbol system (orality vs. literacy), and then combine it with ong-orality-literacy.md"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"davis how to make analogies in a digital age"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Literature and understanding"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-literature"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Ricoeur - Métaphore vive"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Lakoff (take away from chap 2.)"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"barthes"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"voleshov and social aesthetics"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"mace-styles-critiques-de-nos-formes-de-vie"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"rousset: forme et signification"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"flusser: bringing into the realm of prose"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"portela-scripting-reading-motions"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Bouchardon - Valeur heuristique de la littérature numérique"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"N. Katherine Hayles - Speech, Writing Code, My Mother Was A Computer"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Françoise Lavocat - interprétation et sciences cognitives, dimension spatiale de la représentation textuelle."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Jérôme Pelletier -  L'attrait esthétique de la fiction : un point de vue de philosophie cognitive /  La Fiction comme Culture de la Simulation"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Marie-Laure Ryan - Complexity"},{"children":[{"children":null,"tag":"literal","value":"http://marilaur.info/complexity.pdf"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":"/ Mapping and Geography"},{"children":[{"children":null,"tag":"literal","value":"http://marilaur.info/2018-mapping.pdf"}],"tag":"url","value":""},{"children":null,"tag":"literal","value":"/ "},{"children":[{"children":null,"tag":"literal","value":"https://ohiostatepress.org/books/BookPages/ryanetal_narrating.html"}],"tag":"url","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Architecture and understanding"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:arch-understanding"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"https://beautiful.software/"}],"tag":"url","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"habitability, navigation, landscape cognition, relationship between form and function"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"patterns and beacons"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"compression"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Forms of scientific activity"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-scientific"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This section looks at the forms of sciences and activity"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Mathematics and elegance"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-mathematics"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"poincaré"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Epiphany, enlightenment"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"all the reading resources from alberto"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Making and understanding"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:aesthetic-engineering"}],"tag":"label","value":"beauty"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Learning by doing, craft, extract from chap 2"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In conclusion, we have seen that there is a clear connection between aesthetics and cognition, and that it exists across domains. For literature, it is about accessing three-dimensional space through two-dimensional surface and one-dimensional sentences. For architecture, it is about cognition as ability to modify and act within, as well as the ability to derive the meaning of things from their appearances. In mathematics, it is about compressing the maximum amount of insight (which is different from just knowledge) in the minimum amount of explanation/tokens. For engineering it's not quite sure yet, but it's related to architecture: how functional (in the social and technical sense) it is."}],"tag":"paragraph","value":""}],"tag":"root","value":""}],"tag":"include","value":"beauty.tex"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Machine languages"}],"tag":"chapter","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"chap:programming"}],"tag":"label","value":"programming"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This chapter brings it all together: it develops on the medium itself of source code beauty: the programming languages. They will allow us to highlight two things. First, that there is a tension between human-meaning and machine-meaning, a tension between syntax and semantics. Second, it will allow us to show that what is considered beautiful in one language is not always considered beautiful in another, even though it has the same"},{"children":[{"children":null,"tag":"literal","value":"intent"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", but clearly different syntax, and perhaps even different semantics."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Then, we extract form our case studies a theory/typology/nomenclature of aesthetic manifestations in programming."},{"children":[{"children":null,"tag":"literal","value":"Perhaps we should do the theory before, coming out from the programming languages, and then apply it in case studies"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Once we have shown the consolidated typology/exposé of aesthetic manifestations and devices, we will look at some case studies to illustrate all our previous points: the standards established beforehand (clean, elegant, etc.), the different social contexts, the different language contexts, the lit/arch/math/eng components and most importantly the relationship between surface-level and deep-level of a program-text. These case studies include poems, operating systems, parsers. (it would be nice to find something that is very hacky, or something that is very scientific)."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Machine meaning and human meaning"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:human-machine-meaning"}],"tag":"label","value":"programming"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This talks more about programming languages, we show how the abstract artifact is tanglibly manifested. We also look at machine semantics and syntax, and finally we look at language-independent features, or language independent features."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Idiomaticity"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:idiomaticity"}],"tag":"label","value":"programming"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"A Framework for source code aesthetics"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:programming-aesthetic-framework"}],"tag":"label","value":"programming"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This is where we outline a basic theory, as seen in the check-in 2."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Case studies"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:case-studies"}],"tag":"label","value":"programming"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This shows the case studies."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In conclusion, we have shown that a lot of the questions we have raised and features we have pointed out are manifested in programming languages. From there on, we have proposed our theory about levels and distances, confirming this idea of mental structures clearly manifested in source code, and of metaphors. This has been followed by case studies which have shown, in a variety of corpuses, how these are present in specific program-texts. And, again, that aesthetics is inseparable from functionality."}],"tag":"paragraph","value":""}],"tag":"root","value":""}],"tag":"include","value":"programming.tex"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"Conclusion"}],"tag":"chapter","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"chap:conclusion"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A piece of source code, as the lexical representation of computational processes, themselves representations of worldly matters, is an ambiguous object. Such an object exists at the overlap of both human and machine comprehension, and is often hidden away by the executed processes of which it is the source. And yet, source code practioners, those who write and read code, agree on the existence of a certain sense of"},{"children":[{"children":null,"tag":"literal","value":"beauty"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The research aims of this thesis were to highlight the origins and implications of the aesthetic properties exhibited by varieties of source code. That is, we intended to show how aesthetic properties relate to other aesthetic fields, and what role they played in the existence and purpose of source code—with a particular focus on its relationship to function. Our methodology started from an empirical approach of looking at specific instances of source code, and on analyzing of the discourses surrounding and commenting these instances. From this initial study, we identified several lexical fields that programmers refer to when they evoke the aesthetic properties of source code—literature, architecture, mathematics and craft."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Along with this first research axis, we also noted how the aesthetic judgement in source code is closely tied to its fuctionality. Indeed, any aesthetic value is dependent on the correct behaviour of the source code; ugly code is related to its apparent bugginess and difficulty in engaging with it, while beautiful code implies that the actions resulting from the source code are conform to what the programmer had intended, along with being presented in the best possible way"},{"children":[{"children":null,"tag":"literal","value":"Such a definition of a"},{"children":[{"children":null,"tag":"literal","value":"best possible way"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is dependent on the social, cultural and economic spheres within which the code is produced."}],"tag":"footnote","value":"135"},{"children":null,"tag":"literal","value":". The aesthetic properties of source code are therefore those of a semantic representation of computational space-time, whose purpose is the effortless communication of the operations of the computer, the intention of the programmer(s) and the representation of the world."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Findings"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:findings"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The rest of this conclusion will address each of our initial research questions' findings, followed by an examination of the limitations and contributions to existing research on source code."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"What does source code have to say about itself?"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:conclusion-rq-1"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"One of the gaps we identified in source code-related literature is that there was a missing overlap between a broad empirical approach and a robust conceptual framework, expliciting the nature of source's code properties. for instance the works of"},{"children":[{"children":null,"tag":"literal","value":"paloque-berges_poetique_2009,cox_speaking_2013"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"establish an overview of source code with explicit aesthetic properties, but rely on a remediating approach to assess source code as a literary-semantic tool, or as a discursive-political object, respectively. We intended to complement this initial work to highlight source-code-specific aesthetics—that is, formal manifestations with a communicative purpose."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Starting from trade literature on the topic, and complementing it by cases of close-reading, we have highlighted both structural and contextual specificities to source code. Building on existing work, we have found several properties which seem to be unique to source code. Altogether, these properties support our theory of source code as a material used to construct dynamic semantic spaces."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Conceptual distance"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"is key at a structural level: correlated expressions, statements or variables that affect or depend on the same concept (e.g. a file operation or a user account), should be located close to one another in the source code. This counterbalances the entropic tendency of source code to tangle itself, such that the reader has to follow the convoluted machine path of execution, rather than the human conceptual grouping of executable statements."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"insert example / comparison here"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The conceptual coherence, and thus its ease of understandability, is also manifested in"},{"children":[{"children":null,"tag":"literal","value":"conceptual atomicity"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"conceptual symmetry"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", respectively meaning that a given explicit fragment of source code should do only one thing and do it well, and that fragments of source code that do similar things should look similar as well. Also previously identified as"},{"children":[{"children":null,"tag":"literal","value":"separation of concerns"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", these two principles allow for the abstraction of a given syntactic unit by grouping all the statements into a single action or declaration."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"At the lexical level, source code operates on a multi-dimensional level. On the one hand, it operates on an axis that goes from"},{"children":[{"children":null,"tag":"literal","value":"global"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to"},{"children":[{"children":null,"tag":"literal","value":"local"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", whereby global tokens that are used, and are visible, across the whole application code are very explicitly named, sometimes in all uppercase, while local tokens, whose lifetime does not exceed a few lines, tend to be composed of just a few letters. Here, variable length and cap size is closely related to the concept of"},{"children":[{"children":null,"tag":"literal","value":"scope"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", yet in a slightly looser way than from a strict programming language perspective. On the other hand, lexical tokens can belong to three different lexical fields. These lexical fields are whether a given token refers to (1) an individual meaning, (2) a machine meaning, or (3) a domain meaning. For instance, the names"},{"children":[{"children":null,"tag":"literal","value":"start_time"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":", "},{"children":[{"children":null,"tag":"literal","value":"UTC_UNIX_STRING_NOW"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"and"},{"children":[{"children":null,"tag":"literal","value":"meeting_time"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"might all refer to the same moment in time, yet from different perspectives. The first naming, as an individual meaning, is significant in a narrow context, for a narrow set of individuals at the moment of writing or reading. The second naming is a machine meaning, which refers to how that moment is perceived by the computer. The third is the domain meaning, which is how users (and not writers or readers of source code) will refer to that particular moment."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"For some, a piece of source code which can choose a token that will balance these three meanings in order to convey these three senses of the value at hand will be considered aesthetically pleasing. For others, writing tokens at the extreme of either of these three poles can be considered as a marker of aesthetic success and expertise. For instance, code poets would tend to focus on the domain meaning, in which tokens are only referring to non-computing terms, evoke poetic concepts insted. Conversely, hackers share a standard for brevity and directness—by making their tokens as short as possible, e.g. reducing them to bytecode, they strive towards existing as close as the hardware the code will run on, and therefore display unsual feats of performance."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This context-sensitiveness brings us to another aspect of source code—that it is eminently dependent on communities of practice to establish what is beautiful code. With a strong ethos of craft running as a thread throughout each of these identified communities"},{"children":[{"children":null,"tag":"literal","value":"Software engineers, scientists, hackers and poets"}],"tag":"footnote","value":"136"},{"children":null,"tag":"literal","value":", well-written code is"},{"children":[{"children":null,"tag":"literal","value":"idiomatic code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". This implies that the reader and the writer both possess some knowledge of the specificities of the language or hardware that the code is being written with and executed with. This approach to craft thus resonates with a concept of mastery and technical excellence, but also with that of"},{"children":[{"children":null,"tag":"literal","value":"style"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". Style, in this case, highlights the acknowledgment of the social existence of code: by choosing style as a group marker rather than as an individual marker, a source code is judge positively based on its altruistic ethical nature—even if that style is enforced by software itself."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In this research, we have shown that code exhibits specific aesthetic properties, whether they are judged as being positive or negative. We have also shown that these positive or negative judgments are themselves the results of specific communities of practices—argumenting for a social conception of an aesthetic value judgment."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"More fundamentally, the aesthetic properties of source code are derived from a conception of code as a semantic material which in terms is assembled, and apprehended, as a spatial construct, rather than a strictly literary, mathematical, or architectural material. Code"},{"children":[{"children":null,"tag":"literal","value":"navigation"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", code"},{"children":[{"children":null,"tag":"literal","value":"structure"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"or"},{"children":[{"children":null,"tag":"literal","value":"code"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"compression, are terms which all belong to a lexical field of spatiality; the aesthetic properties of source code are tightly related to this apprehension of conceptual spaces constructed from machine-readable lexical tokens represeting problem domains—or, in other words,"},{"children":[{"children":null,"tag":"literal","value":"thought-stuff"}],"tag":"emph","value":""},{"children":[{"children":null,"tag":"literal","value":"brooks_mythical_1975"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"How does source code relate to other aesthetic fields?"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:conclusion-rq-2"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"These aesthetic properties were formalized through an empirical approach, whose first stage included the identification of the different lexical fields that programmers referred to in order to justify their aesthetic judgments of source code. Specifically, we have identified references to literature, architecture, mathematics and engineering. Each of these were used as a metaphorical device in order to better qualify source code (e.g. \"source code is"},{"children":[{"children":null,"tag":"literal","value":"like"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"literature"},{"children":null,"tag":"dots","value":""},{"children":null,"tag":"literal","value":"\")."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"To which aspect of source code did these references map to? Overall, we have identified two main aspects: semantic compression and spatial expression. Semantic expression concerns the ability of a notation to express complex concepts through quantitatively and qualitatively simple combination, while spatial expression concerns the ability of source code to be structured in such a way that is both evocative (the broad shape of things have a relative connotation to what things do) and sustainable (the structuring of a function ensures that a given action will not have unexpected side-effects)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"All of these references point to the fact that structure and expressivity are closely tied when it comes to source code. Furthermore, rather than being opposites of one another, each reference contributes to the purpose of source code aesthetics by clarifying the structure of the code at multiple levels and dimensions."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Literary aesthetics facilitate the comprehension of the scope of variables and of the intent of the programmer in relation with the problem domain. They denote the purpose and intent of specific values, expressions, declarations and statements in a natural language, with a potential both for poetic evokation, cryptic obfuscation, or plain misinterpretation. Despite Yukihiro Matsumoto and Donald Knuth's statements that writing source code is a literary art, this turns out to only be partially true: the most literary parts of source code—comments—are also the parts that are the most decoupled from the actual source code, and are entirely invisible to the machine."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A strictly literary understanding of source sets aside the particularities of the reading process of source code and the temporal control of the writer. A traditional, natural language literary work will assume a linear, front-to-back readership, while source code is defined by its potential ability to jump from any part of the text to any other part of the text. Given this radical difference, references to architectural aesthetics help to establish structural patterns of familiarity and spatiality. Even though it does not operate on concrete, \"natural\" space, the quality of the disposition and combination of the application components on the source code page enable a better navigation of the source code's conceptual space."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This reduction of a vast conceptual space to natural language representations, and presented as clear, delimited set of interrelated components  reveals the tension in source code between form, function, and the fundamental concepts of the function. In this respect, mathematical aesthetics enable the condensation of knowledge and insight in the least amount of tokens, minimizing noise, and related to poetic condensation. Particularly, this ability of representing complex ideas into simple terms is a process of"},{"children":[{"children":null,"tag":"literal","value":"compression"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"shared across poetry and mathematics, and resulting in an elegant structure."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This concept of elegance is also found at an overlap of mathematics and architecture, in the form of engineering. Robust, sparse and straightforward engineering is considered a beautiful achievement, one in which function, structure and skill are intertwined to produce the most with the least. Here, this definition of \"the most\" is not one based on performance or CPU cycles"},{"children":[{"children":null,"tag":"literal","value":"As mentioned previously, the most efficient code is machine generated and human-unreadable."}],"tag":"footnote","value":"137"},{"children":null,"tag":"literal","value":", but rather on its easing of the human's cognitive burden in understanding and engaging with the technical object that is source code."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Ultimately, all of these elements relate to communication and cognition, and to how the (invisible) purpose and intent of the code can be communicated in (visible) lines of a language straddling the line between machine and human comprehension. Literature, architecture, mathematics and engineering all rely on formal tokens to refer to"},{"children":[{"children":null,"tag":"literal","value":"something else"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", and their efficiency at doing so can be assessed by the reader's correct or erroneous estimation of what are the fundamental concepts of what is being communicated to them. Keywords, tokens and beacons are all elements which have been found to structure the writing and reading of source code, allow the programmer to establish a cognitive map of the abstract structure of the program text."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"How do the aesthetics of source code relate to its functionality?"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:conclusion-rq-3"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This final correlation of aesthetics the communication of intent and purpose now leads us to address our third research question: the connections between form and function in source code. we have shown that, in the case of software engineers, aesthetics can be used to facilitate understanding in a functional context, or that, in the case of hackers, aesthetics can be a display of a deep understanding of the material at hand. As for scientists and poets, aesthetics perform a role of compression of complex concepts (be they scientific or poetic) into a concrete form."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"However, the most crucial aspect of the aesthetics of source code is that they are rendered moot if the executed code does not perform as intended. In this case, there is a mismatch between what the original programmer(s) intended, and how the actual machine perfomance. This actuality can be referrenced in comments or documentations"},{"children":[{"children":null,"tag":"literal","value":"Such as \"TODOs\" notes or open issues in tracking software."}],"tag":"footnote","value":"138"},{"children":null,"tag":"literal","value":", but lacks any guarantee of synchronization: the programmer might say something and the machine do something different, and it is not"},{"children":[{"children":null,"tag":"literal","value":"clear"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"what exactly is that difference. In this case, the program text, as the only component of software taken into account by the computer, is also the only canonical source of investigation into restoring the nature of the programmer—its function."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In this sense, the quality of an aesthetic property can be judged on whether it adequately represents a given concept, behaviour or intent"},{"children":[{"children":null,"tag":"literal","value":"These are indeed three different things, but all involve some sort of some aspect of being remote for direct grasp."}],"tag":"footnote","value":"139"},{"children":null,"tag":"literal","value":". The unique aspect of this aesthetic judgment of source code is that there are indeed to judges: the human(s) and the machine, whereby the possibility for human assessment is dependent on the machine assessment. In all the different groups of writers identified,"},{"children":[{"children":null,"tag":"literal","value":"correctness"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"always conditions"},{"children":[{"children":null,"tag":"literal","value":"pleasantness"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This is only verified to a certain extent for poets, who do not require a program text to be functional in the machinic sense in order to be given an aesthetic value. Still, in the case that the poet does write a syntactically correct text from a machine perspective, and a semantically evocative text from a human person, the artistic quality of the work created emanates from this technical feat. This dual display of skill relates to a conception of art as a connection between the technological and magical highlighted in subsection"},{"children":[{"children":null,"tag":"literal","value":"subsubsec:software-relational"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":". Displaying artistic creativity within source code can thus be seen as a way to enchant the technology of software, by representing it as a technically excellent crafted object."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"This tight coupling of function and appearance, something already very present in modernist architecture and explored in section"},{"children":[{"children":null,"tag":"literal","value":"sec:arch-understanding"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":", echoes across theories of art as a language system used to express complex ideas, and practices of craft and toolmaking. Source code, while remaining subject to function, allows for a certain versatility in the expression of the concept (ranging from explicit to implicit) and, in turn, this expressivity depends on a given level of skill and practice in the idiosyncracies of the languages used. Related to our findings on the diversity of communities who read and write code, these communities are defined based on the purpose of the code they write, but there also exists a set of communities which are organized around the specific language that they use. The proficiency in a language involves a \"right way to do things\", and hints at the fact that there is a certain level of expertise is needed to assess the quality of the aesthetic properties of a source, and that the novice cannot be expected to provide an informed aesthetic value judgment."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Contribution"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:conclusion-contribution"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Overall, this thesis has aimed at showing that the formal properties of source code as a specific medium have a close relationship to"},{"children":[{"children":null,"tag":"literal","value":"episteme"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", itself conjugated in various contexts."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Because software, underpinned by source code, belongs first and foremost to the technological realm, embodying a function and an intent of what should be achieved, aesthetics are inscribed within this technological essence by enabling the communication of the complex ideas which constitute the basis of software (its ideal version, as opposed to its implemented version, and its process of implementation, as opposed to its result)."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"While psychological studies and consolidated practical knowledge have shown that particular kinds of layout and presentation are beneficial to program understanding (see section"},{"children":[{"children":null,"tag":"literal","value":"subsec:psychology-programming"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"), this is only one aspect of the system of aesthetic properties. Aesthetic values in source code are also based on the"},{"children":[{"children":null,"tag":"literal","value":"context"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"in which said source code is written or read. These values, while varying, are nonetheless recurrently depending on the relation with the program, the machine, and the audience of the program, as well as the intent of the use."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In order to achieve this epistemic function, and due to software's ambiguous nature as an"},{"children":[{"children":null,"tag":"literal","value":"abstract artifact"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":", a variety of aesthetics domains are summoned by programmers in order to make sense of what they describe as occurences of software beauty. Looking specifically at the overlap of these domains, we have shown that each aim at facilitating a transition between the surface-level syntax immediately accessible to the reader to the deep-level semantics of the topic at hand. Respectively, literature aims at evoking themes and stories (section"},{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-literature"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"), architecture aims at evoking atmospheres and functions (section"},{"children":[{"children":null,"tag":"literal","value":"sec:arch-understanding"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"), while mathematics tries to communicate theorems ("},{"children":[{"children":null,"tag":"literal","value":"sec:aesthetic-mathematics"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":") and engineering focuses on structural integrity and efficiency ("},{"children":[{"children":null,"tag":"literal","value":"subsec:aesthetic-engineering"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"), with all domains above modulated by an approach to craft."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"From the perspective of aesthetic theory, these findings also contribute to a conception of aesthetics as a communicative endeavour. Specifically, we have shown that the concept of aesthetics amongst programmers is not seen exclusively as an end to all things, but rather as a possible means to represent"},{"children":[{"children":null,"tag":"literal","value":"something"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"to"},{"children":[{"children":null,"tag":"literal","value":"someone"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":". As such, aesthetics acts as an expressive interface between a concept and two distinct individuals"},{"children":[{"children":null,"tag":"literal","value":"The assumption specific to source code being that the same individual differs over time."}],"tag":"footnote","value":"140"},{"children":null,"tag":"literal","value":". Located within the particular techno-social environment of source code, this communicative role is also subject to relatively clear assessments of success or failure. A successful communication is a communication which is correctly interpreted, whereby the original ideas transmitted from the writer via the program text are found in an equivalent representation in the reader. Here, the interpretation is, at minima, what the program does, and what the program intents to do, things that might not always be aligned, resulting in the provision of agency in correctly predicting the implications of the program's operations and in the ability to correctly modify the program."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The contributions of this thesis have therefore been in the development of an aesthetic understanding of source code through an interdisciplinary analysis of a discourse analysis, drawing across media studies (from literature to software studies), science and technology studies and aesthetic philosophy. These discourses were composed of a corpus of both program-texts and commentaries and analyses by practicioners of those program texts—reading and analyzing  XXXX INSERT EXACT NUMBER XXXX selected source code snippets. In this sense, we have extended on the contributions of Paloque-Bergès and MacLean and Cox by applying on their concepts of"},{"children":[{"children":null,"tag":"literal","value":"double-meaning"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and showing how this co-existence of computer meaning and human meaning extends beyong the more creative writings of source code, and across communities of source code writers."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In doing so, we have also confirmed and extended Piñeiros' work on describing code aesthetics as instrumental action, bridging his field of research of software developers with other kinds of source code, and confronting it with specific example. While Piñeiro's work thoroughly explores programmers' perspectives, it does not extend its findings to other aesthetic practices mentioned by programmers—by connecting it to literature, architecture, mathematics and engineering, we inscribe the practice of programming within a wider array of creative practices."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"I proposed a conceptualize of code as semantic matter, from which executable structures are built. This approach builds on Katherine Hayles' distinction between the media properties of print and code—the former being flat, the latter being deep. The contribution was to enrich our understanding of what code depth is made of, and how syntactical tokens create conceptual structures."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"I offered a typology of how to exert aesthetic properties in code, based on the purpose of aesthetics as a communicative endeavour with specific outcomes. This complements the perspectives provided in the Oram and Wilson's edited volume"},{"children":[{"children":null,"tag":"literal","value":"oram_beautiful_2007"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":". Instances of beautiful code have been given a theoretical framework as a criterai for belonging to the category of exhibiting positive aesthetic properties, beyond their praise by highly-skilled practitioners."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Through an empirical take, we have also qualified how Florian Cramer and his approach to source code as a form of magic relies on very concrete technical processes and habits across practices of source code writing. Building on the conception of Alfred Gell of art as the enchantment of technology, we have explicited what exactly are the complex technical hurdles and associated skills required to understand software (section"},{"children":[{"children":null,"tag":"literal","value":"subsec:software-complexity"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"). If there is magic in software, it is also manifested through the aesthetic appreciation of source code, particularly through hacking (section"},{"children":[{"children":null,"tag":"literal","value":"subsec:hackers"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":") and code poetry (section"},{"children":[{"children":null,"tag":"literal","value":"subsec:poets"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"), and examplified in works like"},{"children":[{"children":null,"tag":"literal","value":"forkbomb.pl"}],"tag":"inline_listing","value":""},{"children":null,"tag":"literal","value":"(see listing"},{"children":[{"children":null,"tag":"literal","value":"code:forkbomb"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":")."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":[{"children":[{"children":null,"tag":"literal","value":"./corpus/forkbomb.pl"}],"tag":"code","value":"perl"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"options","value":""},{"children":null,"tag":"literal","value":"forkbomb.pl is an artwork in the exhibited sense of the term, displaying conciseness along with expressive power through its technical expansion"}],"tag":"caption","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"code:forkbomb"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""}],"tag":"listing","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, this thesis has contributed to a text-based approach to software aesthetics, as compared to execution-based approaches, in which source code syntax and semantic tend to be set aside. Within those studies of code-dependent aesthetics, such as interface design"},{"children":[{"children":null,"tag":"literal","value":"fishwick_aesthetic_2001"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"or creative coding"},{"children":[{"children":null,"tag":"literal","value":"cox_aesthetic_2020"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":", the aim was to provide an account of how code, the material itself, offers in terms of representational specificities to enrich those studies."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Without directly contradicting any of the work mentioned in our literature review (see"},{"children":[{"children":null,"tag":"literal","value":"subsec:literature-review"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"), our conclusions offer a detailed account of the material origins upon which subsequent interpretations of code are based."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Limitations"}],"tag":"subsection","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"subsec:conclusion-limitations"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The first and most obvous of this limitation is that a lot of source code is not accessible. While originally a freely-circulating commodity, the emergence of proprietary software at the dawn of the 1980s"},{"children":[{"children":null,"tag":"literal","value":"hassett_impact_2012"}],"tag":"citation","value":""},{"children":null,"tag":"literal","value":"has drastically limited free and open access to source code. As such, most of the source code written by software engineers in a commercial context remains confidential. For hackers, due to the nature of the work as an"},{"children":[{"children":null,"tag":"literal","value":"ad hoc"}],"tag":"emph","value":""},{"children":null,"tag":"literal","value":"and localized practice, few examples are made publicly available, as they are often enmeshed in more commercial projects, themselves subject to property restrictions."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"A second limitation is the expertise level required not just in programming, but in idiomaticity—that is, in knowing how to best phrase an action in a specific languages, as addressed in subsection"},{"children":[{"children":null,"tag":"literal","value":"subsec:idiomaticity"}],"tag":"reference","value":""},{"children":null,"tag":"literal","value":"—and, to a lesser extent, in the relevant problem domains. This implication of having already a solid grasp on the technical and problem context can have affected the expositions of aesthetic judgments that I have given in this thesis. Consequently, it is inevitable that other experts programmers might have different opinions given their personal styles and backgrounds."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Finally, our focus on the knowledge-component of both aesthetics and source code has led us to venture into the application of cognitive sciences through empirical studies to fields such as programming, literature or architecture. Since this is still a burgeoning endeavour, in active research,  some of the connections evoked by the current literature between code and cognition, or beauty and cognition are still bound to evolve."}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"Opening"}],"tag":"section","value":""}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"sec:opening"}],"tag":"label","value":"conclusion"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Firmly grounded into aesthetic philosophy, this thesis has nonetheless aimed at expanding the domain of what is traditionally considered beautiful, and how it is considered so, by examining its relations with function and knowledge. Resulting from an interdisciplinary approach, the outcomes of this research therefore have some impact  on both the arts and sciences in general, and programming in particular."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Deliberately eschewing notions of the artistic in favor of the beautiful, the definition work at the beginning of this thesis implied that studies of beauty decoupled from art can be rich and fruitful, revealing a plethora of practices focusing on making something nice, rather than, e.g., gorgeous. This thesis is therefore inscribed in aesthetics of the everyday, and can suggest ways to apply aesthetic judgments to objects of study usually excluded from such. Additionally, we have shown how such objects—source code—possess mechanics of meaning-making of their own, enabling unique semantic structures."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Conversely, we also consider implications for programmers and craftspeople. Not that they need this work to realize that aesthetics and functionality are deeply intertwined, but rather as an explicit account of the ways in which this entanglement happens. For programmers, keeping in mind notions of scale, distance and metaphor within a particular source code would support better work. For other creators, we hope this would encourage them to investigate what is it that makes their material unique, and how it relates to other disciplines."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"Ultimately, this work also has ethical implication. Knowledge, by enabling one's agency, supports and encourages good work, as opposed to meaningless labour. By organizing program texts in such a way that the next individual can discover and understand underlying concepts transmitted through the medium of source code, one engages in an ethically altruistic behaviour, as opposed to self-reflexive references."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"spacer","value":""}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In closing, we see two main directions which can unfold form this thesis, either exploring the poetics of code, or the intricacies of cimputer-readable knowledge management."}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"The unfolding of digital media in the second half of the twentieth century has been seen as an epochal shift, along with other technologies of information reproduction and diffusion. However, computational media is specifici insofar as it can be compressed and unfolded under various forms (from electricity to three-dimensional graphical environments and highly-dimensional vector spaces in recent machine learning approaches). How does the shape of software impact knowledge management and transmission, not just for programmers, but for end users as well, starting from those in the information sciences such as librarians, educators, journalists, researchers, and expanding to anyone engaging in a meaning-making work within a computer environment. While aesthetics can help to signify complex concepts within source code, do those concepts translate at other interface levels, or do these subsequent levels hold aesthetics principles of their own?"}],"tag":"paragraph","value":""},{"children":[{"children":null,"tag":"literal","value":"In terms of poetics, or how the particular structure of a text has a particular effect on an audience, the question would be to which extent does source code structure model and affect the \"real world\""},{"children":[{"children":null,"tag":"literal","value":"Throughout this work, we have been referring to the \"real world\" as the problem domain."}],"tag":"footnote","value":"141"},{"children":null,"tag":"literal","value":". Particularly in terms of  time and space, as we have seen how the execution of source code enegage in a deeply different scale of both components of our experience of reality. In terms of moddelling, we could ask does a particular data structure, in how it is written, reveal social, political and economical agency? To what extent do languages such as Rust, Java or JavaScript influence the programmer's perception of the world? Could that effective impact be observed in an empirical manner? This move from form to consequence would look at an impact beyond programmers and at a broader audience. This relationship between form-giving and meaning-making in digital environments might start with those who write source code and compose electrical circuits, but affect all who engage with computers."}],"tag":"paragraph","value":""}],"tag":"root","value":""}],"tag":"include","value":"conclusion.tex"}],"tag":"paragraph","value":""},{"children":[{"children":[{"children":null,"tag":"literal","value":"thesis.bib"}],"tag":"bibliography","value":""}],"tag":"paragraph","value":""}],"tag":"document","value":""}],"tag":"paragraph","value":""}],"tag":"root","value":""}]